[{"file_name": "fht_1d_x8.v", "verilog_design": "`include \"fht_bfly_noFF.v\" `include \"fht_bfly.v\" module fht_1d_x8( rstn, sclk, x_valid, x_data, fht_valid, fht_data ); parameter N = 8; input rstn; input sclk; input x_valid; input [N-1:0] x_data; output fht_valid; output [N+2:0] fht_data; reg [N-1:0] x0,x1,x2,x3,x4,x5,x6,x7; always @(posedge sclk or negedge rstn) if (!rstn) begin x0 <= #1 0; x1 <= #1 0; x2 <= #1 0; x3 <= #1 0; x4 <= #1 0; x5 <= #1 0; x6 <= #1 0; x7 <= #1 0; end else if (x_valid) begin x0 <= #1 x_data; x1 <= #1 x0; x2 <= #1 x1; x3 <= #1 x2; x4 <= #1 x3; x5 <= #1 x4; x6 <= #1 x5; x7 <= #1 x6; end reg x_valid_1d; always @(posedge sclk or negedge rstn) if (!rstn) x_valid_1d <= #1 0; else x_valid_1d <= #1 x_valid; wire xi_ready; reg [2:0] cnt; always @(posedge sclk or negedge rstn) if (!rstn) cnt <= #1 0; else if (x_valid_1d) cnt <= #1 cnt + 1; assign xi_ready = (cnt == 7 && x_valid_1d) ? 1'b1 : 1'b0; reg [N-1:0] x0_FF,x1_FF,x2_FF,x3_FF,x4_FF,x5_FF,x6_FF,x7_FF; always @(posedge sclk or negedge rstn) if (!rstn) begin x0_FF <= #1 0; x1_FF <= #1 0; x2_FF <= #1 0; x3_FF <= #1 0; x4_FF <= #1 0; x5_FF <= #1 0; x6_FF <= #1 0; x7_FF <= #1 0; end else if (xi_ready) begin x0_FF <= #1 x7; x1_FF <= #1 x6; x2_FF <= #1 x5; x3_FF <= #1 x4; x4_FF <= #1 x3; x5_FF <= #1 x2; x6_FF <= #1 x1; x7_FF <= #1 x0; end reg [13:0] xi_ready_d; always @(posedge sclk or negedge rstn) if (!rstn) xi_ready_d[13:0] <= #1 0; else xi_ready_d[13:0] <= #1 {xi_ready_d[12:0],xi_ready}; wire [N:0] stg1_sum1; wire [N:0] stg1_sum2; wire [N:0] stg1_sum3; wire [N:0] stg1_sum4; wire [N:0] stg1_sub1; wire [N:0] stg1_sub2; wire [N:0] stg1_sub3; wire [N:0] stg1_sub4; fht_bfly_noFF #(N) u11_fht_bfly (.a({x0_FF}),.b({x4_FF}),.c(stg1_sum1),.d(stg1_sub1)); fht_bfly_noFF #(N) u12_fht_bfly (.a({x1_FF}),.b({x5_FF}),.c(stg1_sum2),.d(stg1_sub2)); fht_bfly_noFF #(N) u13_fht_bfly (.a({x2_FF}),.b({x6_FF}),.c(stg1_sum3),.d(stg1_sub3)); fht_bfly_noFF #(N) u14_fht_bfly (.a({x3_FF}),.b({x7_FF}),.c(stg1_sum4),.d(stg1_sub4)); wire [N+1:0] stg2_sum1; wire [N+1:0] stg2_sum2; wire [N+1:0] stg2_sum3; wire [N+1:0] stg2_sub1; wire [N+1:0] stg2_sub2; wire [N+1:0] stg2_sub3; fht_bfly #(N+1) u21_fht_bfly (.rstn(rstn),.clk(sclk),.valid(xi_ready_d[1]),.a(stg1_sum1),.b(stg1_sum3),.c(stg2_sum1),.d(stg2_sub1)); fht_bfly #(N+1) u22_fht_bfly (.rstn(rstn),.clk(sclk),.valid(xi_ready_d[1]),.a(stg1_sum2),.b(stg1_sum4),.c(stg2_sum2),.d(stg2_sub2)); fht_bfly #(N+1) u23_fht_bfly (.rstn(rstn),.clk(sclk),.valid(xi_ready_d[1]),.a(stg1_sub1),.b(stg1_sub3),.c(stg2_sum3),.d(stg2_sub3)); wire [N:0] mult_dat_1; wire [N:0] mult_dat_2; assign mult_dat_1 = stg1_sub2; assign mult_dat_2 = stg1_sub4; wire [N+1:0] mult_res1; wire [N+1:0] mult_res2; `ifdef USE_ASIC_MULT signed_mult_const_asic #(N+1) u_mult_1_fht (rstn,sclk,xi_ready_d[1],mult_dat_1,mult_res1); signed_mult_const_asic #(N+1) u_mult_2_fht (rstn,sclk,xi_ready_d[1],mult_dat_2,mult_res2); `elsif USE_FPGA_MULT signed_mult_const_fpga #(N+1) u_mult_1_fht (rstn,sclk,xi_ready_d[1],mult_dat_1,mult_res1); signed_mult_const_fpga #(N+1) u_mult_2_fht (rstn,sclk,xi_ready_d[1],mult_dat_2,mult_res2); `endif wire [N+2:0] stg3_sum1; wire [N+2:0] stg3_sum2; wire [N+2:0] stg3_sum3; wire [N+2:0] stg3_sum4; wire [N+2:0] stg3_sub1; wire [N+2:0] stg3_sub2; wire [N+2:0] stg3_sub3; wire [N+2:0] stg3_sub4; fht_bfly #(N+2) u31_fht_bfly (.rstn(rstn),.clk(sclk),.valid(xi_ready_d[3]),.a(stg2_sum1),.b(stg2_sum2),.c(stg3_sum1),.d(stg3_sub1)); fht_bfly #(N+2) u32_fht_bfly (.rstn(rstn),.clk(sclk),.valid(xi_ready_d[3]),.a(stg2_sub1),.b(stg2_sub2),.c(stg3_sum2),.d(stg3_sub2)); fht_bfly #(N+2) u33_fht_bfly (.rstn(rstn),.clk(sclk),.valid(xi_ready_d[3]),.a(stg2_sum3),.b(mult_res1),.c(stg3_sum3),.d(stg3_sub3)); fht_bfly #(N+2) u34_fht_bfly (.rstn(rstn),.clk(sclk),.valid(xi_ready_d[3]),.a(stg2_sub3),.b(mult_res2),.c(stg3_sum4),.d(stg3_sub4)); reg [N+2:0] h0_FF,h1_FF,h2_FF,h3_FF,h4_FF,h5_FF,h6_FF,h7_FF; always @(posedge sclk or negedge rstn) if (!rstn) begin h0_FF <= #1 0; h4_FF <= #1 0; h2_FF <= #1 0; h6_FF <= #1 0; h1_FF <= #1 0; h5_FF <= #1 0; h3_FF <= #1 0; h7_FF <= #1 0; end else if (xi_ready_d[5]) begin h0_FF <= #1 stg3_sum1; h4_FF <= #1 stg3_sub1; h2_FF <= #1 stg3_sum2; h6_FF <= #1 stg3_sub2; h1_FF <= #1 stg3_sum3; h5_FF <= #1 stg3_sub3; h3_FF <= #1 stg3_sum4; h7_FF <= #1 stg3_sub4; end wire h0_valid; wire h1_valid; wire h2_valid; wire h3_valid; wire h4_valid; wire h5_valid; wire h6_valid; wire h7_valid; assign h0_valid = xi_ready_d[6]; assign h1_valid = xi_ready_d[7]; assign h2_valid = xi_ready_d[8]; assign h3_valid = xi_ready_d[9]; assign h4_valid = xi_ready_d[10]; assign h5_valid = xi_ready_d[11]; assign h6_valid = xi_ready_d[12]; assign h7_valid = xi_ready_d[13]; wire fht_valid_or; assign fht_valid_or = h0_valid | h1_valid | h2_valid | h3_valid | h4_valid | h5_valid | h6_valid | h7_valid ; wire [N+2:0] h_or_data; assign h_or_data = (h0_FF & {N+3{h0_valid}}) | (h1_FF & {N+3{h1_valid}}) | (h2_FF & {N+3{h2_valid}}) | (h3_FF & {N+3{h3_valid}}) | (h4_FF & {N+3{h4_valid}}) | (h5_FF & {N+3{h5_valid}}) | (h6_FF & {N+3{h6_valid}}) | (h7_FF & {N+3{h7_valid}}) ; reg [N+2:0] fht_data; reg fht_valid; always @(posedge sclk or negedge rstn) if (!rstn) fht_valid <= #1 0; else fht_valid <= #1 fht_valid_or; always @(posedge sclk or negedge rstn) if (!rstn) fht_data <= #1 0; else fht_data <= #1 h_or_data; endmodule", "assertions_gpt_4o": "(x_valid == 1) |-> (x0 == x_data);\n(x_valid == 1) |-> (x1 == x0);\n(x_valid == 1) |-> (x2 == x1);\n(x_valid == 1) |-> (x3 == x2);\n(x_valid == 1) |-> (x4 == x3);\n(x_valid == 1) |-> (x5 == x4);\n(x_valid == 1) |-> (x6 == x5);\n(x_valid == 1) |-> (x7 == x6);\n(x_valid == 0) |-> (x0 == x0);\n(x_valid == 0) |-> (x1 == x1);\n(x_valid == 0) |-> (x2 == x2);\n(x_valid == 0) |-> (x3 == x3);\n(x_valid == 0) |-> (x4 == x4);\n(x_valid == 0) |-> (x5 == x5);\n(x_valid == 0) |-> (x6 == x6);\n(x_valid == 0) |-> (x7 == x7);\n(xi_ready == 1) |-> (x0_FF == x7);\n(xi_ready == 1) |-> (x1_FF == x6);\n(xi_ready == 1) |-> (x2_FF == x5);\n(xi_ready == 1) |-> (x3_FF == x4);\n(xi_ready == 1) |-> (x4_FF == x3);\n(xi_ready == 1) |-> (x5_FF == x2);\n(xi_ready == 1) |-> (x6_FF == x1);\n(xi_ready == 1) |-> (x7_FF == x0);\n(xi_ready == 0) |-> (x0_FF == x0_FF);\n(xi_ready == 0) |-> (x1_FF == x1_FF);\n(xi_ready == 0) |-> (x2_FF == x2_FF);\n(xi_ready == 0) |-> (x3_FF == x3_FF);\n(xi_ready == 0) |-> (x4_FF == x4_FF);\n(xi_ready == 0) |-> (x5_FF == x5_FF);\n(xi_ready == 0) |-> (x6_FF == x6_FF);\n(xi_ready == 0) |-> (x7_FF == x7_FF);\n(xi_ready_d[5] == 1) |-> (h0_FF == stg3_sum1);\n(xi_ready_d[5] == 1) |-> (h4_FF == stg3_sub1);\n(xi_ready_d[5] == 1) |-> (h2_FF == stg3_sum2);\n(xi_ready_d[5] == 1) |-> (h6_FF == stg3_sub2);\n(xi_ready_d[5] == 1) |-> (h1_FF == stg3_sum3);\n(xi_ready_d[5] == 1) |-> (h5_FF == stg3_sub3);\n(xi_ready_d[5] == 1) |-> (h3_FF == stg3_sum4);\n(xi_ready_d[5] == 1) |-> (h7_FF == stg3_sub4);\n(xi_ready_d[5] == 0) |-> (h0_FF == h0_FF);\n(xi_ready_d[5] == 0) |-> (h4_FF == h4_FF);\n(xi_ready_d[5] == 0) |-> (h2_FF == h2_FF);\n(xi_ready_d[5] == 0) |-> (h6_FF == h6_FF);\n(xi_ready_d[5] == 0) |-> (h1_FF == h1_FF);\n(xi_ready_d[5] == 0) |-> (h5_FF == h5_FF);\n(xi_ready_d[5] == 0) |-> (h3_FF == h3_FF);\n(xi_ready_d[5] == 0) |-> (h7_FF == h7_FF);\n(fht_valid_or == 1) |-> (fht_valid == 1);\n(fht_valid_or == 0) |-> (fht_valid == 0);\n(fht_valid_or == 1) |-> (fht_data == h_or_data);\n(fht_valid_or == 0) |-> (fht_data == fht_data);"}, {"file_name": "fht_8x8_core.v", "verilog_design": "`include \"fht_1d_x8.v\" `include \"mtx_trps_8x8_dpsram.v\" module fht_8x8_core ( rstn, sclk, x_valid, x_data, fht_2d_valid, fht_2d_data ); parameter N = 8; input rstn; input sclk; input x_valid; input [N-1:0] x_data; output fht_2d_valid; output [N+5:0] fht_2d_data; wire fht_1d_valid; wire [N+2:0] fht_1d_data; fht_1d_x8 #(N) u1_fht_1d_x8_1st( .rstn (rstn), .sclk (sclk), .x_valid (x_valid), .x_data (x_data), .fht_valid (fht_1d_valid), .fht_data (fht_1d_data) ); wire mem_valid; wire [N+2:0] mem_data; mtx_trps_8x8_dpsram #(N+3) u2_mtx_ts ( .rstn (rstn), .sclk (sclk), .inp_valid (fht_1d_valid), .inp_data (fht_1d_data), .mem_data (mem_data), .mem_valid (mem_valid) ); fht_1d_x8 #(N+3) u3_fht_1d_x8_2nd( .rstn (rstn), .sclk (sclk), .x_valid (mem_valid), .x_data (mem_data), .fht_valid (fht_2d_valid), .fht_data (fht_2d_data) ); endmodule", "assertions_gpt_4o": "1. (x_valid == 1) |-> (u1_fht_1d_x8_1st.fht_valid == 1);\n2. (u1_fht_1d_x8_1st.fht_valid == 1) |-> (u2_mtx_ts.inp_valid == 1);\n3. (u2_mtx_ts.inp_valid == 1) |-> (u2_mtx_ts.mem_valid == 1);\n4. (u2_mtx_ts.mem_valid == 1) |-> (u3_fht_1d_x8_2nd.x_valid == 1);\n5. (u3_fht_1d_x8_2nd.x_valid == 1) |-> (fht_2d_valid == 1);\n6. (rstn == 0) |-> (fht_2d_valid == 0);\n7. (rstn == 0) |-> (u1_fht_1d_x8_1st.fht_valid == 0);\n8. (rstn == 0) |-> (u2_mtx_ts.mem_valid == 0);\n9. (rstn == 0) |-> (u3_fht_1d_x8_2nd.fht_valid == 0);\n10. (u1_fht_1d_x8_1st.fht_valid == 1) |-> (u1_fht_1d_x8_1st.fht_data == fht_1d_data);\n11. (u2_mtx_ts.mem_valid == 1) |-> (u2_mtx_ts.mem_data == mem_data);\n12. (u3_fht_1d_x8_2nd.fht_valid == 1) |-> (u3_fht_1d_x8_2nd.fht_data == fht_2d_data);"}, {"file_name": "fht_bfly.v", "verilog_design": "module fht_bfly( rstn, clk, valid, a, b, c, d ); parameter N = 8; input rstn; input clk; input valid; input [N-1:0] a; input [N-1:0] b; output [N :0] c; output [N :0] d; reg [N-1:0] a_FF; always @(posedge clk) if (!rstn) a_FF <= #1 0; else if (valid) a_FF <= #1 a; reg [N-1:0] b_FF; always @(posedge clk) if (!rstn) b_FF <= #1 0; else if (valid) b_FF <= #1 b; assign c = rca_N(a_FF,b_FF); assign d = rca_N(a_FF,twos_complement(b_FF)); function [1:0] full_adder; input a, b, ci; reg co, s; begin s = (a ^ b ^ ci); co = (a & b) | (ci & (a ^ b)); full_adder = {co,s}; end endfunction function [1:0] half_adder; input a, b; reg co, s; begin s = (a ^ b); co = (a & b); half_adder = {co,s}; end endfunction function [N:0] rca_N; input [N-1:0] a; input [N-1:0] b; reg [N-1:0] co,sum; begin : RCA integer i; for (i = 0; i < N; i = i + 1) if (i == 0) {co[i],sum[i]} = half_adder(a[i],b[i]); else {co[i],sum[i]} = full_adder(a[i],b[i],co[i-1]); rca_N[N-1:0] = sum; rca_N[N] = (a[N-1]==b[N-1]) ? co[N-1] : sum[N-1]; end endfunction function [N-1:0] twos_complement; input [N-1:0] a; reg [N-1:0] ainv; reg [N:0] plus1; begin ainv = ~a; plus1 = rca_N(ainv,{{N-1{1'b0}},1'b1}); if (a == {1'b1, {N-1{1'b0}}}) $display(\"--->>> 2's complement ERROR - absolute minimum negative value: %0b\\n\\t %m\",a); twos_complement = plus1[N-1:0]; end endfunction endmodule", "assertions_gpt_4o": "(valid == 1) |-> (a_FF == a);\n(valid == 1) |-> (b_FF == b);\n(!rstn) |-> (a_FF == 0);\n(!rstn) |-> (b_FF == 0);\n(valid == 0) |-> (a_FF == a_FF);\n(valid == 0) |-> (b_FF == b_FF);\n(c == rca_N(a_FF, b_FF));\n(d == rca_N(a_FF, twos_complement(b_FF)));"}, {"file_name": "fht_bfly_noFF.v", "verilog_design": "module fht_bfly_noFF( rstn, clk, valid, a, b, c, d ); parameter N = 8; input rstn; input clk; input valid; input [N-1:0] a; input [N-1:0] b; output [N :0] c; output [N :0] d; reg [N-1:0] a_FF; always @(posedge clk) if (!rstn) a_FF <= #1 0; else if (valid) a_FF <= #1 a; reg [N-1:0] b_FF; always @(posedge clk) if (!rstn) b_FF <= #1 0; else if (valid) b_FF <= #1 b; assign c = rca_N(a_FF,b_FF); assign d = rca_N(a_FF,twos_complement(b_FF)); function [1:0] full_adder; input a, b, ci; reg co, s; begin s = (a ^ b ^ ci); co = (a & b) | (ci & (a ^ b)); full_adder = {co,s}; end endfunction function [1:0] half_adder; input a, b; reg co, s; begin s = (a ^ b); co = (a & b); half_adder = {co,s}; end endfunction function [N:0] rca_N; input [N-1:0] a; input [N-1:0] b; reg [N-1:0] co,sum; begin : RCA integer i; for (i = 0; i < N; i = i + 1) if (i == 0) {co[i],sum[i]} = half_adder(a[i],b[i]); else {co[i],sum[i]} = full_adder(a[i],b[i],co[i-1]); rca_N[N-1:0] = sum; rca_N[N] = (a[N-1]==b[N-1]) ? co[N-1] : sum[N-1]; end endfunction function [N-1:0] twos_complement; input [N-1:0] a; reg [N-1:0] ainv; reg [N:0] plus1; begin ainv = ~a; plus1 = rca_N(ainv,{{N-1{1'b0}},1'b1}); if (a == {1'b1, {N-1{1'b0}}}) $display(\"--->>> 2's complement ERROR - absolute minimum negative value: %0b\\n\\t %m\",a); twos_complement = plus1[N-1:0]; end endfunction endmodule", "assertions_gpt_4o": "(valid == 1) |-> (a_FF == a);\n(valid == 1) |-> (b_FF == b);\n(!rstn) |-> (a_FF == 0);\n(!rstn) |-> (b_FF == 0);\n(valid == 0) |-> (a_FF == $past(a_FF));\n(valid == 0) |-> (b_FF == $past(b_FF));\n(c == rca_N(a_FF, b_FF));\n(d == rca_N(a_FF, twos_complement(b_FF)));"}, {"file_name": "mtx_trps_8x8_dpsram.v", "verilog_design": "module mtx_trps_8x8_dpsram ( rstn, sclk, inp_valid, inp_data, mem_data, mem_valid ); parameter N = 8; input rstn; input sclk; input inp_valid; input [N-1:0] inp_data; output [N-1:0] mem_data; output mem_valid; reg [6:0] cnt128d_wr; wire indicator; reg indicator_1d; wire indicator_pos_edge; wire indicator_neg_edge; reg [6:0] cnt128d_rd; wire cnt128d_rd_valid_start; wire cnt128d_rd_valid_stop; reg cnt128d_rd_valid; reg mem_valid; wire [15:0] wr_DATA; wire [ 6:0] wr_ADDR; wire wr_CSN; wire wr_WEN; wire [ 6:0] rd_ADDR; wire rd_CSN; wire [15:0] rd_DATA; `ifdef USE_FPGA_SPSRAM dpsram_128x16 u_dpsram( .addra (wr_ADDR), .addrb (rd_ADDR), .clka (sclk), .clkb (sclk), .dina (wr_DATA), .dinb ({16{1'b0}}), .douta (), .doutb (rd_DATA), .ena (wr_CSN), .enb (rd_CSN), .wea (wr_WEN), .web (1'b1) ); `endif `ifdef USE_ASIC_SPSRAM reg [15:0] rd_DATA = 16'd0; reg [15:0] sram[0:127]; always @(posedge sclk) if (~wr_WEN && ~wr_CSN) sram[wr_ADDR] <= wr_DATA; always @(posedge sclk) if ( 1'b1 && ~rd_CSN) rd_DATA <= sram[rd_ADDR]; `endif always @(posedge sclk or negedge rstn) if (!rstn) cnt128d_wr <= #1 0; else if (inp_valid) cnt128d_wr <= #1 cnt128d_wr + 1; assign wr_DATA = {{16-N{1'b0}},inp_data}; assign wr_ADDR = cnt128d_wr; assign wr_CSN = ~inp_valid; assign wr_WEN = ~inp_valid; assign indicator = cnt128d_wr[6]; always @(posedge sclk or negedge rstn) if (!rstn) indicator_1d <= #1 1'b0; else indicator_1d <= #1 indicator; assign indicator_pos_edge = indicator & ~indicator_1d; assign indicator_neg_edge = ~indicator & indicator_1d; assign cnt128d_rd_valid_start = indicator_pos_edge | indicator_neg_edge; assign cnt128d_rd_valid_stop = (cnt128d_rd[5:0] == 63) ? 1'b1 : 1'b0; always @(posedge sclk or negedge rstn) if (!rstn) cnt128d_rd_valid <= #1 1'b0; else if (cnt128d_rd_valid_start)cnt128d_rd_valid <= #1 1'b1; else if (cnt128d_rd_valid_stop) cnt128d_rd_valid <= #1 1'b0; always @(posedge sclk or negedge rstn) if (!rstn) cnt128d_rd <= #1 1'b0; else if (cnt128d_rd_valid) cnt128d_rd <= #1 cnt128d_rd + 1; assign rd_ADDR = {cnt128d_rd[6],cnt128d_rd[2:0],cnt128d_rd[5:3]}; assign rd_CSN = ~cnt128d_rd_valid; always @(posedge sclk or negedge rstn) if (!rstn) mem_valid <= #1 1'b0; else mem_valid <= #1 cnt128d_rd_valid; assign #1 mem_data = rd_DATA[7:0]; endmodule", "assertions_gpt_4o": "(cnt128d_wr == 0) |-> (wr_ADDR == 0);\n(inp_valid == 1) |-> (wr_CSN == 0);\n(inp_valid == 1) |-> (wr_WEN == 0);\n(indicator_pos_edge || indicator_neg_edge) |-> (cnt128d_rd_valid_start == 1);\n(cnt128d_rd[5:0] == 63) |-> (cnt128d_rd_valid_stop == 1);\n(cnt128d_rd_valid_start == 1) |-> (cnt128d_rd_valid == 1);\n(cnt128d_rd_valid_stop == 1) |-> (cnt128d_rd_valid == 0);\n(cnt128d_rd_valid == 1) |-> (rd_CSN == 0);\n(cnt128d_rd_valid == 0) |-> (rd_CSN == 1);\n(cnt128d_rd_valid == 1) |-> (mem_valid == 1);\n(cnt128d_rd_valid == 0) |-> (mem_valid == 0);\n(mem_valid == 1) |-> (mem_data == rd_DATA[7:0]);\n(wr_CSN == 0 && wr_WEN == 0) |-> (sram[wr_ADDR] == wr_DATA);\n(rd_CSN == 0) |-> (rd_DATA == sram[rd_ADDR]);"}, {"file_name": "signed_mult_const_asic.v", "verilog_design": "module signed_mult_const_asic ( rstn, clk, valid, a, p ); parameter N = 8; input rstn; input clk; input valid; input [N-1:0] a; output [N :0] p; parameter mult_constant = 9'd362; reg [N-1:0] a_FF; always @(posedge clk) if (!rstn) a_FF <= #1 0; else if (valid) a_FF <= #1 a; wire [N-1:0] b; assign b = a_FF[N-1] ? {~a_FF[N-1:0] + {{N-1{1'b0}},1'b1} } : a_FF[N-1:0]; wire [N+7:0] mult_wo_sign; assign mult_wo_sign = b[N-2:0]*mult_constant; wire [N-1:0] div256; assign div256 = mult_wo_sign >> 8; assign p = a_FF[N-1] ? {1'b1,{~div256[N-1:0] + {{N-1{1'b0}},1'b1}} } : {1'b0, div256[N-1:0]} ; endmodule", "assertions_gpt_4o": "(valid == 1) |-> (a_FF == a);\n(!rstn) |-> (a_FF == 0);\n(a_FF[N-1] == 1) |-> (b == {~a_FF[N-1:0] + {{N-1{1'b0}},1'b1}});\n(a_FF[N-1] == 0) |-> (b == a_FF[N-1:0]);\n(mult_wo_sign == b[N-2:0]*mult_constant);\n(div256 == mult_wo_sign >> 8);\n(a_FF[N-1] == 1) |-> (p == {1'b1,{~div256[N-1:0] + {{N-1{1'b0}},1'b1}}});\n(a_FF[N-1] == 0) |-> (p == {1'b0, div256[N-1:0]});"}, {"file_name": "signed_mult_const_fpga.v", "verilog_design": "module signed_mult_const_fpga ( rstn, clk, valid, a, p ); parameter N = 8; input rstn; input clk; input valid; input signed [N-1:0] a; output signed [N :0] p; parameter mult_constant = {1'b0, 17'd92681}; reg signed [N-1:0] a_FF; always @(posedge clk) if (!rstn) a_FF <= #1 0; else if (valid) a_FF <= #1 a; wire signed [(16+1)+N-1:0] p_tmp = $signed(a_FF) * $signed(mult_constant); assign p = p_tmp >> 16; endmodule", "assertions_gpt_4o": "(valid == 1) |-> (a_FF == a);\n(!rstn) |-> (a_FF == 0);\n(valid == 0) |-> (a_FF == a_FF);\n(p == (a_FF * mult_constant) >> 16);\n(valid == 1) |-> (p == ($signed(a) * $signed(mult_constant)) >> 16);"}, {"file_name": "accMUX.v", "verilog_design": "`include \"timescale.v\" `include \"defines.v\" module accumulatorMUX (accMuxSel, immData, aluOut `ifdef timerAndCounter_peripheral , tcLoadIn, tcAccIn `endif `ifdef UART_peripheral , uartDataIn, uartStatIn `endif , accMuxOut ); input [`accMuxSelLen-1:0] accMuxSel; input [`immDataLen-1:0] immData; input [7:0] aluOut; `ifdef timerAndCounter_peripheral input [7:0] tcLoadIn, tcAccIn; `endif `ifdef UART_peripheral input [7:0] uartDataIn, uartStatIn; `endif output [7:0] accMuxOut; reg [7:0] accMuxOut; always @ * begin case (accMuxSel) `accMuxSelImmData : begin accMuxOut = immData; end `accMuxSelAluOut : begin accMuxOut = aluOut; end `ifdef timerAndCounter_peripheral `accMuxSelTcLoad : begin accMuxOut = tcLoadIn; end `accMuxSelTcAcc : begin accMuxOut = tcAccIn; end `endif `ifdef UART_peripheral `accMuxSelUartData : begin accMuxOut = uartDataIn; end `accMuxSelUartStat : begin accMuxOut = uartStatIn; end `endif default : begin accMuxOut = 8'bzzzzzzzz; end endcase end endmodule", "assertions_gpt_4o": "1. (accMuxSel == `accMuxSelImmData) |-> (accMuxOut == immData);\n2. (accMuxSel == `accMuxSelAluOut) |-> (accMuxOut == aluOut);\n3. `ifdef timerAndCounter_peripheral (accMuxSel == `accMuxSelTcLoad) |-> (accMuxOut == tcLoadIn); `endif\n4. `ifdef timerAndCounter_peripheral (accMuxSel == `accMuxSelTcAcc) |-> (accMuxOut == tcAccIn); `endif\n5. `ifdef UART_peripheral (accMuxSel == `accMuxSelUartData) |-> (accMuxOut == uartDataIn); `endif\n6. `ifdef UART_peripheral (accMuxSel == `accMuxSelUartStat) |-> (accMuxOut == uartStatIn); `endif\n7. (accMuxSel != `accMuxSelImmData && accMuxSel != `accMuxSelAluOut `ifdef timerAndCounter_peripheral && accMuxSel != `accMuxSelTcLoad && accMuxSel != `accMuxSelTcAcc `endif `ifdef UART_peripheral && accMuxSel != `accMuxSelUartData && accMuxSel != `accMuxSelUartStat `endif) |-> (accMuxOut == 8'bzzzzzzzz);"}, {"file_name": "bitNegator.v", "verilog_design": "`include \"timescale.v\" `include \"defines.v\" module bitNegator (bitIn, bitN, bitOut); input bitIn, bitN; output bitOut; reg bitOut; always @ (bitIn or bitN) begin if (bitN) begin bitOut = ~ bitIn; end else begin bitOut = bitIn; end end endmodule", "assertions_gpt_4o": "(bitN == 1) |-> (bitOut == ~bitIn);\n(bitN == 0) |-> (bitOut == bitIn);\n(bitOut == ~bitIn) |-> (bitN == 1);\n(bitOut == bitIn) |-> (bitN == 0);"}, {"file_name": "ramBit.v", "verilog_design": "`include \"timescale.v\" `include \"defines.v\" module bitRam (clk, reset, bitRamEn, bitRamRw, bitRamIn, bitRamAddr, bitRamOut); input clk, reset, bitRamEn, bitRamRw, bitRamIn; input [`bitRamAddrLen-1:0] bitRamAddr; output bitRamOut; reg bitRam [`bitRamDepth-1:0]; reg bitRamOut; always @ (posedge clk or posedge reset) begin if (reset) begin bitRamOut = 1'b0; $write (\"\\nmodule bitRam is reset \"); end else begin if (bitRamEn) begin if (bitRamRw) begin bitRamOut = bitRam[bitRamAddr]; end else begin bitRam[bitRamAddr] = bitRamIn; end end else begin bitRamOut = 1'bZ; end end end endmodule", "assertions_gpt_4o": "(bitRamEn == 1 & bitRamRw == 1) |-> (bitRamOut == bitRam[bitRamAddr]);\n(bitRamEn == 1 & bitRamRw == 0) |-> (bitRam[bitRamAddr] == bitRamIn);\n(bitRamEn == 0) |-> (bitRamOut == 1'bZ);\n(reset == 1) |-> (bitRamOut == 1'b0);\n(bitRamEn == 1 & bitRamRw == 1) |-> (bitRamOut != 1'bZ);\n(bitRamEn == 1 & bitRamRw == 0) |-> (bitRamOut != 1'bZ);"}, {"file_name": "byteNegator.v", "verilog_design": "`include \"timescale.v\" `include \"defines.v\" module byteNegator (byteIn, byteN, byteOut); input [7:0] byteIn; input byteN; output [7:0] byteOut; reg [7:0] byteOut; always @ (byteIn or byteN) begin if (byteN) begin byteOut = ~ byteIn; end else begin byteOut = byteIn; end end endmodule", "assertions_gpt_4o": "(byteN == 1) |-> (byteOut == ~byteIn);\n(byteN == 0) |-> (byteOut == byteIn);\n(byteOut == ~byteIn) |-> (byteN == 1);\n(byteOut == byteIn) |-> (byteN == 0);"}, {"file_name": "ramByte.v", "verilog_design": "`include \"timescale.v\" `include \"defines.v\" module byteRam (clk, reset, byteRamEn, byteRamRw, byteRamIn, byteRamAddr, byteRamOut); input clk, reset, byteRamEn, byteRamRw; input [`byteRamLen-1:0] byteRamIn; input [`byteRamAddrLen-1:0] byteRamAddr; output [`byteRamLen-1:0] byteRamOut; reg [`byteRamLen-1:0] byteRam [`byteRamDepth-1:0]; reg [`byteRamLen-1:0] byteRamOut; always @ (posedge clk or posedge reset) begin if (reset) begin byteRamOut = `byteRamLen'b0; $write (\"\\nmodule byteRam is reset \"); end else begin if (byteRamEn) begin if (byteRamRw) begin byteRamOut = byteRam[byteRamAddr]; end else begin byteRam[byteRamAddr] = byteRamIn; end end else begin byteRamOut = `byteRamLen'bz; end end end endmodule", "assertions_gpt_4o": "(reset) |-> (byteRamOut == `byteRamLen'b0);\n(byteRamEn & byteRamRw) |-> (byteRamOut == byteRam[byteRamAddr]);\n(byteRamEn & ~byteRamRw) |-> (byteRam[byteRamAddr] == byteRamIn);\n(~byteRamEn) |-> (byteRamOut == `byteRamLen'bz);"}, {"file_name": "inputReg.v", "verilog_design": "`include \"timescale.v\" `include \"defines.v\" module inputRegister (inputs, inputReadAddr, inputReadOut); input [`inputNumber-1:0] inputs; input [`inputAddrLen-1:0] inputReadAddr; output inputReadOut; wire [`inputNumber-1:0] inputs; assign inputReadOut = inputs[inputReadAddr]; endmodule", "assertions_gpt_4o": "(inputReadAddr < `inputNumber) |-> (inputReadOut == inputs[inputReadAddr]);"}, {"file_name": "outputReg.v", "verilog_design": "`include \"timescale.v\" `include \"defines.v\" module outputReg (reset, outputRw, outputRwAddr, outputWriteIn, outputReadOut, outputs); input reset, outputRw; input [`outputAddrLen-1:0] outputRwAddr; input outputWriteIn; output outputReadOut; output wire [`outputNumber-1:0] outputs; reg outputReadOut; reg [`outputNumber-1 :0] outputReg = 0; always @ (reset or outputRw or outputRwAddr or outputWriteIn or outputReg) begin if (reset) begin outputReadOut = 1'bz; $write (\"\\nmodule outputRegister is reset \"); end else begin if (outputRw) begin outputReadOut = outputReg[outputRwAddr]; end else begin outputReg[outputRwAddr] = outputWriteIn; $write (\"\\nwriting to the output register : module outputRegister \"); end end end assign outputs = outputReg; endmodule", "assertions_gpt_4o": "1. (reset) |-> (outputReadOut == 1'bz);\n2. (!reset & outputRw) |-> (outputReadOut == outputReg[outputRwAddr]);\n3. (!reset & !outputRw) |-> (outputReg[outputRwAddr] == outputWriteIn);\n4. (!reset & !outputRw) |-> (outputReadOut == 1'bz);\n5. (outputReg[outputRwAddr] == outputWriteIn) |-> (!outputRw);\n6. (outputReadOut == outputReg[outputRwAddr]) |-> (outputRw);\n7. (outputs == outputReg) |-> (!reset);"}, {"file_name": "ppReg1.v", "verilog_design": "`include \"defines.v\" module ppReg1 (clk, opcodeIn, fieldIn, opcodeOut, fieldOut); input clk; input [`instOpCodeLen-1:0] opcodeIn; input [`instFieldLen-1:0] fieldIn; output [`instOpCodeLen-1:0] opcodeOut; output [`instFieldLen-1:0] fieldOut; reg [`instOpCodeLen-1:0] opcodeOut; reg [`instFieldLen-1:0] fieldOut; always @ (posedge clk) begin opcodeOut = opcodeIn; fieldOut = fieldIn; end endmodule", "assertions_gpt_4o": "1. (opcodeIn == opcodeOut);\n2. (fieldIn == fieldOut);"}, {"file_name": "tcLoad.v", "verilog_design": "`include \"timescale.v\" `include \"defines.v\" module tcLoad (tcAddr, dnIn, ttIn, cuIn, cdIn, tcLoadOut); input [`tcAddrLen-1:0] tcAddr; input [`tcNumbers-1:0] dnIn, ttIn, cuIn, cdIn; output [7:0] tcLoadOut; wire dnSel, ttSel, cuSel, cdSel; assign dnSel = dnIn[tcAddr]; assign ttSel = ttIn[tcAddr]; assign cuSel = cuIn[tcAddr]; assign cdSel = cdIn[tcAddr]; assign tcLoadOut = {4'b0, cdSel, cuSel, ttSel, dnSel}; endmodule", "assertions_gpt_4o": "(dnIn[tcAddr] == 1) |-> (tcLoadOut[0] == 1);\n(dnIn[tcAddr] == 0) |-> (tcLoadOut[0] == 0);\n(ttIn[tcAddr] == 1) |-> (tcLoadOut[1] == 1);\n(ttIn[tcAddr] == 0) |-> (tcLoadOut[1] == 0);\n(cuIn[tcAddr] == 1) |-> (tcLoadOut[2] == 1);\n(cuIn[tcAddr] == 0) |-> (tcLoadOut[2] == 0);\n(cdIn[tcAddr] == 1) |-> (tcLoadOut[3] == 1);\n(cdIn[tcAddr] == 0) |-> (tcLoadOut[3] == 0);"}, {"file_name": "tcReset.v", "verilog_design": "`include \"timescale.v\" `include \"defines.v\" module tcReset (tcResetEn, resetIn, tcAddr, resetOut); input tcResetEn, resetIn; input [`tcAddrLen-1:0] tcAddr; output [`tcNumbers-1:0] resetOut; reg [`tcNumbers-1:0] resets; always @ (posedge tcResetEn) begin if (tcResetEn) begin resets[tcAddr] = resetIn; end end assign resetOut = resets; endmodule", "assertions_gpt_4o": "(tcResetEn == 1) |-> (resets[tcAddr] == resetIn);\n(tcResetEn == 0) |-> (resets[tcAddr] == resets[tcAddr]);\n(tcResetEn == 1) |-> (resetOut == resets);\n(tcResetEn == 0) |-> (resetOut == resets);"}, {"file_name": "uartRec.v", "verilog_design": "`include \"timescale.v\" `include \"defines.v\" module uartRec(clk, reset, sTick, rx, rxDoneTick, dOut); parameter dataBits = `dataBits; parameter sbTick = `sbTick; input clk, reset, sTick, rx; output rxDoneTick; output [dataBits-1:0] dOut; reg rxDoneTick; localparam idle = 2'b00, start = 2'b01, data = 2'b10, stop = 2'b11; reg [1:0] stateReg, stateNext; reg [3:0] sReg, sNext; reg [2:0] nReg, nNext; reg [7:0] bReg, bNext; always @ (posedge clk or posedge reset) begin if (reset) begin stateReg <= idle; sReg <= 1'b0; bReg <= 1'b0; nReg <= 1'b0; end else begin stateReg <= stateNext; sReg <= sNext; bReg <= bNext; nReg <= nNext; end end always @ * begin stateNext = stateReg; sNext = sReg; bNext = bReg; nNext = nReg; rxDoneTick = 1'b0; case (stateReg) idle : if (~rx) begin stateNext = start; sNext = 0; end start : if (sTick) if (sReg == 7) begin stateNext = data; sNext = 0; nNext = 0; end else sNext = sReg + 1; data : if (sTick) if (sReg == 15) begin sNext = 0; bNext = {rx, bReg[7:1]}; if (nReg == (dataBits-1)) stateNext = stop; else nNext = nReg + 1; end else sNext = sReg + 1; stop : if (sTick) if (sReg == (sbTick-1)) begin stateNext = idle; rxDoneTick = 1'b1; end else sNext = sReg + 1; endcase end assign dOut = bReg; endmodule", "assertions_gpt_4o": "(stateReg == idle && ~rx) |-> (stateNext == start);\n(stateReg == start && sTick && sReg == 7) |-> (stateNext == data && sNext == 0 && nNext == 0);\n(stateReg == start && sTick && sReg != 7) |-> (sNext == sReg + 1);\n(stateReg == data && sTick && sReg == 15 && nReg == (dataBits-1)) |-> (stateNext == stop && sNext == 0 && bNext == {rx, bReg[7:1]});\n(stateReg == data && sTick && sReg == 15 && nReg != (dataBits-1)) |-> (nNext == nReg + 1 && sNext == 0 && bNext == {rx, bReg[7:1]});\n(stateReg == data && sTick && sReg != 15) |-> (sNext == sReg + 1);\n(stateReg == stop && sTick && sReg == (sbTick-1)) |-> (stateNext == idle && rxDoneTick == 1'b1);\n(stateReg == stop && sTick && sReg != (sbTick-1)) |-> (sNext == sReg + 1);\n(reset) |-> (stateReg == idle && sReg == 1'b0 && bReg == 1'b0 && nReg == 1'b0);\n(rxDoneTick) |-> (stateReg == stop && sTick && sReg == (sbTick-1));"}, {"file_name": "uartTrans.v", "verilog_design": "`include \"timescale.v\" `include \"defines.v\" module uartTrans (clk, reset, sTick, txDoneTick, din, tx, txStart); parameter dataBits = `dataBits; parameter sbTick = `sbTick; input [dataBits-1 :0] din; input clk, reset, sTick, txStart; output tx, txDoneTick; reg txDoneTick; localparam [1:0] idle = 2'b00, start = 2'b01, data = 2'b10, stop = 2'b11; reg [1:0] stateReg, stateNext; reg [3:0] sReg, sNext; reg [2:0] nReg, nNext; reg [7:0] bReg, bNext; reg txReg, txNext; always @ (posedge clk or posedge reset) begin if (reset) begin stateReg <= idle; sReg <= 1'b0; bReg <= 1'b0; nReg <= 1'b0; txReg <= 1'b1; end else begin stateReg <= stateNext; sReg <= sNext; bReg <= bNext; nReg <= nNext; txReg <= txNext; end end always @ * begin stateNext = stateReg; sNext = sReg; bNext = bReg; nNext = nReg; txNext = txReg; txDoneTick = 1'b0; case (stateReg) idle : begin txNext = 1'b1; if (txStart) begin txDoneTick = 1'b1; stateNext = start; sNext = 0; end end start : begin txNext = 0; txDoneTick = 1'b0; bNext = din; if (sTick) if (sReg == 15) begin stateNext = data; sNext = 1'b0; nNext = 1'b0; end else sNext = sReg + 1; end data : begin txNext = bReg[0]; if (sTick) if (sReg == 15) begin sNext = 0; bNext = bReg >> 1; if (nReg == (dataBits-1)) stateNext = stop; else nNext = nReg +1; end else sNext = sReg + 1; end stop : begin txNext = 1'b1; if (sTick) if (sReg == sbTick-1) begin stateNext = idle; end else sNext = sReg + 1; end endcase end assign tx = txReg; endmodule", "assertions_gpt_4o": "(stateReg == idle & txStart) |-> (stateNext == start);\n(stateReg == idle & txStart) |-> (txNext == 1'b1);\n(stateReg == start & sTick & sReg == 15) |-> (stateNext == data);\n(stateReg == start & sTick & sReg == 15) |-> (sNext == 1'b0);\n(stateReg == start & sTick & sReg == 15) |-> (nNext == 1'b0);\n(stateReg == data & sTick & sReg == 15 & nReg == (dataBits-1)) |-> (stateNext == stop);\n(stateReg == data & sTick & sReg == 15 & nReg != (dataBits-1)) |-> (nNext == nReg + 1);\n(stateReg == stop & sTick & sReg == sbTick-1) |-> (stateNext == idle);\n(stateReg == idle) |-> (txNext == 1'b1);\n(stateReg == start) |-> (txNext == 1'b0);\n(stateReg == data) |-> (txNext == bReg[0]);\n(stateReg == stop) |-> (txNext == 1'b1);\n(txNext == 1'b1) |-> (tx == 1'b1);\n(txNext == 1'b0) |-> (tx == 1'b0);"}, {"file_name": "host_interface.v", "verilog_design": "module host_interface_aes ( output [3:0] key_en, output [1:0] col_addr, output [1:0] chmod, output [1:0] mode, output [1:0] data_type, output col_wr_en, output col_rd_en, output [1:0] key_sel, output [3:0] iv_en, output [3:0] iv_sel, output int_ccf, output int_err, output disable_core, output reg first_block, output dma_req_wr, output dma_req_rd, output reg start_core, output [31:0] PRDATA, input [3:0] PADDR, input [12:0] PWDATA, input PWRITE, input PENABLE, input PSEL, input PCLK, input PRESETn, input [31:0] key_bus, input [31:0] col_bus, input [31:0] iv_bus, input ccf_set ); localparam AES_CR = 4'd00; localparam AES_SR = 4'd01; localparam AES_DINR = 4'd02; localparam AES_DOUTR = 4'd03; localparam AES_KEYR0 = 4'd04; localparam AES_KEYR1 = 4'd05; localparam AES_KEYR2 = 4'd06; localparam AES_KEYR3 = 4'd07; localparam AES_IVR0 = 4'd08; localparam AES_IVR1 = 4'd09; localparam AES_IVR2 = 4'd10; localparam AES_IVR3 = 4'd11; localparam ENCRYPTION = 2'b00; localparam KEY_DERIVATION = 2'b01; localparam DECRYPTION = 2'b10; localparam DECRYP_W_DERIV = 2'b11; localparam ECB = 2'b00; localparam CBC = 2'b01; localparam CTR = 2'b10; localparam AES_CR_RESET = 13'd0; localparam AES_SR_RESET = 3'd0; localparam ENABLE = 1'b1; localparam DISABLE = 1'b0; localparam IDLE = 3'd0; localparam INPUT = 3'd1; localparam START = 3'd2; localparam WAIT = 3'd3; localparam OUTPUT = 3'd4; wire [31:0] bus_out; reg [31:0] bus_out_mux; reg cnt_en; reg enable_clear; reg access_permission; reg first_block_set; reg first_block_clear; wire [1:0] mode_in; wire [1:0] chmod_in; wire write_en; wire read_en; wire dma_out_en; wire dma_in_en; wire err_ie; wire ccf_ie; wire errc; wire ccfc; wire aes_cr_wr_en; wire wr_err_en; wire rd_err_en; wire write_completed; wire read_completed; wire key_deriv; reg [10:0] aes_cr; reg wr_err; reg rd_err; reg ccf; reg [2:0] state, next_state; reg [1:0] cnt; reg dma_req; wire enable; assign write_en = PSEL & PENABLE & PWRITE; assign read_en = (PSEL & ~PWRITE)?1'b1:1'b0; assign dma_out_en = aes_cr[10]; assign dma_in_en = aes_cr[9]; assign err_ie = aes_cr[8]; assign ccf_ie = aes_cr[7]; assign errc = PWDATA[8]; assign ccfc = PWDATA[7]; assign chmod = aes_cr[6:5]; assign mode = aes_cr[4:3]; assign data_type = aes_cr[2:1]; assign enable = aes_cr[0]; assign aes_cr_wr_en = (PADDR == AES_CR) & write_en; assign mode_in = PWDATA[4:3]; assign chmod_in = PWDATA[6:5]; always @(posedge PCLK or negedge PRESETn) begin if(!PRESETn) aes_cr <= AES_CR_RESET[10:0]; else begin if(enable_clear) aes_cr[0] <= 1'b0; else if(aes_cr_wr_en) aes_cr[0] <= PWDATA[0]; if(aes_cr_wr_en && access_permission) begin aes_cr[2:1] <= PWDATA[2:1]; if(mode_in == DECRYP_W_DERIV && chmod_in == CTR) aes_cr[4:3] <= DECRYPTION; else aes_cr[4:3] <= mode_in; aes_cr[ 6:5] <= PWDATA[6:5]; aes_cr[10:7] <= PWDATA[12:9]; end end end always @(posedge PCLK or negedge PRESETn) begin if(!PRESETn) begin {wr_err, rd_err, ccf} <= AES_SR_RESET; end else begin if(wr_err_en) wr_err <= 1'b1; else if(errc && aes_cr_wr_en && access_permission) wr_err <= 1'b0; if(rd_err_en) rd_err <= 1'b1; else if(errc && aes_cr_wr_en && access_permission) rd_err <= 1'b0; if(ccf_set) ccf <= 1'b1; else if(ccfc && aes_cr_wr_en ) ccf <= 1'b0; end end assign int_ccf = ccf_ie & ccf_set; assign int_err = (wr_err_en | rd_err_en) & err_ie; assign key_en = (4'b1000 >> PADDR[1:0]) & {4{(~PADDR[3] & PADDR[2] & access_permission & write_en)}}; assign key_sel = ~PADDR[1:0] & {2{(PADDR[2] & access_permission)}}; assign iv_sel = (4'b1000 >> PADDR[1:0]) & {4{(PADDR[3] & ~PADDR[2] & access_permission)}}; assign iv_en = iv_sel & {4{write_en}}; always @(posedge PCLK or negedge PRESETn) begin if(!PRESETn) state <= IDLE; else if(!enable) state <= IDLE; else state <= next_state; end assign write_completed = (cnt == 2'b11); assign read_completed = (cnt == 2'b11); assign key_deriv = (mode == KEY_DERIVATION); always @(*) begin next_state = state; case(state) IDLE : begin if(enable) next_state = (key_deriv) ? START : INPUT; end INPUT : next_state = (write_completed && cnt_en) ? START : INPUT; START : next_state = WAIT; WAIT : begin if(ccf_set) next_state = (key_deriv) ? IDLE : OUTPUT; end OUTPUT: next_state = (read_completed && cnt_en) ? INPUT : OUTPUT; endcase end assign disable_core = ~enable; always @(*) begin access_permission = DISABLE; start_core = DISABLE; cnt_en = DISABLE; enable_clear = DISABLE; first_block_set = DISABLE; first_block_clear = DISABLE; case(state) IDLE: begin access_permission = ENABLE; first_block_set = ENABLE; if(enable && !key_deriv) cnt_en = ENABLE; end INPUT: begin if(PADDR == AES_DINR && write_en) cnt_en = ENABLE; end START: begin start_core = ENABLE; end WAIT: begin if(ccf_set) cnt_en = ENABLE; if(ccf_set && key_deriv) enable_clear = ENABLE; end OUTPUT: begin first_block_clear = ENABLE; if(PADDR == AES_DOUTR && read_en && PENABLE ) cnt_en = ENABLE; end endcase end always @(posedge PCLK or negedge PRESETn) begin if(!PRESETn) first_block <= 1'b1; else if(first_block_set) first_block <= 1'b1; else if(first_block_clear) first_block <= 1'b0; end always @(posedge PCLK or negedge PRESETn) begin if(!PRESETn) cnt <= 2'b11; else begin if(!enable || state == START) cnt <= 2'b11; else if(cnt_en) cnt <= cnt + 1'b1; end end assign col_addr = cnt; assign col_wr_en = (PADDR == AES_DINR && write_en && state == INPUT); assign col_rd_en = (PADDR == AES_DOUTR && read_en && state == OUTPUT); assign wr_err_en = (PADDR == AES_DINR && write_en && (state != INPUT && state != IDLE)); assign rd_err_en = (PADDR == AES_DOUTR && read_en && (state != OUTPUT && state != IDLE)); always @(posedge PCLK or negedge PRESETn) begin if(!PRESETn) dma_req <= 1'b0; else dma_req <= cnt[0]; end assign dma_req_wr = (dma_req ^ cnt[0]) & dma_in_en & enable & (state == INPUT || state == IDLE); assign dma_req_rd = (dma_req ^ cnt[0]) & dma_out_en & enable & (state == OUTPUT); assign PRDATA = bus_out; always @(*) begin bus_out_mux = 32'd0; case(PADDR) AES_CR: bus_out_mux = {{19{1'b0}}, aes_cr[10:7], 2'b00, aes_cr[6:0]}; AES_SR: bus_out_mux = {{29{1'b0}}, wr_err, rd_err, (ccf_set && ~PENABLE)? 1'b1:(ccfc && aes_cr_wr_en)?1'b0:ccf}; AES_DINR, AES_DOUTR: begin if(~PWRITE && PADDR == AES_DOUTR && (ccf_set || ccf )) bus_out_mux = col_bus; end AES_KEYR0, AES_KEYR1, AES_KEYR2, AES_KEYR3: if(!enable) bus_out_mux = key_bus; AES_IVR0, AES_IVR1, AES_IVR2, AES_IVR3: if(!enable) bus_out_mux = iv_bus; endcase end assign bus_out =(read_en)? bus_out_mux:32'd0; endmodule", "assertions_gpt_4o": "(PRESETn == 0) |-> (aes_cr == AES_CR_RESET[10:0]);\n(PRESETn == 0) |-> ({wr_err, rd_err, ccf} == AES_SR_RESET);\n(aes_cr_wr_en && access_permission) |-> (aes_cr[2:1] == PWDATA[2:1]);\n(aes_cr_wr_en && access_permission && mode_in == DECRYP_W_DERIV && chmod_in == CTR) |-> (aes_cr[4:3] == DECRYPTION);\n(aes_cr_wr_en && access_permission && !(mode_in == DECRYP_W_DERIV && chmod_in == CTR)) |-> (aes_cr[4:3] == mode_in);\n(aes_cr_wr_en && access_permission) |-> (aes_cr[6:5] == PWDATA[6:5]);\n(aes_cr_wr_en && access_permission) |-> (aes_cr[10:7] == PWDATA[12:9]);\n(wr_err_en) |-> (wr_err == 1'b1);\n(errc && aes_cr_wr_en && access_permission) |-> (wr_err == 1'b0);\n(rd_err_en) |-> (rd_err == 1'b1);\n(errc && aes_cr_wr_en && access_permission) |-> (rd_err == 1'b0);\n(ccf_set) |-> (ccf == 1'b1);\n(ccfc && aes_cr_wr_en) |-> (ccf == 1'b0);\n(int_ccf) |-> (ccf_ie && ccf_set);\n(int_err) |-> ((wr_err_en || rd_err_en) && err_ie);\n(key_en) |-> ((4'b1000 >> PADDR[1:0]) & {4{(~PADDR[3] && PADDR[2] && access_permission && write_en)}});\n(key_sel) |-> (~PADDR[1:0] & {2{(PADDR[2] && access_permission)}});\n(iv_sel) |-> ((4'b1000 >> PADDR[1:0]) & {4{(PADDR[3] && ~PADDR[2] && access_permission)}});\n(iv_en) |-> (iv_sel & {4{write_en}});\n(state == IDLE && enable) |-> (next_state == (key_deriv ? START : INPUT));\n(state == INPUT && write_completed && cnt_en) |-> (next_state == START);\n(state == START) |-> (next_state == WAIT);\n(state == WAIT && ccf_set) |-> (next_state == (key_deriv ? IDLE : OUTPUT));\n(state == OUTPUT && read_completed && cnt_en) |-> (next_state == INPUT);\n(state == IDLE && enable && !key_deriv) |-> (cnt_en == ENABLE);\n(state == INPUT && PADDR == AES_DINR && write_en) |-> (cnt_en == ENABLE);\n(state == START) |-> (start_core == ENABLE);\n(state == WAIT && ccf_set) |-> (cnt_en == ENABLE);\n(state == WAIT && ccf_set && key_deriv) |-> (enable_clear == ENABLE);\n(state == OUTPUT && PADDR == AES_DOUTR && read_en && PENABLE) |-> (cnt_en == ENABLE);\n(PRESETn == 0) |-> (first_block == 1'b1);\n(first_block_set) |-> (first_block == 1'b1);\n(first_block_clear) |-> (first_block == 1'b0);\n(PRESETn == 0) |-> (cnt == 2'b11);\n(!enable || state == START) |-> (cnt == 2'b11);\n(cnt_en) |-> (cnt == cnt + 1'b1);\n(state == INPUT && PADDR == AES_DINR && write_en) |-> (col_wr_en == 1'b1);\n(state == OUTPUT && PADDR == AES_DOUTR && read_en) |-> (col_rd_en == 1'b1);\n(state != INPUT && state != IDLE && PADDR == AES_DINR && write_en) |-> (wr_err_en == 1'b1);\n(state != OUTPUT && state != IDLE && PADDR == AES_DOUTR && read_en) |-> (rd_err_en == 1'b1);\n(PRESETn == 0) |-> (dma_req == 1'b0);\n(cnt[0]) |-> (dma_req == cnt[0]);\n(dma_in_en && enable && (state == INPUT || state == IDLE)) |-> (dma_req_wr == (dma_req ^ cnt[0]));\n(dma_out_en && enable && (state == OUTPUT)) |-> (dma_req_rd == (dma_req ^ cnt[0]));\n(read_en) |-> (PRDATA == bus_out);\n(PADDR == AES_CR) |-> (bus_out_mux == {{19{1'b0"}, {"file_name": "key_expander.v", "verilog_design": "module key_expander ( output [127:0] key_out, output [ 31:0] g_in, input [ 31:0] g_out, input [127:0] key_in, input [ 3:0] round, input add_w_out, input enc_dec ); localparam integer KEY_WIDTH = 32; localparam integer KEY_NUM = 4; localparam integer WORD = 8; localparam integer ROUNDS = 10; wire [32 - 1 : 0] key [0 : 4 - 1]; wire [ 8 - 1 : 0] rot_in[0 : 4 - 1]; wire [32 - 1 : 0] g_func; reg [ 8 - 1 : 0] rc_dir, rc_inv; wire [ 8 - 1 : 0] rc; generate genvar i; for(i = 0; i < KEY_NUM; i = i + 1) begin:KG assign key[KEY_NUM - 1 - i] = key_in[KEY_WIDTH*(i + 1) - 1 : KEY_WIDTH*i]; end endgenerate generate genvar j; for(j = 0; j < KEY_NUM; j = j + 1) begin:KGO if(j == 0) assign key_out[KEY_WIDTH*(KEY_NUM - j) - 1 : KEY_WIDTH*(KEY_NUM - j - 1)] = key[j] ^ g_func; else if(j == 1) assign key_out[KEY_WIDTH*(KEY_NUM - j) - 1 : KEY_WIDTH*(KEY_NUM - j - 1)] = (add_w_out) ? key[j] ^ key[j - 1] ^ g_func : key[j] ^ key[j - 1]; else assign key_out[KEY_WIDTH*(KEY_NUM - j) - 1 : KEY_WIDTH*(KEY_NUM - j - 1)] = key[j] ^ key[j - 1]; end endgenerate generate genvar k; for(k = 0; k < KEY_NUM; k = k + 1) begin:GFIG assign rot_in[k] = (enc_dec) ? key[KEY_NUM - 1][WORD*(k + 1) - 1 : WORD*k] : key[KEY_NUM - 1][WORD*(k + 1) - 1 : WORD*k] ^ key[KEY_NUM - 2][WORD*(k + 1) - 1 : WORD*k]; end endgenerate generate genvar l; for(l = 0; l < KEY_NUM; l = l + 1) begin:GFIG1 assign g_in[WORD*(l + 1) - 1 : WORD*l] = rot_in[(KEY_NUM + l - 1)%KEY_NUM]; end endgenerate assign g_func = {g_out[KEY_WIDTH - 1 : KEY_WIDTH - WORD] ^ rc, g_out[KEY_WIDTH - WORD - 1 : 0]}; assign rc = (enc_dec) ? rc_dir : rc_inv; always @(*) begin: RC_DIR integer i; for(i = 0; i < ROUNDS; i = i + 1) if(round == 8) rc_dir = 8'h1b; else if(round == 9) rc_dir = 8'h36; else rc_dir = 8'h01 << round; end always @(*) begin: RC_INV integer i; for(i = 0; i < ROUNDS; i = i + 1) if(round == 1) rc_inv = 8'h1b; else if(round == 0) rc_inv = 8'h36; else rc_inv = 8'h80 >> (round - 2); end endmodule", "assertions_gpt_4o": "(g_out[31:24] ^ rc == g_func[31:24]);\n(g_out[23:0] == g_func[23:0]);\n(enc_dec == 1) |-> (rc == rc_dir);\n(enc_dec == 0) |-> (rc == rc_inv);\n(round == 8) |-> (rc_dir == 8'h1b);\n(round == 9) |-> (rc_dir == 8'h36);\n(round != 8 && round != 9) |-> (rc_dir == 8'h01 << round);\n(round == 1) |-> (rc_inv == 8'h1b);\n(round == 0) |-> (rc_inv == 8'h36);\n(round != 1 && round != 0) |-> (rc_inv == 8'h80 >> (round - 2));\n(add_w_out == 1 && j == 1) |-> (key_out[KEY_WIDTH*(KEY_NUM - j) - 1 : KEY_WIDTH*(KEY_NUM - j - 1)] == key[j] ^ key[j - 1] ^ g_func);\n(add_w_out == 0 && j == 1) |-> (key_out[KEY_WIDTH*(KEY_NUM - j) - 1 : KEY_WIDTH*(KEY_NUM - j - 1)] == key[j] ^ key[j - 1]);\n(j != 1) |-> (key_out[KEY_WIDTH*(KEY_NUM - j) - 1 : KEY_WIDTH*(KEY_NUM - j - 1)] == key[j] ^ key[j - 1]);\n(enc_dec == 1) |-> (rot_in[k] == key[KEY_NUM - 1][WORD*(k + 1) - 1 : WORD*k]);\n(enc_dec == 0) |-> (rot_in[k] == key[KEY_NUM - 1][WORD*(k + 1) - 1 : WORD*k] ^ key[KEY_NUM - 2][WORD*(k + 1) - 1 : WORD*k]);\n(g_in[WORD*(l + 1) - 1 : WORD*l] == rot_in[(KEY_NUM + l - 1) % KEY_NUM]);"}, {"file_name": "cavlc_fsm.v", "verilog_design": "`include \"defines.v\" module cavlc_fsm ( clk, rst_n, ena, start, max_coeff_num, TotalCoeff, TotalCoeff_comb, TrailingOnes, TrailingOnes_comb, ZeroLeft, state, i, idle, valid ); input clk; input rst_n; input ena; input start; input [4:0] max_coeff_num; input [4:0] TotalCoeff; input [4:0] TotalCoeff_comb; input [1:0] TrailingOnes; input [1:0] TrailingOnes_comb; input [3:0] ZeroLeft; output [7:0] state; output [3:0] i; output idle; output valid; reg [7:0] state; reg [3:0] i; reg valid; always @(posedge clk or negedge rst_n) if (!rst_n) begin state <= `cavlc_idle_s; i <= 0; valid <= 0; end else if (ena) case(state) `cavlc_idle_s : begin if (start) begin state <= `cavlc_read_total_coeffs_s; valid <= 0; end else begin state <= `cavlc_idle_s; end end `cavlc_read_total_coeffs_s : begin i <= TotalCoeff_comb -1; if (TrailingOnes_comb > 0 && TotalCoeff_comb > 0) state <= `cavlc_read_t1s_flags_s; else if (TotalCoeff_comb > 0) state <= `cavlc_read_level_prefix_s; else begin state <= `cavlc_idle_s; valid <= 1; end end `cavlc_read_t1s_flags_s : begin if (TrailingOnes == TotalCoeff) state <= `cavlc_read_total_zeros_s; else begin state <= `cavlc_read_level_prefix_s; i <= i - TrailingOnes; end end `cavlc_read_level_prefix_s : begin state <= `cavlc_read_level_suffix_s; end `cavlc_read_level_suffix_s : begin state <= `cavlc_calc_level_s; end `cavlc_calc_level_s : begin if ( i == 0 && TotalCoeff < max_coeff_num) state <= `cavlc_read_total_zeros_s; else if (i == 0) begin state <= `cavlc_read_run_befores_s; i <= TotalCoeff - 1; end else begin state <= `cavlc_read_level_prefix_s; i <= i - 1; end end `cavlc_read_total_zeros_s : begin state <= `cavlc_read_run_befores_s; i <= TotalCoeff - 1; end `cavlc_read_run_befores_s : begin if (i == 0 || ZeroLeft == 0) begin state <= `cavlc_idle_s; valid <= 1; end else begin state <= `cavlc_read_run_befores_s; i <= i - 1; end end endcase assign idle = state[`cavlc_idle_bit]; endmodule", "assertions_gpt_4o": "(state == `cavlc_idle_s && start) |-> (state == `cavlc_read_total_coeffs_s);\n(state == `cavlc_idle_s && !start) |-> (state == `cavlc_idle_s);\n(state == `cavlc_read_total_coeffs_s && TrailingOnes_comb > 0 && TotalCoeff_comb > 0) |-> (state == `cavlc_read_t1s_flags_s);\n(state == `cavlc_read_total_coeffs_s && TrailingOnes_comb == 0 && TotalCoeff_comb > 0) |-> (state == `cavlc_read_level_prefix_s);\n(state == `cavlc_read_total_coeffs_s && TotalCoeff_comb == 0) |-> (state == `cavlc_idle_s && valid == 1);\n(state == `cavlc_read_t1s_flags_s && TrailingOnes == TotalCoeff) |-> (state == `cavlc_read_total_zeros_s);\n(state == `cavlc_read_t1s_flags_s && TrailingOnes != TotalCoeff) |-> (state == `cavlc_read_level_prefix_s);\n(state == `cavlc_read_level_prefix_s) |-> (state == `cavlc_read_level_suffix_s);\n(state == `cavlc_read_level_suffix_s) |-> (state == `cavlc_calc_level_s);\n(state == `cavlc_calc_level_s && i == 0 && TotalCoeff < max_coeff_num) |-> (state == `cavlc_read_total_zeros_s);\n(state == `cavlc_calc_level_s && i == 0 && TotalCoeff >= max_coeff_num) |-> (state == `cavlc_read_run_befores_s);\n(state == `cavlc_calc_level_s && i != 0) |-> (state == `cavlc_read_level_prefix_s);\n(state == `cavlc_read_total_zeros_s) |-> (state == `cavlc_read_run_befores_s);\n(state == `cavlc_read_run_befores_s && (i == 0 || ZeroLeft == 0)) |-> (state == `cavlc_idle_s && valid == 1);\n(state == `cavlc_read_run_befores_s && i != 0 && ZeroLeft != 0) |-> (state == `cavlc_read_run_befores_s);"}, {"file_name": "cavlc_len_gen.v", "verilog_design": "`include \"defines.v\" module cavlc_len_gen ( cavlc_state, len_read_total_coeffs_comb, len_read_levels_comb, len_read_total_zeros_comb, len_read_run_befores_comb, len_comb ); input [7:0] cavlc_state; input [4:0] len_read_total_coeffs_comb; input [4:0] len_read_levels_comb; input [3:0] len_read_total_zeros_comb; input [3:0] len_read_run_befores_comb; output [4:0] len_comb; reg [4:0] len_comb; always @ (*) case (1'b1) cavlc_state[`cavlc_read_total_coeffs_bit] : len_comb <= len_read_total_coeffs_comb; cavlc_state[`cavlc_read_t1s_flags_bit], cavlc_state[`cavlc_read_level_prefix_bit], cavlc_state[`cavlc_read_level_suffix_bit] : len_comb <= len_read_levels_comb; cavlc_state[`cavlc_read_total_zeros_bit] : len_comb <= len_read_total_zeros_comb; cavlc_state[`cavlc_read_run_befores_bit] : len_comb <= len_read_run_befores_comb; cavlc_state[`cavlc_calc_level_bit], cavlc_state[`cavlc_idle_bit] : len_comb <= 0; default : len_comb <= 'bx; endcase endmodule", "assertions_gpt_4o": "(cavlc_state[`cavlc_read_total_coeffs_bit] == 1'b1) |-> (len_comb == len_read_total_coeffs_comb);\n(cavlc_state[`cavlc_read_t1s_flags_bit] == 1'b1 || cavlc_state[`cavlc_read_level_prefix_bit] == 1'b1 || cavlc_state[`cavlc_read_level_suffix_bit] == 1'b1) |-> (len_comb == len_read_levels_comb);\n(cavlc_state[`cavlc_read_total_zeros_bit] == 1'b1) |-> (len_comb == len_read_total_zeros_comb);\n(cavlc_state[`cavlc_read_run_befores_bit] == 1'b1) |-> (len_comb == len_read_run_befores_comb);\n(cavlc_state[`cavlc_calc_level_bit] == 1'b1 || cavlc_state[`cavlc_idle_bit] == 1'b1) |-> (len_comb == 0);\n(cavlc_state != `cavlc_read_total_coeffs_bit && cavlc_state != `cavlc_read_t1s_flags_bit && cavlc_state != `cavlc_read_level_prefix_bit && cavlc_state != `cavlc_read_level_suffix_bit && cavlc_state != `cavlc_read_total_zeros_bit && cavlc_state != `cavlc_read_run_befores_bit && cavlc_state != `cavlc_calc_level_bit && cavlc_state != `cavlc_idle_bit) |-> (len_comb === 'bx);"}, {"file_name": "cavlc_read_levels.v", "verilog_design": "`include \"defines.v\" module cavlc_read_levels ( clk, rst_n, ena, t1s_sel, prefix_sel, suffix_sel, calc_sel, TrailingOnes, TotalCoeff, rbsp, i, level_0, level_1, level_2, level_3, level_4, level_5, level_6, level_7, level_8, level_9, level_10, level_11, level_12, level_13, level_14, level_15, len_comb ); input clk; input rst_n; input ena; input t1s_sel; input prefix_sel; input suffix_sel; input calc_sel; input [1:0] TrailingOnes; input [4:0] TotalCoeff; input [0:15] rbsp; input [3:0] i; output [8:0] level_0; output [8:0] level_1; output [8:0] level_2; output [8:0] level_3; output [8:0] level_4; output [8:0] level_5; output [8:0] level_6; output [8:0] level_7; output [8:0] level_8; output [8:0] level_9; output [8:0] level_10; output [8:0] level_11; output [8:0] level_12; output [8:0] level_13; output [8:0] level_14; output [8:0] level_15; output [4:0] len_comb; reg [0:15] rbsp_internal; reg [3:0] level_prefix_comb; reg [8:0] level_suffix; reg [4:0] len_comb; reg [3:0] level_prefix; reg [2:0] suffixLength; reg [8:0] level; reg [8:0] level_abs; reg [8:0] level_code_tmp; reg [8:0] level_0, level_1, level_2, level_3, level_4, level_5, level_6, level_7; reg [8:0] level_8, level_9, level_10, level_11, level_12, level_13, level_14, level_15; always @(*) if ((t1s_sel || prefix_sel || suffix_sel)&& ena) rbsp_internal <= rbsp; else rbsp_internal <= 'hffff; always @(*) if (rbsp_internal[0]) level_prefix_comb <= 0; else if (rbsp_internal[1]) level_prefix_comb <= 1; else if (rbsp_internal[2]) level_prefix_comb <= 2; else if (rbsp_internal[3]) level_prefix_comb <= 3; else if (rbsp_internal[4]) level_prefix_comb <= 4; else if (rbsp_internal[5]) level_prefix_comb <= 5; else if (rbsp_internal[6]) level_prefix_comb <= 6; else if (rbsp_internal[7]) level_prefix_comb <= 7; else if (rbsp_internal[8]) level_prefix_comb <= 8; else if (rbsp_internal[9]) level_prefix_comb <= 9; else if (rbsp_internal[10]) level_prefix_comb <= 10; else if (rbsp_internal[11]) level_prefix_comb <= 11; else if (rbsp_internal[12]) level_prefix_comb <= 12; else if (rbsp_internal[13]) level_prefix_comb <= 13; else if (rbsp_internal[14]) level_prefix_comb <= 14; else if (rbsp_internal[15]) level_prefix_comb <= 15; else level_prefix_comb <= 'bx; always @(posedge clk or negedge rst_n) if (!rst_n) level_prefix <= 0; else if (prefix_sel && ena) level_prefix <= level_prefix_comb; wire first_level; assign first_level = (i == TotalCoeff - TrailingOnes - 1); always @(posedge clk or negedge rst_n) if (!rst_n) suffixLength <= 0; else if (prefix_sel && ena) begin if (TotalCoeff > 10 && TrailingOnes < 3 && first_level ) suffixLength <= 1; else if (first_level) suffixLength <= 0; else if (suffixLength == 0 && level_abs > 2'd3) suffixLength <= 2; else if (suffixLength == 0) suffixLength <= 1; else if ( level_abs > (2'd3 << (suffixLength - 1'b1) ) && suffixLength < 6) suffixLength <= suffixLength + 1'b1; end always @(*) if (suffixLength > 0 && level_prefix <= 14) level_suffix <= {3'b0, rbsp_internal[0:5] >> (3'd6 - suffixLength)}; else if (level_prefix == 14) level_suffix <= {3'b0, rbsp_internal[0:3] }; else if (level_prefix == 15) level_suffix <= rbsp_internal[3:11]; else level_suffix <= 0; always @(posedge clk or negedge rst_n) if (!rst_n) begin level_code_tmp <= 0; end else if (suffix_sel && ena) begin level_code_tmp <= (level_prefix << suffixLength) + level_suffix + ((suffixLength == 0 && level_prefix == 15) ? 4'd15 : 0); end wire [2:0] tmp1; assign tmp1 = (first_level && TrailingOnes < 3)? 2'd2 : 2'd0; always @(*) begin if (level_code_tmp % 2 == 0) begin level <= ( level_code_tmp + tmp1 + 2 ) >> 1; end else begin level <= (-level_code_tmp - tmp1 - 1 ) >> 1; end end wire level_abs_refresh; assign level_abs_refresh = calc_sel && ena; always @(posedge clk or negedge rst_n) if (!rst_n) begin level_abs <= 0; end else if (level_abs_refresh) begin level_abs <= level[8] ? -level : level; end always @ (posedge clk or negedge rst_n) if (!rst_n) begin level_0 <= 0; level_1 <= 0; level_2 <= 0; level_3 <= 0; level_4 <= 0; level_5 <= 0; level_6 <= 0; level_7 <= 0; level_8 <= 0; level_9 <= 0; level_10<= 0; level_11<= 0; level_12<= 0; level_13<= 0; level_14<= 0; level_15<= 0; end else if (t1s_sel && ena) case (i) 0 : level_0 <= rbsp_internal[0]? -1 : 1; 1 : begin level_1 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_0 <= rbsp_internal[1]? -1 : 1; end 2 : begin level_2 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_1 <= rbsp_internal[1]? -1 : 1; if (TrailingOnes == 3) level_0 <= rbsp_internal[2]? -1 : 1; end 3 : begin level_3 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_2 <= rbsp_internal[1]? -1 : 1; if (TrailingOnes == 3) level_1 <= rbsp_internal[2]? -1 : 1; end 4 : begin level_4 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_3 <= rbsp_internal[1]? -1 : 1; if (TrailingOnes == 3) level_2 <= rbsp_internal[2]? -1 : 1; end 5 : begin level_5 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_4 <= rbsp_internal[1]? -1 : 1; if (TrailingOnes == 3) level_3 <= rbsp_internal[2]? -1 : 1; end 6 : begin level_6 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_5 <= rbsp_internal[1]? -1 : 1; if (TrailingOnes == 3) level_4 <= rbsp_internal[2]? -1 : 1; end 7 : begin level_7 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_6 <= rbsp_internal[1]? -1 : 1; if (TrailingOnes == 3) level_5 <= rbsp_internal[2]? -1 : 1; end 8 : begin level_8 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_7 <= rbsp_internal[1]? -1 : 1; if (TrailingOnes == 3) level_6 <= rbsp_internal[2]? -1 : 1; end 9 : begin level_9 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_8 <= rbsp_internal[1]? -1 : 1; if (TrailingOnes == 3) level_7 <= rbsp_internal[2]? -1 : 1; end 10: begin level_10 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_9 <= rbsp_internal[1]? -1 : 1; if (TrailingOnes == 3) level_8 <= rbsp_internal[2]? -1 : 1; end 11: begin level_11 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_10 <= rbsp_internal[1]? -1 : 1; if (TrailingOnes == 3) level_9 <= rbsp_internal[2]? -1 : 1; end 12: begin level_12 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_11 <= rbsp_internal[1]? -1 : 1; if (TrailingOnes == 3) level_10 <= rbsp_internal[2]? -1 : 1; end 13: begin level_13 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_12 <= rbsp_internal[1]? -1 : 1; if (TrailingOnes == 3) level_11 <= rbsp_internal[2]? -1 : 1; end 14: begin level_14 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_13 <= rbsp_internal[1]? -1 : 1; if (TrailingOnes == 3) level_12 <= rbsp_internal[2]? -1 : 1; end 15: begin level_15 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_14 <= rbsp_internal[1]? -1 : 1; if (TrailingOnes == 3) level_13 <= rbsp_internal[2]? -1 : 1; end endcase else if (calc_sel && ena) case (i) 0 :level_0 <= level; 1 :level_1 <= level; 2 :level_2 <= level; 3 :level_3 <= level; 4 :level_4 <= level; 5 :level_5 <= level; 6 :level_6 <= level; 7 :level_7 <= level; 8 :level_8 <= level; 9 :level_9 <= level; 10:level_10<= level; 11:level_11<= level; 12:level_12<= level; 13:level_13<= level; 14:level_14<= level; 15:level_15<= level; endcase always @(*) if(t1s_sel) len_comb <= TrailingOnes; else if(prefix_sel) len_comb <= level_prefix_comb + 1; else if(suffix_sel && suffixLength > 0 && level_prefix <= 14) len_comb <= suffixLength; else if(suffix_sel && level_prefix == 14) len_comb <= 4; else if(suffix_sel && level_prefix == 15) len_comb <= 12; else len_comb <= 0; endmodule", "assertions_gpt_4o": "(req1 == 1 & state == 0) |-> (gnt1 == 1);\n(req1 == 0) |-> (gnt1 == 0);\n(req1 == 1 & req2 == 0) |-> (gnt1 == 1);\n(req1 == 1 & state == 0) |-> (gnt2 == 0);\n(req2 == 1 & state == 1) |-> (gnt2 == 1);\n(req2 == 0) |-> (gnt2 == 0);\n(req2 == 1 & req1 == 0) |-> (gnt2 == 1);\n(gnt2) |-> (req2);\n(gnt1) |-> (req1);\n(t1s_sel || prefix_sel || suffix_sel) && ena |-> (rbsp_internal == rbsp);\n!(t1s_sel || prefix_sel || suffix_sel) && ena |-> (rbsp_internal == 'hffff);\n(rbsp_internal[0]) |-> (level_prefix_comb == 0);\n(rbsp_internal[1]) |-> (level_prefix_comb == 1);\n(rbsp_internal[2]) |-> (level_prefix_comb == 2);\n(rbsp_internal[3]) |-> (level_prefix_comb == 3);\n(rbsp_internal[4]) |-> (level_prefix_comb == 4);\n(rbsp_internal[5]) |-> (level_prefix_comb == 5);\n(rbsp_internal[6]) |-> (level_prefix_comb == 6);\n(rbsp_internal[7]) |-> (level_prefix_comb == 7);\n(rbsp_internal[8]) |-> (level_prefix_comb == 8);\n(rbsp_internal[9]) |-> (level_prefix_comb == 9);\n(rbsp_internal[10]) |-> (level_prefix_comb == 10);\n(rbsp_internal[11]) |-> (level_prefix_comb == 11);\n(rbsp_internal[12]) |-> (level_prefix_comb == 12);\n(rbsp_internal[13]) |-> (level_prefix_comb == 13);\n(rbsp_internal[14]) |-> (level_prefix_comb == 14);\n(rbsp_internal[15]) |-> (level_prefix_comb == 15);\n(prefix_sel && ena) |-> (level_prefix == level_prefix_comb);\n(prefix_sel && ena && TotalCoeff > 10 && TrailingOnes < 3 && first_level) |-> (suffixLength == 1);\n(prefix_sel && ena && first_level) |-> (suffixLength == 0);\n(suffixLength == 0 && level_abs > 2'd3) |-> (suffixLength == 2);\n(suffixLength == 0) |-> (suffixLength == 1);\n(level_abs > (2'd3 << (suffixLength - 1'b1)) && suffixLength < 6) |-> (suffixLength == suffixLength + 1'b1);\n(suffixLength > 0 && level_prefix <= 14) |-> (level_suffix == {3'b0, rbsp_internal[0:5] >> (3'd6 - suffixLength)});\n(level_prefix == 14) |-> (level_suffix == {3'b0, rbsp_internal[0:3]});\n(level_prefix == 15) |-> (level_suffix == rbsp_internal[3:11]);\n(suffix_sel && ena) |-> (level_code_tmp == (level_prefix << suffixLength) + level_suffix + ((suffixLength == 0 && level_prefix == 15) ? 4'd15 : 0));\n(level_code_tmp % 2 == 0) |-> (level == (level_code_tmp + tmp1 + 2) >> 1);\n(level_code_tmp % 2 != 0) |-> (level == (-level_code_tmp - tmp1 - 1) >> 1);\n(calc_sel && ena) |-> (level_abs == (level[8] ? -level : level));\n(t1s_sel && ena && i == 0) |-> (level_0 == (rbsp_internal[0] ? -1 : 1));\n(t1s_sel && ena && i == 1) |-> (level_1 == (rbsp_internal[0] ? -1 : 1));\n(t1s_sel && ena && i == 1 && TrailingOnes[1]) |-> (level_0 == (rbsp_internal[1] ? -1 : 1));\n(t1s_sel && ena && i == 2) |-> (level_2 == (rbsp_internal[0] ? -1 : 1));\n(t1s_sel && ena && i == 2 && TrailingOnes[1]) |-> (level_1 == (rbsp_internal[1] ? -1 : 1));\n(t1s_sel && ena && i == 2 && TrailingOnes == 3) |-> (level_0"}, {"file_name": "cavlc_read_run_befores.v", "verilog_design": "`include \"defines.v\" module cavlc_read_run_befores ( clk, rst_n, ena, sel, clr, ZeroLeft_init, rbsp, i, TotalZeros_comb, level_0, level_1, level_2, level_3, level_4, level_5, level_6, level_7, level_8, level_9, level_10, level_11, level_12, level_13, level_14, level_15, coeff_0, coeff_1, coeff_2, coeff_3, coeff_4, coeff_5, coeff_6, coeff_7, coeff_8, coeff_9, coeff_10, coeff_11, coeff_12, coeff_13, coeff_14, coeff_15, ZeroLeft, len_comb ); input clk; input rst_n; input ena; input sel; input clr; input ZeroLeft_init; input [0:10] rbsp; input [3:0] i; input [3:0] TotalZeros_comb; input [8:0] level_0; input [8:0] level_1; input [8:0] level_2; input [8:0] level_3; input [8:0] level_4; input [8:0] level_5; input [8:0] level_6; input [8:0] level_7; input [8:0] level_8; input [8:0] level_9; input [8:0] level_10; input [8:0] level_11; input [8:0] level_12; input [8:0] level_13; input [8:0] level_14; input [8:0] level_15; output [8:0] coeff_0; output [8:0] coeff_1; output [8:0] coeff_2; output [8:0] coeff_3; output [8:0] coeff_4; output [8:0] coeff_5; output [8:0] coeff_6; output [8:0] coeff_7; output [8:0] coeff_8; output [8:0] coeff_9; output [8:0] coeff_10; output [8:0] coeff_11; output [8:0] coeff_12; output [8:0] coeff_13; output [8:0] coeff_14; output [8:0] coeff_15; output [3:0] ZeroLeft; output [3:0] len_comb; reg [3:0] run; reg [3:0] len; reg [8:0] coeff; reg [3:0] len_comb; reg [3:0] ZeroLeft; reg [8:0] coeff_0; reg [8:0] coeff_1; reg [8:0] coeff_2; reg [8:0] coeff_3; reg [8:0] coeff_4; reg [8:0] coeff_5; reg [8:0] coeff_6; reg [8:0] coeff_7; reg [8:0] coeff_8; reg [8:0] coeff_9; reg [8:0] coeff_10; reg [8:0] coeff_11; reg [8:0] coeff_12; reg [8:0] coeff_13; reg [8:0] coeff_14; reg [8:0] coeff_15; always @(rbsp or ZeroLeft or ena or sel) if (ena && sel) case(ZeroLeft) 0 : begin len <= 0; run <= 0; end 1 : begin len <= 1; run <= rbsp[0]? 0:1; end 2 : begin if (rbsp[0]) begin run <= 0; len <= 1; end else if (rbsp[1]) begin run <= 1; len <= 2; end else begin run <= 2; len <= 2; end end 3 : begin run <= 3 - rbsp[0:1]; len <= 2; end 4 : begin if (rbsp[0:1] != 0) begin run <= 3 - rbsp[0:1]; len <= 2; end else begin run <= rbsp[2]? 3:4; len <= 3; end end 5 : begin if (rbsp[0]) begin run <= rbsp[1]? 0:1; len <= 2; end else if (rbsp[1]) begin run <= rbsp[2]? 2:3; len <= 3; end else begin run <= rbsp[2]? 4:5; len <= 3; end end 6 : begin if (rbsp[0:1] == 2'b11) begin run <= 0; len <= 2; end else begin len <= 3; case(rbsp[0:2]) 3'b000 : run <= 1; 3'b001 : run <= 2; 3'b011 : run <= 3; 3'b010 : run <= 4; 3'b101 : run <= 5; default: run <= 6; endcase end end default : begin if (rbsp[0:2] != 0) begin run <= 7 - rbsp[0:2]; len <= 3; end else begin case (1'b1) rbsp[3] : begin run <= 7; len <= 4; end rbsp[4] : begin run <= 8; len <= 5; end rbsp[5] : begin run <= 9; len <= 6; end rbsp[6] : begin run <= 10; len <= 7; end rbsp[7] : begin run <= 11; len <= 8; end rbsp[8] : begin run <= 12; len <= 9; end rbsp[9] : begin run <= 13; len <= 10;end rbsp[10]: begin run <= 14; len <= 11;end default : begin run <= 'bx; len <='bx;end endcase end end endcase else begin len <= 0; run <= 0; end always @(*) if (i > 0) len_comb <= len; else len_comb <= 0; always @(posedge clk or negedge rst_n) if (!rst_n) ZeroLeft <= 0; else if (ena && clr) ZeroLeft <= 0; else if (ena && ZeroLeft_init) ZeroLeft <= TotalZeros_comb; else if (ena && sel ) ZeroLeft <= ZeroLeft - run; always @(*) if (ena && sel) case (i) 0 :coeff <= level_0; 1 :coeff <= level_1; 2 :coeff <= level_2; 3 :coeff <= level_3; 4 :coeff <= level_4; 5 :coeff <= level_5; 6 :coeff <= level_6; 7 :coeff <= level_7; 8 :coeff <= level_8; 9 :coeff <= level_9; 10:coeff <= level_10; 11:coeff <= level_11; 12:coeff <= level_12; 13:coeff <= level_13; 14:coeff <= level_14; 15:coeff <= level_15; endcase else coeff <= 0; always @(posedge clk or negedge rst_n) if (!rst_n) begin coeff_0 <= 0; coeff_1 <= 0; coeff_2 <= 0; coeff_3 <= 0; coeff_4 <= 0; coeff_5 <= 0; coeff_6 <= 0; coeff_7 <= 0; coeff_8 <= 0; coeff_9 <= 0; coeff_10<= 0; coeff_11<= 0; coeff_12<= 0; coeff_13<= 0; coeff_14<= 0; coeff_15<= 0; end else if (ena && clr) begin coeff_0 <= 0; coeff_1 <= 0; coeff_2 <= 0; coeff_3 <= 0; coeff_4 <= 0; coeff_5 <= 0; coeff_6 <= 0; coeff_7 <= 0; coeff_8 <= 0; coeff_9 <= 0; coeff_10<= 0; coeff_11<= 0; coeff_12<= 0; coeff_13<= 0; coeff_14<= 0; coeff_15<= 0; end else if (ena && sel && ZeroLeft > 0) case (ZeroLeft+i) 1 :coeff_1 <= coeff; 2 :coeff_2 <= coeff; 3 :coeff_3 <= coeff; 4 :coeff_4 <= coeff; 5 :coeff_5 <= coeff; 6 :coeff_6 <= coeff; 7 :coeff_7 <= coeff; 8 :coeff_8 <= coeff; 9 :coeff_9 <= coeff; 10:coeff_10 <= coeff; 11:coeff_11 <= coeff; 12:coeff_12 <= coeff; 13:coeff_13 <= coeff; 14:coeff_14 <= coeff; default: coeff_15 <= coeff; endcase else if (ena && sel) begin if (i >= 0) coeff_0 <= level_0; if (i >= 1) coeff_1 <= level_1; if (i >= 2) coeff_2 <= level_2; if (i >= 3) coeff_3 <= level_3; if (i >= 4) coeff_4 <= level_4; if (i >= 5) coeff_5 <= level_5; if (i >= 6) coeff_6 <= level_6; if (i >= 7) coeff_7 <= level_7; if (i >= 8) coeff_8 <= level_8; if (i >= 9) coeff_9 <= level_9; if (i >= 10)coeff_10 <= level_10; if (i >= 11)coeff_11 <= level_11; if (i >= 12)coeff_12 <= level_12; if (i >= 13)coeff_13 <= level_13; if (i >= 14)coeff_14 <= level_14; if (i == 15)coeff_15 <= level_15; end endmodule", "assertions_gpt_4o": "1. (ena && sel && ZeroLeft == 0) |-> (len == 0 && run == 0);\n2. (ena && sel && ZeroLeft == 1 && rbsp[0] == 1) |-> (len == 1 && run == 0);\n3. (ena && sel && ZeroLeft == 1 && rbsp[0] == 0) |-> (len == 1 && run == 1);\n4. (ena && sel && ZeroLeft == 2 && rbsp[0] == 1) |-> (len == 1 && run == 0);\n5. (ena && sel && ZeroLeft == 2 && rbsp[0] == 0 && rbsp[1] == 1) |-> (len == 2 && run == 1);\n6. (ena && sel && ZeroLeft == 2 && rbsp[0] == 0 && rbsp[1] == 0) |-> (len == 2 && run == 2);\n7. (ena && sel && ZeroLeft == 3) |-> (len == 2 && run == 3 - rbsp[0:1]);\n8. (ena && sel && ZeroLeft == 4 && rbsp[0:1] != 0) |-> (len == 2 && run == 3 - rbsp[0:1]);\n9. (ena && sel && ZeroLeft == 4 && rbsp[0:1] == 0 && rbsp[2] == 1) |-> (len == 3 && run == 3);\n10. (ena && sel && ZeroLeft == 4 && rbsp[0:1] == 0 && rbsp[2] == 0) |-> (len == 3 && run == 4);\n11. (ena && sel && ZeroLeft == 5 && rbsp[0] == 1 && rbsp[1] == 1) |-> (len == 2 && run == 0);\n12. (ena && sel && ZeroLeft == 5 && rbsp[0] == 1 && rbsp[1] == 0) |-> (len == 2 && run == 1);\n13. (ena && sel && ZeroLeft == 5 && rbsp[0] == 0 && rbsp[1] == 1 && rbsp[2] == 1) |-> (len == 3 && run == 2);\n14. (ena && sel && ZeroLeft == 5 && rbsp[0] == 0 && rbsp[1] == 1 && rbsp[2] == 0) |-> (len == 3 && run == 3);\n15. (ena && sel && ZeroLeft == 5 && rbsp[0] == 0 && rbsp[1] == 0 && rbsp[2] == 1) |-> (len == 3 && run == 4);\n16. (ena && sel && ZeroLeft == 5 && rbsp[0] == 0 && rbsp[1] == 0 && rbsp[2] == 0) |-> (len == 3 && run == 5);\n17. (ena && sel && ZeroLeft == 6 && rbsp[0:1] == 2'b11) |-> (len == 2 && run == 0);\n18. (ena && sel && ZeroLeft == 6 && rbsp[0:1] != 2'b11) |-> (len == 3);\n19. (ena && sel && ZeroLeft == 6 && rbsp[0:2] == 3'b000) |-> (run == 1);\n20. (ena && sel && ZeroLeft == 6 && rbsp[0:2] == 3'b001) |-> (run == 2);\n21. (ena && sel && ZeroLeft == 6 && rbsp[0:2] == 3'b011) |-> (run == 3);\n22. (ena && sel && ZeroLeft == 6 && rbsp[0:2] == 3'b010) |-> (run == 4);\n23. (ena && sel && ZeroLeft == 6 && rbsp[0:2] == 3'b101) |-> (run == 5);\n24. (ena && sel && ZeroLeft == 6 && rbsp[0:2] == 3'b100) |-> (run == 6);\n25. (ena && sel && ZeroLeft > 6 && rbsp[0:2] != 0) |-> (len == 3 && run == 7 - rbsp[0:2]);\n26. (ena && sel && ZeroLeft > 6 && rbsp"}, {"file_name": "cavlc_read_total_coeffs.v", "verilog_design": "`include \"defines.v\" module cavlc_read_total_coeffs ( clk, rst_n, ena, start, sel, rbsp, nC, TrailingOnes, TotalCoeff, TrailingOnes_comb, TotalCoeff_comb, len_comb ); input clk; input rst_n; input ena; input start; input sel; input [0:15] rbsp; input signed [5:0] nC; output [4:0] TotalCoeff; output [1:0] TrailingOnes; output [4:0] TotalCoeff_comb; output [1:0] TrailingOnes_comb; output [4:0] len_comb; reg [4:0] TotalCoeff_comb; reg [1:0] TrailingOnes_comb; reg [4:0] len_comb; reg [4:0] TotalCoeff_1; reg [1:0] TrailingOnes_1; reg [4:0] len_1; reg [4:0] TotalCoeff_2; reg [1:0] TrailingOnes_2; reg [4:0] len_2; reg [4:0] TotalCoeff_3; reg [1:0] TrailingOnes_3; reg [4:0] len_3; reg [4:0] TotalCoeff_4; reg [1:0] TrailingOnes_4; reg [4:0] len_4; reg [4:0] TotalCoeff_5; reg [1:0] TrailingOnes_5; reg [4:0] len_5; reg [0:15] rbsp_1; reg [0:13] rbsp_2; reg [0:9] rbsp_3; reg [0:5] rbsp_4; reg [0:7] rbsp_5; reg [4:0] TotalCoeff; reg [1:0] TrailingOnes; always @(posedge clk or negedge rst_n) if (!rst_n) begin rbsp_1 <= 0; rbsp_2 <= 0; rbsp_3 <= 0; rbsp_4 <= 0; rbsp_5 <= 0; end else if (ena && start) begin if (nC[5]) rbsp_5 <= rbsp[0:7]; else if ( nC[4] || nC[3]) rbsp_4 <= rbsp[0:5]; else if (nC[2]) rbsp_3 <= rbsp[0:9]; else if (nC[1]) rbsp_2 <= rbsp[0:13]; else rbsp_1 <= rbsp; end always @(rbsp_1) case (1'b1) rbsp_1[0] : begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 0; len_1 <= 1; end rbsp_1[1] : begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 1; len_1 <= 2; end rbsp_1[2] : begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 2; len_1 <= 3; end rbsp_1[3] : begin if (rbsp_1[4] == 'b1) begin TrailingOnes_1 <= 3; TotalCoeff_1 <= 3; len_1 <= 5; end else if (rbsp_1[5] == 'b1) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 1; len_1 <= 6; end else begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 2; len_1 <= 6; end end rbsp_1[4] : begin if (rbsp_1[5] == 'b1) begin TrailingOnes_1 <= 3; TotalCoeff_1 <= 4; len_1 <= 6; end else if (rbsp_1[6] == 'b1) begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 3; len_1 <= 7; end else begin TrailingOnes_1 <= 3; TotalCoeff_1 <= 5; len_1 <= 7; end end rbsp_1[5] : begin len_1 <= 8; if (rbsp_1[6:7] == 'b11) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 2; end else if (rbsp_1[6:7] == 'b10) begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 3; end else if (rbsp_1[6:7] == 'b01) begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 4; end else begin TrailingOnes_1 <= 3; TotalCoeff_1 <= 6; end end rbsp_1[6] : begin len_1 <= 9; if (rbsp_1[7:8] == 2'b11) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 3; end else if (rbsp_1[7:8] == 2'b10) begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 4; end else if (rbsp_1[7:8] == 2'b01) begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 5; end else begin TrailingOnes_1 <= 3; TotalCoeff_1 <= 7; end end rbsp_1[7] : begin len_1 <= 10; if (rbsp_1[8:9] == 2'b11) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 4; end else if (rbsp_1[8:9] == 2'b10) begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 5; end else if (rbsp_1[8:9] == 2'b01) begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 6; end else begin TrailingOnes_1 <= 3; TotalCoeff_1 <= 8; end end rbsp_1[8] : begin len_1 <= 11; if (rbsp_1[9:10] == 2'b11) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 5; end else if (rbsp_1[9:10] == 2'b10) begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 6; end else if (rbsp_1[9:10] == 2'b01) begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 7; end else begin TrailingOnes_1 <= 3; TotalCoeff_1 <= 9; end end rbsp_1[9] : begin len_1 <= 13; if (rbsp_1[10:12] == 3'b111) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 6; end else if (rbsp_1[10:12] == 3'b011) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 7; end else if (rbsp_1[10:12] == 3'b110) begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 7; end else if (rbsp_1[10:12] == 3'b000) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 8; end else if (rbsp_1[10:12] == 3'b010) begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 8; end else if (rbsp_1[10:12] == 3'b101) begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 8; end else if (rbsp_1[10:12] == 3'b001) begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 9; end else begin TrailingOnes_1 <= 3; TotalCoeff_1 <= 10; end end rbsp_1[10] : begin len_1 <= 14; if (rbsp_1[11:13] == 3'b111) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 9; end else if (rbsp_1[11:13] == 3'b110) begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 9; end else if (rbsp_1[11:13] == 3'b011) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 10; end else if (rbsp_1[11:13] == 3'b010) begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 10; end else if (rbsp_1[11:13] == 3'b101) begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 10; end else if (rbsp_1[11:13] == 3'b001) begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 11; end else if (rbsp_1[11:13] == 3'b100) begin TrailingOnes_1 <= 3; TotalCoeff_1 <= 11; end else begin TrailingOnes_1 <= 3; TotalCoeff_1 <= 12; end end rbsp_1[11] : begin len_1 <= 15; if (rbsp_1[12:14] == 3'b111) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 11; end else if (rbsp_1[12:14] == 3'b110) begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 11; end else if (rbsp_1[12:14] == 3'b011) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 12; end else if (rbsp_1[12:14] == 3'b010) begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 12; end else if (rbsp_1[12:14] == 3'b101) begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 12; end else if (rbsp_1[12:14] == 3'b001) begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 13; end else if (rbsp_1[12:14] == 3'b100) begin TrailingOnes_1 <= 3; TotalCoeff_1 <= 13; end else begin TrailingOnes_1 <= 3; TotalCoeff_1 <= 14; end end rbsp_1[12] : begin len_1 <= 16; if (rbsp_1[13:15] == 3'b111) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 13; end else if (rbsp_1[13:15] == 3'b011) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 14; end else if (rbsp_1[13:15] == 3'b110) begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 14; end else if (rbsp_1[13:15] == 3'b101) begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 14; end else if (rbsp_1[13:15] == 3'b010) begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 15; end else if (rbsp_1[13:15] == 3'b001) begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 15; end else if (rbsp_1[13:15] == 3'b100) begin TrailingOnes_1 <= 3; TotalCoeff_1 <= 15; end else begin TrailingOnes_1 <= 3; TotalCoeff_1 <= 16; end end rbsp_1[13] : begin len_1 <= 16; if (rbsp_1[14:15] == 2'b11) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 15; end else if (rbsp_1[14:15] == 2'b00) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 16; end else if (rbsp_1[14:15] == 2'b10) begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 16; end else begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 16; end end default : begin len_1 <= 15; TrailingOnes_1 <= 1; TotalCoeff_1 <= 13; end endcase always @(rbsp_2) case (1'b1) rbsp_2[0] : begin len_2 <= 2; if (rbsp_2[1] == 'b1) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 0; end else begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 1; end end rbsp_2[1] : begin if (rbsp_2[2] == 'b1) begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 2; len_2 <= 3; end else if (rbsp_2[3] == 'b1) begin TrailingOnes_2 <= 3; TotalCoeff_2 <= 3; len_2 <= 4; end else begin TrailingOnes_2 <= 3; TotalCoeff_2 <= 4; len_2 <= 4; end end rbsp_2[2] : begin if (rbsp_2[3:4] == 'b11) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 2; len_2 <= 5; end else if (rbsp_2[3:4] == 'b10) begin TrailingOnes_2 <= 3; TotalCoeff_2 <= 5; len_2 <= 5; end else if (rbsp_2[4:5] == 'b11) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 1; len_2 <= 6; end else if (rbsp_2[4:5] == 'b10) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 3; len_2 <= 6; end else if (rbsp_2[4:5] == 'b01) begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 3; len_2 <= 6; end else begin TrailingOnes_2 <= 3; TotalCoeff_2 <= 6; len_2 <= 6; end end rbsp_2[3] : begin len_2 <= 6; if (rbsp_2[4:5] == 'b11) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 2; end else if (rbsp_2[4:5] == 'b10) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 4; end else if (rbsp_2[4:5] == 'b01) begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 4; end else begin TrailingOnes_2 <= 3; TotalCoeff_2 <= 7; end end rbsp_2[4] : begin len_2 <= 7; if (rbsp_2[5:6] == 'b11) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 3; end else if (rbsp_2[5:6] == 'b10) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 5; end else if (rbsp_2[5:6] == 'b01) begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 5; end else begin TrailingOnes_2 <= 3; TotalCoeff_2 <= 8; end end rbsp_2[5] : begin len_2 <= 8; if (rbsp_2[6:7] == 'b11) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 4; end else if (rbsp_2[6:7] == 'b00) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 5; end else if (rbsp_2[6:7] == 'b10) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 6; end else begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 6; end end rbsp_2[6] : begin len_2 <= 9; if (rbsp_2[7:8] == 'b11) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 6; end else if (rbsp_2[7:8] == 'b10) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 7; end else if (rbsp_2[7:8] == 'b01) begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 7; end else begin TrailingOnes_2 <= 3; TotalCoeff_2 <= 9; end end rbsp_2[7] : begin len_2 <= 11; if (rbsp_2[8:10] == 'b111) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 7; end else if (rbsp_2[8:10] == 'b011) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 8; end else if (rbsp_2[8:10] == 'b110) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 8; end else if (rbsp_2[8:10] == 'b101) begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 8; end else if (rbsp_2[8:10] == 'b010) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 9; end else if (rbsp_2[8:10] == 'b001) begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 9; end else if (rbsp_2[8:10] == 'b100) begin TrailingOnes_2 <= 3; TotalCoeff_2 <= 10; end else begin TrailingOnes_2 <= 3; TotalCoeff_2 <= 11; end end rbsp_2[8] : begin len_2 <= 12; if (rbsp_2[9:11] == 'b111) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 9; end else if (rbsp_2[9:11] == 'b011) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 10; end else if (rbsp_2[9:11] == 'b110) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 10; end else if (rbsp_2[9:11] == 'b101) begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 10; end else if (rbsp_2[9:11] == 'b000) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 11; end else if (rbsp_2[9:11] == 'b010) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 11; end else if (rbsp_2[9:11] == 'b001) begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 11; end else begin TrailingOnes_2 <= 3; TotalCoeff_2 <= 12; end end rbsp_2[9] : begin len_2 <= 13; if (rbsp_2[10:12] == 'b111) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 12; end else if (rbsp_2[10:12] == 'b110) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 12; end else if (rbsp_2[10:12] == 'b101) begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 12; end else if (rbsp_2[10:12] == 'b011) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 13; end else if (rbsp_2[10:12] == 'b010) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 13; end else if (rbsp_2[10:12] == 'b001) begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 13; end else if (rbsp_2[10:12] == 'b100) begin TrailingOnes_2 <= 3; TotalCoeff_2 <= 13; end else begin TrailingOnes_2 <= 3; TotalCoeff_2 <= 14; end end rbsp_2[10] : begin if (rbsp_2[11:12] == 'b11) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 14; len_2 <= 13; end else if (rbsp_2[11:12] == 'b10) begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 14; len_2 <= 13; end else if (rbsp_2[12:13] == 'b11) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 14; len_2 <= 14; end else if (rbsp_2[12:13] == 'b01) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 15; len_2 <= 14; end else if (rbsp_2[12:13] == 'b00) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 15; len_2 <= 14; end else begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 15; len_2 <= 14; end end rbsp_2[11] : begin len_2 <= 14; if (rbsp_2[12:13] == 'b11) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 16; end else if (rbsp_2[12:13] == 'b10) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 16; end else if (rbsp_2[12:13] == 'b01) begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 16; end else begin TrailingOnes_2 <= 3; TotalCoeff_2 <= 16; end end default : begin TrailingOnes_2 <= 3; TotalCoeff_2 <= 15; len_2 <= 13; end endcase always @(rbsp_3) case (1'b1) rbsp_3[0] : begin len_3 <= 4; case (rbsp_3[1:3]) 'b111 : begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 0; end 'b110 : begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 1; end 'b101 : begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 2; end 'b100 : begin TrailingOnes_3 <= 3; TotalCoeff_3 <= 3; end 'b011 : begin TrailingOnes_3 <= 3; TotalCoeff_3 <= 4; end 'b010 : begin TrailingOnes_3 <= 3; TotalCoeff_3 <= 5; end 'b001 : begin TrailingOnes_3 <= 3; TotalCoeff_3 <= 6; end 'b000 : begin TrailingOnes_3 <= 3; TotalCoeff_3 <= 7; end endcase end rbsp_3[1] : begin len_3 <= 5; case (rbsp_3[2:4]) 'b111 : begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 2; end 'b100 : begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 3; end 'b110 : begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 3; end 'b010 : begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 4; end 'b011 : begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 4; end 'b000 : begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 5; end 'b001 : begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 5; end 'b101 : begin TrailingOnes_3 <= 3; TotalCoeff_3 <= 8; end endcase end rbsp_3[2] : begin len_3 <= 6; case (rbsp_3[3:5]) 3'b111 : begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 1; end 3'b011 : begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 2; end 3'b000 : begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 3; end 3'b110 : begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 6; end 3'b101 : begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 6; end 3'b010 : begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 7; end 3'b001 : begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 7; end 3'b100 : begin TrailingOnes_3 <= 3; TotalCoeff_3 <= 9; end endcase end rbsp_3[3] : begin len_3 <= 7; case (rbsp_3[4:6]) 'b111 : begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 4; end 'b011 : begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 5; end 'b001 : begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 6; end 'b000 : begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 7; end 'b110 : begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 8; end 'b101 : begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 8; end 'b010 : begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 9; end 'b100 : begin TrailingOnes_3 <= 3; TotalCoeff_3 <= 10; end endcase end rbsp_3[4] : begin len_3 <= 8; case (rbsp_3[5:7]) 'b111 : begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 8; end 'b011 : begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 9; end 'b110 : begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 9; end 'b010 : begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 10; end 'b101 : begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 10; end 'b001 : begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 11; end 'b100 : begin TrailingOnes_3 <= 3; TotalCoeff_3 <= 11; end 'b000 : begin TrailingOnes_3 <= 3; TotalCoeff_3 <= 12; end endcase end rbsp_3[5] : begin len_3 <= 9; case (rbsp_3[6:8]) 'b111 : begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 10; end 'b011 : begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 11; end 'b110 : begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 11; end 'b000 : begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 12; end 'b010 : begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 12; end 'b101 : begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 12; end 'b001 : begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 13; end 'b100 : begin TrailingOnes_3 <= 3; TotalCoeff_3 <= 13; end endcase end rbsp_3[6] : begin if (rbsp_3[7:8] == 'b11)begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 13; len_3 <= 9; end else if (rbsp_3[7:9] == 'b101)begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 13; len_3 <= 10; end else if (rbsp_3[7:9] == 'b001)begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 14; len_3 <= 10; end else if (rbsp_3[7:9] == 'b100)begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 14; len_3 <= 10; end else if (rbsp_3[7:9] == 'b011)begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 14; len_3 <= 10; end else if (rbsp_3[7:9] == 'b010)begin TrailingOnes_3 <= 3; TotalCoeff_3 <= 14; len_3 <= 10; end else begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 15; len_3 <= 10; end end rbsp_3[7] : begin len_3 <= 10; case (rbsp_3[8:9]) 'b01 : begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 15; end 'b11 : begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 15; end 'b10 : begin TrailingOnes_3 <= 3; TotalCoeff_3 <= 15; end 'b00 : begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 16; end endcase end rbsp_3[8] : begin len_3 <= 10; if (rbsp_3[9] == 'b1)begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 16; end else begin TrailingOnes_3 <= 3; TotalCoeff_3 <= 16; end end default : begin len_3 <= 10; TrailingOnes_3 <= 0; TotalCoeff_3 <= 16; end endcase always @(rbsp_4) begin len_4 <= 6; if (rbsp_4[0:4] == 5'b00001) begin TrailingOnes_4 <= 0; TotalCoeff_4 <= 0; end else begin TrailingOnes_4 <= rbsp_4[4:5]; TotalCoeff_4 <= rbsp_4[0:3] + 1'b1; end end always @(rbsp_5) case (1'b1) rbsp_5[0] : begin TrailingOnes_5 <= 1; TotalCoeff_5 <= 1; len_5 <= 1; end rbsp_5[1] : begin TrailingOnes_5 <= 0; TotalCoeff_5 <= 0; len_5 <= 2; end rbsp_5[2] : begin TrailingOnes_5 <= 2; TotalCoeff_5 <= 2; len_5 <= 3; end rbsp_5[3] : begin len_5 <= 6; if (rbsp_5[4:5] == 'b11) begin TrailingOnes_5 <= 0; TotalCoeff_5 <= 1; end else if (rbsp_5[4:5] == 'b00) begin TrailingOnes_5 <= 0; TotalCoeff_5 <= 2; end else if (rbsp_5[4:5] == 'b10) begin TrailingOnes_5 <= 1; TotalCoeff_5 <= 2; end else begin TrailingOnes_5 <= 3; TotalCoeff_5 <= 3; end end rbsp_5[4] : begin len_5 <= 6; if (rbsp_5[5] == 'b1) begin TrailingOnes_5 <= 0; TotalCoeff_5 <= 3; end else begin TrailingOnes_5 <= 0; TotalCoeff_5 <= 4; end end rbsp_5[5] : begin len_5 <= 7; if (rbsp_5[6] == 'b1) begin TrailingOnes_5 <= 1; TotalCoeff_5 <= 3; end else begin TrailingOnes_5 <= 2; TotalCoeff_5 <= 3; end end rbsp_5[6] : begin len_5 <= 8; if (rbsp_5[7] == 'b1) begin TrailingOnes_5 <= 1; TotalCoeff_5 <= 4; end else begin TrailingOnes_5 <= 2; TotalCoeff_5 <= 4; end end default : begin len_5 <= 7; TrailingOnes_5 <= 3; TotalCoeff_5 <= 4; end endcase always @(*) begin if (nC == -1) begin TrailingOnes_comb <= TrailingOnes_5; TotalCoeff_comb <= TotalCoeff_5; len_comb <= len_5; end else if (nC[4] | nC[3]) begin TrailingOnes_comb <= TrailingOnes_4; TotalCoeff_comb <= TotalCoeff_4; len_comb <= len_4; end else if (nC[2]) begin TrailingOnes_comb <= TrailingOnes_3; TotalCoeff_comb <= TotalCoeff_3; len_comb <= len_3; end else if (nC[1]) begin TrailingOnes_comb <= TrailingOnes_2; TotalCoeff_comb <= TotalCoeff_2; len_comb <= len_2; end else begin TrailingOnes_comb <= TrailingOnes_1; TotalCoeff_comb <= TotalCoeff_1; len_comb <= len_1; end end always @(posedge clk or negedge rst_n) if (!rst_n) begin TrailingOnes <= 0; TotalCoeff <= 0; end else if (ena && sel) begin TrailingOnes <= TrailingOnes_comb; TotalCoeff <= TotalCoeff_comb; end endmodule", "assertions_gpt_4o": "(nC == -1) |-> (TrailingOnes_comb == TrailingOnes_5 && TotalCoeff_comb == TotalCoeff_5 && len_comb == len_5);\n(nC[4] | nC[3]) |-> (TrailingOnes_comb == TrailingOnes_4 && TotalCoeff_comb == TotalCoeff_4 && len_comb == len_4);\n(nC[2]) |-> (TrailingOnes_comb == TrailingOnes_3 && TotalCoeff_comb == TotalCoeff_3 && len_comb == len_3);\n(nC[1]) |-> (TrailingOnes_comb == TrailingOnes_2 && TotalCoeff_comb == TotalCoeff_2 && len_comb == len_2);\n!(nC == -1 || nC[4] || nC[3] || nC[2] || nC[1]) |-> (TrailingOnes_comb == TrailingOnes_1 && TotalCoeff_comb == TotalCoeff_1 && len_comb == len_1);\n!rst_n |-> (rbsp_1 == 0 && rbsp_2 == 0 && rbsp_3 == 0 && rbsp_4 == 0 && rbsp_5 == 0);\n(ena && start && nC[5]) |-> (rbsp_5 == rbsp[0:7]);\n(ena && start && !(nC[5]) && (nC[4] || nC[3])) |-> (rbsp_4 == rbsp[0:5]);\n(ena && start && !(nC[5]) && !(nC[4] || nC[3]) && nC[2]) |-> (rbsp_3 == rbsp[0:9]);\n(ena && start && !(nC[5]) && !(nC[4] || nC[3]) && !(nC[2]) && nC[1]) |-> (rbsp_2 == rbsp[0:13]);\n(ena && start && !(nC[5]) && !(nC[4] || nC[3]) && !(nC[2]) && !(nC[1])) |-> (rbsp_1 == rbsp);\n(rbsp_1[0]) |-> (TrailingOnes_1 == 0 && TotalCoeff_1 == 0 && len_1 == 1);\n(rbsp_1[1]) |-> (TrailingOnes_1 == 1 && TotalCoeff_1 == 1 && len_1 == 2);\n(rbsp_1[2]) |-> (TrailingOnes_1 == 2 && TotalCoeff_1 == 2 && len_1 == 3);\n(rbsp_1[3] && rbsp_1[4] == 'b1) |-> (TrailingOnes_1 == 3 && TotalCoeff_1 == 3 && len_1 == 5);\n(rbsp_1[3] && rbsp_1[5] == 'b1) |-> (TrailingOnes_1 == 0 && TotalCoeff_1 == 1 && len_1 == 6);\n(rbsp_1[3] && !(rbsp_1[4] == 'b1) && !(rbsp_1[5] == 'b1)) |-> (TrailingOnes_1 == 1 && TotalCoeff_1 == 2 && len_1 == 6);\n(rbsp_1[4] && rbsp_1[5] == 'b1) |-> (TrailingOnes_1 == 3 && TotalCoeff_1 == 4 && len_1 == 6);\n(rbsp_1[4] && rbsp_1[6] == 'b1) |-> (TrailingOnes_1 == 2 && TotalCoeff_1 == 3 && len_1 == 7);\n(rbsp_1[4] && !(rbsp_1[5] == 'b1) && !(rbsp_1[6] == 'b1)) |-> (TrailingOnes_1 == 3 && TotalCoeff_1 == 5 && len_1 == 7);\n(rbsp_1[5] && rbsp_1[6:7] == 'b11) |-> (TrailingOnes_1 == 0 && TotalCoeff_1 == 2 && len_1 == 8);\n(rbsp_1[5] && rbsp_1[6:7] == 'b10) |-> (TrailingOnes_1 == 1 && TotalCoeff_1 == 3 && len_1 == 8);\n(rbsp_1[5] && rbsp_1[6:7] == 'b01) |-> (TrailingOnes_1 == 2 && TotalCoeff_1 == 4 && len_"}, {"file_name": "cavlc_read_total_zeros.v", "verilog_design": "`include \"defines.v\" module cavlc_read_total_zeros ( ena, sel, chroma_DC_sel, rbsp, TotalCoeff, TotalZeros_comb, len_comb ); input ena; input sel; input chroma_DC_sel; input [0:8] rbsp; input [3:0] TotalCoeff; output [3:0] TotalZeros_comb; output [3:0] len_comb; reg [3:0] TotalZeros_comb; reg [3:0] len_comb; reg [0:2] rbsp_chroma_DC; reg [1:0] TotalZeros_chroma_DC; reg [1:0] len_chroma_DC; reg [0:8] rbsp_LE3; reg [3:0] TotalZeros_LE3; reg [3:0] len_LE3; reg [0:5] rbsp_G3; reg [3:0] TotalZeros_G3; reg [2:0] len_G3; always @(*) if (ena && sel && chroma_DC_sel) begin rbsp_chroma_DC <= rbsp[0:2]; rbsp_LE3 <= 'hffff; rbsp_G3 <= 'hffff; end else if (ena && sel && TotalCoeff[3:2] == 2'b00) begin rbsp_chroma_DC <= 'hffff; rbsp_LE3 <= rbsp[0:8]; rbsp_G3 <= 'hffff; end else if (ena && sel)begin rbsp_chroma_DC <= 'hffff; rbsp_LE3 <= 'hffff; rbsp_G3 <= rbsp[0:5]; end else begin rbsp_chroma_DC <= 'hffff; rbsp_LE3 <= 'hffff; rbsp_G3 <= 'hffff; end always @(*) if ( TotalCoeff == 1 && rbsp_chroma_DC[0] ) begin TotalZeros_chroma_DC <= 0; len_chroma_DC <= 1; end else if ( TotalCoeff == 1 && rbsp_chroma_DC[1] ) begin TotalZeros_chroma_DC <= 1; len_chroma_DC <= 2; end else if ( TotalCoeff == 1 && rbsp_chroma_DC[2] ) begin TotalZeros_chroma_DC <= 2; len_chroma_DC <= 3; end else if ( TotalCoeff == 1 ) begin TotalZeros_chroma_DC <= 3; len_chroma_DC <= 3; end else if ( TotalCoeff == 2 && rbsp_chroma_DC[0] ) begin TotalZeros_chroma_DC <= 0; len_chroma_DC <= 1; end else if ( TotalCoeff == 2 && rbsp_chroma_DC[1] ) begin TotalZeros_chroma_DC <= 1; len_chroma_DC <= 2; end else if ( TotalCoeff == 2 ) begin TotalZeros_chroma_DC <= 2; len_chroma_DC <= 2; end else if ( rbsp_chroma_DC[0] ) begin TotalZeros_chroma_DC <= 0; len_chroma_DC <= 1; end else begin TotalZeros_chroma_DC <= 1; len_chroma_DC <= 1; end always @(rbsp_LE3 or TotalCoeff) case (TotalCoeff[1:0]) 1 :begin case(1'b1) rbsp_LE3[0] : begin TotalZeros_LE3 <= 0; len_LE3 <= 1; end rbsp_LE3[1] : begin len_LE3 <= 3; if (rbsp_LE3[2]) TotalZeros_LE3 <= 1; else TotalZeros_LE3 <= 2; end rbsp_LE3[2] : begin len_LE3 <= 4; if (rbsp_LE3[3]) TotalZeros_LE3 <= 3; else TotalZeros_LE3 <= 4; end rbsp_LE3[3] : begin len_LE3 <= 5; if (rbsp_LE3[4]) TotalZeros_LE3 <= 5; else TotalZeros_LE3 <= 6; end rbsp_LE3[4] : begin len_LE3 <= 6; if (rbsp_LE3[5]) TotalZeros_LE3 <= 7; else TotalZeros_LE3 <= 8; end rbsp_LE3[5] : begin len_LE3 <= 7; if (rbsp_LE3[6]) TotalZeros_LE3 <= 9; else TotalZeros_LE3 <= 10; end rbsp_LE3[6] : begin len_LE3 <= 8; if (rbsp_LE3[7]) TotalZeros_LE3 <= 11; else TotalZeros_LE3 <= 12; end rbsp_LE3[7] : begin len_LE3 <= 9; if (rbsp_LE3[8]) TotalZeros_LE3 <= 13; else TotalZeros_LE3 <= 14; end default : begin len_LE3 <= 9; TotalZeros_LE3 <= 15; end endcase end 2 : begin case(1'b1) rbsp_LE3[0] : begin len_LE3 <= 3; case(rbsp_LE3[1:2]) 'b11 : TotalZeros_LE3 <= 0; 'b10 : TotalZeros_LE3 <= 1; 'b01 : TotalZeros_LE3 <= 2; 'b00 : TotalZeros_LE3 <= 3; endcase end rbsp_LE3[1] : begin if (rbsp_LE3[2]) begin TotalZeros_LE3 <= 4; len_LE3 <= 3; end else begin len_LE3 <= 4; if (rbsp_LE3[3]) TotalZeros_LE3 <= 5; else TotalZeros_LE3 <= 6; end end rbsp_LE3[2] : begin len_LE3 <= 4; if (rbsp_LE3[3]) TotalZeros_LE3 <= 7; else TotalZeros_LE3 <= 8; end rbsp_LE3[3] : begin len_LE3 <= 5; if (rbsp_LE3[4]) TotalZeros_LE3 <= 9; else TotalZeros_LE3 <= 10; end default : begin len_LE3 <= 6; case(rbsp_LE3[4:5]) 'b11 : TotalZeros_LE3 <= 11; 'b10 : TotalZeros_LE3 <= 12; 'b01 : TotalZeros_LE3 <= 13; 'b00 : TotalZeros_LE3 <= 14; endcase end endcase end 3 : begin case(1'b1) rbsp_LE3[0] : begin len_LE3 <= 3; case(rbsp_LE3[1:2]) 'b11 : TotalZeros_LE3 <= 1; 'b10 : TotalZeros_LE3 <= 2; 'b01 : TotalZeros_LE3 <= 3; 'b00 : TotalZeros_LE3 <= 6; endcase end rbsp_LE3[1] : begin if (rbsp_LE3[2]) begin TotalZeros_LE3 <= 7; len_LE3 <= 3; end else begin len_LE3 <= 4; if (rbsp_LE3[3]) TotalZeros_LE3 <= 0; else TotalZeros_LE3 <= 4; end end rbsp_LE3[2] : begin len_LE3 <= 4; if (rbsp_LE3[3]) TotalZeros_LE3 <= 5; else TotalZeros_LE3 <= 8; end rbsp_LE3[3] : begin len_LE3 <= 5; if (rbsp_LE3[4]) TotalZeros_LE3 <= 9; else TotalZeros_LE3 <= 10; end rbsp_LE3[4] : begin len_LE3 <= 5; TotalZeros_LE3 <= 12; end default : begin len_LE3 <= 6; if(rbsp_LE3[5]) TotalZeros_LE3 <= 11; else TotalZeros_LE3 <= 13; end endcase end default : begin len_LE3 <= 'bx; TotalZeros_LE3 <= 'bx; end endcase always @(rbsp_G3 or TotalCoeff) case (TotalCoeff) 4 : begin case(1'b1) rbsp_G3[0] : begin len_G3 <= 3; case(rbsp_G3[1:2]) 'b11 : TotalZeros_G3 <= 1; 'b10 : TotalZeros_G3 <= 4; 'b01 : TotalZeros_G3 <= 5; 'b00 : TotalZeros_G3 <= 6; endcase end rbsp_G3[1] : begin if (rbsp_G3[2]) begin TotalZeros_G3 <= 8; len_G3 <= 3; end else begin len_G3 <= 4; if (rbsp_G3[3]) TotalZeros_G3 <= 2; else TotalZeros_G3 <= 3; end end rbsp_G3[2] : begin len_G3 <= 4; if (rbsp_G3[3]) TotalZeros_G3 <= 7; else TotalZeros_G3 <= 9; end default : begin len_G3 <= 5; case(rbsp_G3[3:4]) 'b11 : TotalZeros_G3 <= 0; 'b10 : TotalZeros_G3 <= 10; 'b01 : TotalZeros_G3 <= 11; 'b00 : TotalZeros_G3 <= 12; endcase end endcase end 5 :begin case(1'b1) rbsp_G3[0] : begin len_G3 <= 3; case(rbsp_G3[1:2]) 'b11 : TotalZeros_G3 <= 3; 'b10 : TotalZeros_G3 <= 4; 'b01 : TotalZeros_G3 <= 5; 'b00 : TotalZeros_G3 <= 6; endcase end rbsp_G3[1] : begin if (rbsp_G3[2]) begin TotalZeros_G3 <= 7; len_G3 <= 3; end else begin len_G3 <= 4; if (rbsp_G3[3]) TotalZeros_G3 <= 0; else TotalZeros_G3 <= 1; end end rbsp_G3[2] : begin len_G3 <= 4; if (rbsp_G3[3]) TotalZeros_G3 <= 2; else TotalZeros_G3 <= 8; end rbsp_G3[3] : begin len_G3 <= 4; TotalZeros_G3 <= 10; end default : begin len_G3 <= 5; if (rbsp_G3[4]) TotalZeros_G3 <= 9; else TotalZeros_G3 <= 11; end endcase end 6 : begin case(1'b1) rbsp_G3[0] : begin len_G3 <= 3; case(rbsp_G3[1:2]) 'b11 : TotalZeros_G3 <= 2; 'b10 : TotalZeros_G3 <= 3; 'b01 : TotalZeros_G3 <= 4; 'b00 : TotalZeros_G3 <= 5; endcase end rbsp_G3[1] : begin len_G3 <= 3; if (rbsp_G3[2]) TotalZeros_G3 <= 6; else TotalZeros_G3 <= 7; end rbsp_G3[2] : begin len_G3 <= 3; TotalZeros_G3 <= 9; end rbsp_G3[3] : begin len_G3 <= 4; TotalZeros_G3 <= 8; end rbsp_G3[4] : begin len_G3 <= 5; TotalZeros_G3 <= 1; end default : begin len_G3 <= 6; if (rbsp_G3[5]) TotalZeros_G3 <= 0; else TotalZeros_G3 <= 10; end endcase end 7 :begin case(1'b1) rbsp_G3[0] : begin if (rbsp_G3[1]) begin TotalZeros_G3 <= 5; len_G3 <= 2; end else begin len_G3 <= 3; if (rbsp_G3[2]) TotalZeros_G3 <= 2; else TotalZeros_G3 <= 3; end end rbsp_G3[1] : begin len_G3 <= 3; if (rbsp_G3[2]) TotalZeros_G3 <= 4; else TotalZeros_G3 <= 6; end rbsp_G3[2] : begin len_G3 <= 3; TotalZeros_G3 <= 8; end rbsp_G3[3] : begin len_G3 <= 4; TotalZeros_G3 <= 7; end rbsp_G3[4] : begin len_G3 <= 5; TotalZeros_G3 <= 1; end default : begin len_G3 <= 6; if (rbsp_G3[5]) TotalZeros_G3 <= 0; else TotalZeros_G3 <= 9; end endcase end 8 :begin case(1'b1) rbsp_G3[0] : begin len_G3 <= 2; if (rbsp_G3[1]) TotalZeros_G3 <= 4; else TotalZeros_G3 <= 5; end rbsp_G3[1] : begin len_G3 <= 3; if (rbsp_G3[2]) TotalZeros_G3 <= 3; else TotalZeros_G3 <= 6; end rbsp_G3[2] : begin len_G3 <= 3; TotalZeros_G3 <= 7; end rbsp_G3[3] : begin len_G3 <= 4; TotalZeros_G3 <= 1; end rbsp_G3[4] : begin len_G3 <= 5; TotalZeros_G3 <= 2; end default : begin len_G3 <= 6; if (rbsp_G3[5]) TotalZeros_G3 <= 0; else TotalZeros_G3 <= 8; end endcase end 9 : begin case(1'b1) rbsp_G3[0] : begin len_G3 <= 2; if (rbsp_G3[1]) TotalZeros_G3 <= 3; else TotalZeros_G3 <= 4; end rbsp_G3[1] : begin len_G3 <= 2; TotalZeros_G3 <= 6; end rbsp_G3[2] : begin len_G3 <= 3; TotalZeros_G3 <= 5; end rbsp_G3[3] : begin len_G3 <= 4; TotalZeros_G3 <= 2; end rbsp_G3[4] : begin len_G3 <= 5; TotalZeros_G3 <= 7; end default : begin len_G3 <= 6; if (rbsp_G3[5]) TotalZeros_G3 <= 0; else TotalZeros_G3 <= 1; end endcase end 10 : begin case(1'b1) rbsp_G3[0] : begin len_G3 <= 2; if (rbsp_G3[1]) TotalZeros_G3 <= 3; else TotalZeros_G3 <= 4; end rbsp_G3[1] : begin len_G3 <= 2; TotalZeros_G3 <= 5; end rbsp_G3[2] : begin len_G3 <= 3; TotalZeros_G3 <= 2; end rbsp_G3[3] : begin len_G3 <= 4; TotalZeros_G3 <= 6; end default : begin len_G3 <= 5; if (rbsp_G3[4]) TotalZeros_G3 <= 0; else TotalZeros_G3 <= 1; end endcase end 11 : begin case(1'b1) rbsp_G3[0] : begin len_G3 <= 1; TotalZeros_G3 <= 4; end rbsp_G3[1] : begin len_G3 <= 3; if (rbsp_G3[2]) TotalZeros_G3 <= 5; else TotalZeros_G3 <= 3; end rbsp_G3[2] : begin len_G3 <= 3; TotalZeros_G3 <= 2; end default : begin len_G3 <= 4; if (rbsp_G3[3]) TotalZeros_G3 <= 1; else TotalZeros_G3 <= 0; end endcase end 12 : begin case(1'b1) rbsp_G3[0] : begin len_G3 <= 1; TotalZeros_G3 <= 3; end rbsp_G3[1] : begin len_G3 <= 2; TotalZeros_G3 <= 2; end rbsp_G3[2] : begin len_G3 <= 3; TotalZeros_G3 <= 4; end default : begin len_G3 <= 4; if (rbsp_G3[3]) TotalZeros_G3 <= 1; else TotalZeros_G3 <= 0; end endcase end 13 :begin if (rbsp_G3[0]) begin TotalZeros_G3 <= 2; len_G3 <= 1; end else if (rbsp_G3[1]) begin TotalZeros_G3 <= 3; len_G3 <= 2; end else if (rbsp_G3[2]) begin TotalZeros_G3 <= 1; len_G3 <= 3; end else begin TotalZeros_G3 <= 0; len_G3 <= 3; end end 14 : begin if (rbsp_G3[0]) begin TotalZeros_G3 <= 2; len_G3 <= 1; end else if (rbsp_G3[1]) begin TotalZeros_G3 <= 1; len_G3 <= 2; end else begin TotalZeros_G3 <= 0; len_G3 <= 2; end end 15 : begin len_G3 <= 1; if (rbsp_G3[0]) TotalZeros_G3 <= 1; else TotalZeros_G3 <= 0; end default : begin len_G3 <= 'bx; TotalZeros_G3 <= 'bx; end endcase always @(*) if (ena && sel && chroma_DC_sel) begin TotalZeros_comb <= TotalZeros_chroma_DC; len_comb <= len_chroma_DC; end else if (ena && sel && TotalCoeff[3:2] == 2'b00) begin TotalZeros_comb <= TotalZeros_LE3; len_comb <= len_LE3; end else if (ena && sel)begin TotalZeros_comb <= TotalZeros_G3; len_comb <= len_G3; end else begin TotalZeros_comb <= 0; len_comb <= 0; end endmodule", "assertions_gpt_4o": "(ena && sel && chroma_DC_sel) |-> (rbsp_chroma_DC == rbsp[0:2]);\n(ena && sel && chroma_DC_sel) |-> (rbsp_LE3 == 'hffff);\n(ena && sel && chroma_DC_sel) |-> (rbsp_G3 == 'hffff);\n(ena && sel && TotalCoeff[3:2] == 2'b00) |-> (rbsp_chroma_DC == 'hffff);\n(ena && sel && TotalCoeff[3:2] == 2'b00) |-> (rbsp_LE3 == rbsp[0:8]);\n(ena && sel && TotalCoeff[3:2] == 2'b00) |-> (rbsp_G3 == 'hffff);\n(ena && sel && !chroma_DC_sel && TotalCoeff[3:2] != 2'b00) |-> (rbsp_chroma_DC == 'hffff);\n(ena && sel && !chroma_DC_sel && TotalCoeff[3:2] != 2'b00) |-> (rbsp_LE3 == 'hffff);\n(ena && sel && !chroma_DC_sel && TotalCoeff[3:2] != 2'b00) |-> (rbsp_G3 == rbsp[0:5]);\n(!ena || !sel) |-> (rbsp_chroma_DC == 'hffff);\n(!ena || !sel) |-> (rbsp_LE3 == 'hffff);\n(!ena || !sel) |-> (rbsp_G3 == 'hffff);\n(TotalCoeff == 1 && rbsp_chroma_DC[0]) |-> (TotalZeros_chroma_DC == 0 && len_chroma_DC == 1);\n(TotalCoeff == 1 && rbsp_chroma_DC[1]) |-> (TotalZeros_chroma_DC == 1 && len_chroma_DC == 2);\n(TotalCoeff == 1 && rbsp_chroma_DC[2]) |-> (TotalZeros_chroma_DC == 2 && len_chroma_DC == 3);\n(TotalCoeff == 1 && !rbsp_chroma_DC[0] && !rbsp_chroma_DC[1] && !rbsp_chroma_DC[2]) |-> (TotalZeros_chroma_DC == 3 && len_chroma_DC == 3);\n(TotalCoeff == 2 && rbsp_chroma_DC[0]) |-> (TotalZeros_chroma_DC == 0 && len_chroma_DC == 1);\n(TotalCoeff == 2 && rbsp_chroma_DC[1]) |-> (TotalZeros_chroma_DC == 1 && len_chroma_DC == 2);\n(TotalCoeff == 2 && !rbsp_chroma_DC[0] && !rbsp_chroma_DC[1]) |-> (TotalZeros_chroma_DC == 2 && len_chroma_DC == 2);\n(TotalCoeff != 1 && TotalCoeff != 2 && rbsp_chroma_DC[0]) |-> (TotalZeros_chroma_DC == 0 && len_chroma_DC == 1);\n(TotalCoeff != 1 && TotalCoeff != 2 && !rbsp_chroma_DC[0]) |-> (TotalZeros_chroma_DC == 1 && len_chroma_DC == 1);\n(TotalCoeff[1:0] == 1 && rbsp_LE3[0]) |-> (TotalZeros_LE3 == 0 && len_LE3 == 1);\n(TotalCoeff[1:0] == 1 && rbsp_LE3[1] && rbsp_LE3[2]) |-> (TotalZeros_LE3 == 1 && len_LE3 == 3);\n(TotalCoeff[1:0] == 1 && rbsp_LE3[1] && !rbsp_LE3[2]) |-> (TotalZeros_LE3 == 2 && len_LE3 == 3);\n(TotalCoeff[1:0] == 1 && rbsp_LE3[2] && rbsp_LE3[3]) |-> (TotalZeros_LE3 == 3 && len_LE3 == 4);\n(TotalCoeff[1:0] == 1 && rbsp_LE3[2] && !rbsp_LE3[3]) |-> (TotalZeros_LE3 == 4 && len_LE3 == 4);\n(TotalCoeff[1:0] == 1 && rbsp_LE3[3] && rbsp_LE3[4]) |-> (TotalZeros_LE3 == 5 && len_LE3 == 5);\n(TotalCoeff[1:0] == 1 && rbsp_LE3[3] && !rbsp_LE3[4]) |-> (TotalZeros_LE3 == 6 && len_LE3 == 5);\n(TotalCoeff[1:0] == 1 && rbsp_LE3[4] && rbsp_LE"}, {"file_name": "cavlc_top.v", "verilog_design": "`include \"defines.v\" `include \"cavlc_read_total_coeffs.v\" `include \"cavlc_read_run_befores.v\" `include \"cavlc_read_levels.v\" `include \"cavlc_read_total_zeros.v\" `include \"cavlc_fsm.v\" `include \"cavlc_len_gen.v\" module cavlc_top ( clk, rst_n, ena, start, rbsp, nC, max_coeff_num, coeff_0, coeff_1, coeff_2, coeff_3, coeff_4, coeff_5, coeff_6, coeff_7, coeff_8, coeff_9, coeff_10, coeff_11, coeff_12, coeff_13, coeff_14, coeff_15, TotalCoeff, len_comb, idle, valid ); input clk, rst_n; input ena; input start; input [0:15] rbsp; input signed [5:0] nC; input [4:0] max_coeff_num; output signed [8:0] coeff_0; output signed [8:0] coeff_1; output signed [8:0] coeff_2; output signed [8:0] coeff_3; output signed [8:0] coeff_4; output signed [8:0] coeff_5; output signed [8:0] coeff_6; output signed [8:0] coeff_7; output signed [8:0] coeff_8; output signed [8:0] coeff_9; output signed [8:0] coeff_10; output signed [8:0] coeff_11; output signed [8:0] coeff_12; output signed [8:0] coeff_13; output signed [8:0] coeff_14; output signed [8:0] coeff_15; output [4:0] TotalCoeff; output [4:0] len_comb; output idle; output valid; wire [1:0] TrailingOnes; wire [4:0] TotalCoeff; wire [1:0] TrailingOnes_comb; wire [4:0] TotalCoeff_comb; wire [4:0] len_read_total_coeffs_comb; wire [7:0] cavlc_state; cavlc_read_total_coeffs cavlc_read_total_coeffs( .clk(clk), .rst_n(rst_n), .ena(ena), .start(start), .sel(cavlc_state[`cavlc_read_total_coeffs_bit]), .rbsp(rbsp), .nC(nC), .TrailingOnes(TrailingOnes), .TotalCoeff(TotalCoeff), .TrailingOnes_comb(TrailingOnes_comb), .TotalCoeff_comb(TotalCoeff_comb), .len_comb(len_read_total_coeffs_comb) ); wire [4:0] len_read_levels_comb; wire [3:0] i; wire [8:0] level_0; wire [8:0] level_1; wire [8:0] level_2; wire [8:0] level_3; wire [8:0] level_4; wire [8:0] level_5; wire [8:0] level_6; wire [8:0] level_7; wire [8:0] level_8; wire [8:0] level_9; wire [8:0] level_10; wire [8:0] level_11; wire [8:0] level_12; wire [8:0] level_13; wire [8:0] level_14; wire [8:0] level_15; cavlc_read_levels cavlc_read_levels( .clk(clk), .rst_n(rst_n), .ena(ena), .t1s_sel(cavlc_state[`cavlc_read_t1s_flags_bit]), .prefix_sel(cavlc_state[`cavlc_read_level_prefix_bit]), .suffix_sel(cavlc_state[`cavlc_read_level_suffix_bit]), .calc_sel(cavlc_state[`cavlc_calc_level_bit]), .TrailingOnes(TrailingOnes), .TotalCoeff(TotalCoeff), .i(i), .rbsp(rbsp), .level_0(level_0), .level_1(level_1), .level_2(level_2), .level_3(level_3), .level_4(level_4), .level_5(level_5), .level_6(level_6), .level_7(level_7), .level_8(level_8), .level_9(level_9), .level_10(level_10), .level_11(level_11), .level_12(level_12), .level_13(level_13), .level_14(level_14), .level_15(level_15), .len_comb(len_read_levels_comb) ); wire [3:0] TotalZeros_comb; wire [3:0] len_read_total_zeros_comb; cavlc_read_total_zeros cavlc_read_total_zeros( .ena(ena), .sel(cavlc_state[`cavlc_read_total_zeros_bit]), .chroma_DC_sel(nC[5]), .rbsp(rbsp[0:8]), .TotalCoeff(TotalCoeff[3:0]), .TotalZeros_comb(TotalZeros_comb), .len_comb(len_read_total_zeros_comb) ); wire [3:0] ZeroLeft; wire [3:0] len_read_run_befores_comb; cavlc_read_run_befores cavlc_read_run_befores( .clk(clk), .rst_n(rst_n), .ena(ena), .clr(cavlc_state[`cavlc_read_total_coeffs_bit]), .sel(cavlc_state[`cavlc_read_run_befores_bit]), .ZeroLeft_init(cavlc_state[`cavlc_read_total_zeros_bit]), .rbsp(rbsp[0:10]), .i(i), .TotalZeros_comb(TotalZeros_comb), .level_0(level_0), .level_1(level_1), .level_2(level_2), .level_3(level_3), .level_4(level_4), .level_5(level_5), .level_6(level_6), .level_7(level_7), .level_8(level_8), .level_9(level_9), .level_10(level_10), .level_11(level_11), .level_12(level_12), .level_13(level_13), .level_14(level_14), .level_15(level_15), .coeff_0(coeff_0), .coeff_1(coeff_1), .coeff_2(coeff_2), .coeff_3(coeff_3), .coeff_4(coeff_4), .coeff_5(coeff_5), .coeff_6(coeff_6), .coeff_7(coeff_7), .coeff_8(coeff_8), .coeff_9(coeff_9), .coeff_10(coeff_10), .coeff_11(coeff_11), .coeff_12(coeff_12), .coeff_13(coeff_13), .coeff_14(coeff_14), .coeff_15(coeff_15), .ZeroLeft(ZeroLeft), .len_comb(len_read_run_befores_comb) ); wire [4:0] len_comb; cavlc_len_gen cavlc_len_gen( .cavlc_state(cavlc_state), .len_read_total_coeffs_comb(len_read_total_coeffs_comb), .len_read_levels_comb(len_read_levels_comb), .len_read_total_zeros_comb(len_read_total_zeros_comb), .len_read_run_befores_comb(len_read_run_befores_comb), .len_comb(len_comb) ); cavlc_fsm cavlc_fsm( .clk(clk), .rst_n(rst_n), .ena(ena), .start(start), .max_coeff_num(max_coeff_num), .TotalCoeff(TotalCoeff), .TotalCoeff_comb(TotalCoeff_comb), .TrailingOnes(TrailingOnes), .TrailingOnes_comb(TrailingOnes_comb), .ZeroLeft(ZeroLeft), .state(cavlc_state), .i(i), .idle(idle), .valid(valid) ); endmodule", "assertions_gpt_4o": "1. (rst_n == 0) |-> (idle == 1);\n2. (start == 1) |-> (idle == 0);\n3. (ena == 1 && cavlc_state[`cavlc_read_total_coeffs_bit] == 1) |-> (TotalCoeff <= max_coeff_num);\n4. (ena == 1 && cavlc_state[`cavlc_read_t1s_flags_bit] == 1) |-> (TrailingOnes <= 3);\n5. (ena == 1 && cavlc_state[`cavlc_read_level_prefix_bit] == 1) |-> (level_0 <= 2047);\n6. (ena == 1 && cavlc_state[`cavlc_read_level_suffix_bit] == 1) |-> (level_1 <= 2047);\n7. (ena == 1 && cavlc_state[`cavlc_calc_level_bit] == 1) |-> (level_2 <= 2047);\n8. (ena == 1 && cavlc_state[`cavlc_read_total_zeros_bit] == 1) |-> (TotalZeros_comb <= 15);\n9. (ena == 1 && cavlc_state[`cavlc_read_run_befores_bit] == 1) |-> (ZeroLeft <= 15);\n10. (valid == 1) |-> (idle == 0);\n11. (idle == 1) |-> (valid == 0);\n12. (cavlc_state[`cavlc_read_total_coeffs_bit] == 1) |-> (len_comb == len_read_total_coeffs_comb);\n13. (cavlc_state[`cavlc_read_levels_bit] == 1) |-> (len_comb == len_read_levels_comb);\n14. (cavlc_state[`cavlc_read_total_zeros_bit] == 1) |-> (len_comb == len_read_total_zeros_comb);\n15. (cavlc_state[`cavlc_read_run_befores_bit] == 1) |-> (len_comb == len_read_run_befores_comb);\n16. (cavlc_state[`cavlc_read_total_coeffs_bit] == 1) |-> (TotalCoeff == TotalCoeff_comb);\n17. (cavlc_state[`cavlc_read_t1s_flags_bit] == 1) |-> (TrailingOnes == TrailingOnes_comb);\n18. (cavlc_state[`cavlc_read_total_zeros_bit] == 1) |-> (ZeroLeft == TotalZeros_comb);\n19. (cavlc_state[`cavlc_read_run_befores_bit] == 1) |-> (ZeroLeft == ZeroLeft);\n20. (cavlc_state[`cavlc_read_levels_bit] == 1) |-> (level_0 == coeff_0);\n21. (cavlc_state[`cavlc_read_levels_bit] == 1) |-> (level_1 == coeff_1);\n22. (cavlc_state[`cavlc_read_levels_bit] == 1) |-> (level_2 == coeff_2);\n23. (cavlc_state[`cavlc_read_levels_bit] == 1) |-> (level_3 == coeff_3);\n24. (cavlc_state[`cavlc_read_levels_bit] == 1) |-> (level_4 == coeff_4);\n25. (cavlc_state[`cavlc_read_levels_bit] == 1) |-> (level_5 == coeff_5);\n26. (cavlc_state[`cavlc_read_levels_bit] == 1) |-> (level_6 == coeff_6);\n27. (cavlc_state[`cavlc_read_levels_bit] == 1) |-> (level_7 == coeff_7);\n28. (cavlc_state[`cavlc_read_levels_bit] == 1) |-> (level_8 == coeff_8);\n29. (cavlc_state[`cavlc_read_levels_bit] == 1) |-> (level_9 == coeff_9);\n30. (cavlc_state[`cavlc_read_levels_bit] == 1) |-> (level_10 == coeff_10);\n31. (cavlc_state[`cavlc_read_levels_bit] == 1) |-> (level_11 == coeff_11);\n32. (cavlc_state[`cavlc_read_levels_bit] == 1) |-> (level_12 == coeff_12);\n33. (cavlc_state[`cavlc_read_levels_bit] == 1) |-> (level_13 == coeff_13);\n34. (cavlc_state[`cavlc_read_levels_bit] == 1) |-> (level_14 == coeff_14);\n35."}, {"file_name": "ca_prng.v", "verilog_design": "module ca_prng( input wire clk, input wire reset_n, input wire [31 : 0] init_pattern_data, input wire load_init_pattern, input wire next_pattern, input wire [7 : 0] update_rule, input wire load_update_rule, output wire [31 : 0] prng_data ); parameter [7 : 0] DEFAULT_RULE = 8'b00011110; reg [31 : 0] ca_state_reg; reg [31 : 0] ca_state_new; reg ca_state_we; reg [7 : 0] update_rule_reg; reg [31 : 0] tmp_ca_state_new; assign prng_data = ca_state_reg; always @ (posedge clk) begin : reg_update if (!reset_n) begin update_rule_reg <= DEFAULT_RULE; ca_state_reg <= 32'b00000000000000000000000000000000; end else begin if (load_update_rule) begin update_rule_reg <= update_rule; end if (ca_state_we) begin ca_state_reg <= ca_state_new; end end end always @* begin : ca_state_update case({ca_state_reg[31], ca_state_reg[0], ca_state_reg[1]}) 0: begin tmp_ca_state_new[0] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[0] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[0] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[0] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[0] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[0] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[0] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[0] = update_rule_reg[7]; end endcase case({ca_state_reg[0], ca_state_reg[1], ca_state_reg[2]}) 0: begin tmp_ca_state_new[1] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[1] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[1] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[1] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[1] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[1] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[1] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[1] = update_rule_reg[7]; end endcase case({ca_state_reg[1], ca_state_reg[2], ca_state_reg[3]}) 0: begin tmp_ca_state_new[2] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[2] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[2] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[2] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[2] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[2] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[2] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[2] = update_rule_reg[7]; end endcase case({ca_state_reg[2], ca_state_reg[3], ca_state_reg[4]}) 0: begin tmp_ca_state_new[3] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[3] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[3] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[3] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[3] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[3] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[3] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[3] = update_rule_reg[7]; end endcase case({ca_state_reg[3], ca_state_reg[4], ca_state_reg[5]}) 0: begin tmp_ca_state_new[4] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[4] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[4] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[4] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[4] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[4] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[4] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[4] = update_rule_reg[7]; end endcase case({ca_state_reg[4], ca_state_reg[5], ca_state_reg[6]}) 0: begin tmp_ca_state_new[5] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[5] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[5] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[5] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[5] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[5] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[5] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[5] = update_rule_reg[7]; end endcase case({ca_state_reg[5], ca_state_reg[6], ca_state_reg[7]}) 0: begin tmp_ca_state_new[6] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[6] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[6] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[6] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[6] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[6] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[6] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[6] = update_rule_reg[7]; end endcase case({ca_state_reg[6], ca_state_reg[7], ca_state_reg[8]}) 0: begin tmp_ca_state_new[7] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[7] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[7] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[7] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[7] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[7] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[7] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[7] = update_rule_reg[7]; end endcase case({ca_state_reg[7], ca_state_reg[8], ca_state_reg[9]}) 0: begin tmp_ca_state_new[8] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[8] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[8] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[8] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[8] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[8] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[8] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[8] = update_rule_reg[7]; end endcase case({ca_state_reg[8], ca_state_reg[9], ca_state_reg[10]}) 0: begin tmp_ca_state_new[9] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[9] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[9] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[9] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[9] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[9] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[9] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[9] = update_rule_reg[7]; end endcase case({ca_state_reg[9], ca_state_reg[10], ca_state_reg[11]}) 0: begin tmp_ca_state_new[10] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[10] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[10] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[10] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[10] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[10] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[10] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[10] = update_rule_reg[7]; end endcase case({ca_state_reg[10], ca_state_reg[11], ca_state_reg[12]}) 0: begin tmp_ca_state_new[11] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[11] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[11] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[11] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[11] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[11] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[11] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[11] = update_rule_reg[7]; end endcase case({ca_state_reg[11], ca_state_reg[12], ca_state_reg[13]}) 0: begin tmp_ca_state_new[12] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[12] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[12] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[12] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[12] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[12] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[12] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[12] = update_rule_reg[7]; end endcase case({ca_state_reg[12], ca_state_reg[13], ca_state_reg[14]}) 0: begin tmp_ca_state_new[13] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[13] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[13] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[13] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[13] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[13] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[13] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[13] = update_rule_reg[7]; end endcase case({ca_state_reg[13], ca_state_reg[14], ca_state_reg[15]}) 0: begin tmp_ca_state_new[14] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[14] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[14] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[14] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[14] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[14] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[14] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[14] = update_rule_reg[7]; end endcase case({ca_state_reg[14], ca_state_reg[15], ca_state_reg[16]}) 0: begin tmp_ca_state_new[15] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[15] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[15] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[15] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[15] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[15] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[15] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[15] = update_rule_reg[7]; end endcase case({ca_state_reg[15], ca_state_reg[16], ca_state_reg[17]}) 0: begin tmp_ca_state_new[16] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[16] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[16] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[16] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[16] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[16] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[16] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[16] = update_rule_reg[7]; end endcase case({ca_state_reg[16], ca_state_reg[17], ca_state_reg[18]}) 0: begin tmp_ca_state_new[17] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[17] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[17] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[17] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[17] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[17] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[17] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[17] = update_rule_reg[7]; end endcase case({ca_state_reg[17], ca_state_reg[18], ca_state_reg[19]}) 0: begin tmp_ca_state_new[18] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[18] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[18] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[18] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[18] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[18] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[18] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[18] = update_rule_reg[7]; end endcase case({ca_state_reg[18], ca_state_reg[19], ca_state_reg[20]}) 0: begin tmp_ca_state_new[19] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[19] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[19] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[19] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[19] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[19] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[19] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[19] = update_rule_reg[7]; end endcase case({ca_state_reg[19], ca_state_reg[20], ca_state_reg[21]}) 0: begin tmp_ca_state_new[20] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[20] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[20] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[20] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[20] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[20] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[20] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[20] = update_rule_reg[7]; end endcase case({ca_state_reg[20], ca_state_reg[21], ca_state_reg[22]}) 0: begin tmp_ca_state_new[21] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[21] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[21] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[21] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[21] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[21] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[21] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[21] = update_rule_reg[7]; end endcase case({ca_state_reg[21], ca_state_reg[22], ca_state_reg[23]}) 0: begin tmp_ca_state_new[22] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[22] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[22] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[22] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[22] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[22] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[22] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[22] = update_rule_reg[7]; end endcase case({ca_state_reg[22], ca_state_reg[23], ca_state_reg[24]}) 0: begin tmp_ca_state_new[23] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[23] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[23] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[23] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[23] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[23] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[23] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[23] = update_rule_reg[7]; end endcase case({ca_state_reg[23], ca_state_reg[24], ca_state_reg[25]}) 0: begin tmp_ca_state_new[24] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[24] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[24] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[24] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[24] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[24] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[24] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[24] = update_rule_reg[7]; end endcase case({ca_state_reg[24], ca_state_reg[25], ca_state_reg[26]}) 0: begin tmp_ca_state_new[25] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[25] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[25] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[25] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[25] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[25] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[25] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[25] = update_rule_reg[7]; end endcase case({ca_state_reg[25], ca_state_reg[26], ca_state_reg[27]}) 0: begin tmp_ca_state_new[26] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[26] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[26] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[26] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[26] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[26] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[26] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[26] = update_rule_reg[7]; end endcase case({ca_state_reg[26], ca_state_reg[27], ca_state_reg[28]}) 0: begin tmp_ca_state_new[27] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[27] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[27] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[27] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[27] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[27] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[27] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[27] = update_rule_reg[7]; end endcase case({ca_state_reg[27], ca_state_reg[28], ca_state_reg[29]}) 0: begin tmp_ca_state_new[28] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[28] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[28] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[28] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[28] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[28] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[28] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[28] = update_rule_reg[7]; end endcase case({ca_state_reg[28], ca_state_reg[29], ca_state_reg[30]}) 0: begin tmp_ca_state_new[29] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[29] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[29] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[29] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[29] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[29] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[29] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[29] = update_rule_reg[7]; end endcase case({ca_state_reg[29], ca_state_reg[30], ca_state_reg[31]}) 0: begin tmp_ca_state_new[30] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[30] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[30] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[30] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[30] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[30] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[30] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[30] = update_rule_reg[7]; end endcase case({ca_state_reg[30], ca_state_reg[31], ca_state_reg[0]}) 0: begin tmp_ca_state_new[31] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[31] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[31] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[31] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[31] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[31] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[31] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[31] = update_rule_reg[7]; end endcase if (load_init_pattern) begin ca_state_new = init_pattern_data; end else begin ca_state_new = tmp_ca_state_new; end if (load_init_pattern || next_pattern) begin ca_state_we = 1; end else begin ca_state_we = 0; end end endmodule", "assertions_gpt_4o": "1. (!reset_n) |-> (update_rule_reg == DEFAULT_RULE && ca_state_reg == 32'b00000000000000000000000000000000);\n2. (load_update_rule) |-> (update_rule_reg == update_rule);\n3. (ca_state_we) |-> (ca_state_reg == ca_state_new);\n4. (load_init_pattern) |-> (ca_state_new == init_pattern_data);\n5. (!load_init_pattern && !next_pattern) |-> (ca_state_we == 0);\n6. (load_init_pattern || next_pattern) |-> (ca_state_we == 1);\n7. ({ca_state_reg[31], ca_state_reg[0], ca_state_reg[1]} == 0) |-> (tmp_ca_state_new[0] == update_rule_reg[0]);\n8. ({ca_state_reg[31], ca_state_reg[0], ca_state_reg[1]} == 1) |-> (tmp_ca_state_new[0] == update_rule_reg[1]);\n9. ({ca_state_reg[31], ca_state_reg[0], ca_state_reg[1]} == 2) |-> (tmp_ca_state_new[0] == update_rule_reg[2]);\n10. ({ca_state_reg[31], ca_state_reg[0], ca_state_reg[1]} == 3) |-> (tmp_ca_state_new[0] == update_rule_reg[3]);\n11. ({ca_state_reg[31], ca_state_reg[0], ca_state_reg[1]} == 4) |-> (tmp_ca_state_new[0] == update_rule_reg[4]);\n12. ({ca_state_reg[31], ca_state_reg[0], ca_state_reg[1]} == 5) |-> (tmp_ca_state_new[0] == update_rule_reg[5]);\n13. ({ca_state_reg[31], ca_state_reg[0], ca_state_reg[1]} == 6) |-> (tmp_ca_state_new[0] == update_rule_reg[6]);\n14. ({ca_state_reg[31], ca_state_reg[0], ca_state_reg[1]} == 7) |-> (tmp_ca_state_new[0] == update_rule_reg[7]);\n15. ({ca_state_reg[0], ca_state_reg[1], ca_state_reg[2]} == 0) |-> (tmp_ca_state_new[1] == update_rule_reg[0]);\n16. ({ca_state_reg[0], ca_state_reg[1], ca_state_reg[2]} == 1) |-> (tmp_ca_state_new[1] == update_rule_reg[1]);\n17. ({ca_state_reg[0], ca_state_reg[1], ca_state_reg[2]} == 2) |-> (tmp_ca_state_new[1] == update_rule_reg[2]);\n18. ({ca_state_reg[0], ca_state_reg[1], ca_state_reg[2]} == 3) |-> (tmp_ca_state_new[1] == update_rule_reg[3]);\n19. ({ca_state_reg[0], ca_state_reg[1], ca_state_reg[2]} == 4) |-> (tmp_ca_state_new[1] == update_rule_reg[4]);\n20. ({ca_state_reg[0], ca_state_reg[1], ca_state_reg[2]} == 5) |-> (tmp_ca_state_new[1] == update_rule_reg[5]);\n21. ({ca_state_reg[0], ca_state_reg[1], ca_state_reg[2]} == 6) |-> (tmp_ca_state_new[1] == update_rule_reg[6]);\n22. ({ca_state_reg[0], ca_state_reg[1], ca_state_reg[2]} == 7) |-> (tmp_ca_state_new[1] == update_rule_reg[7]);\n23. ({ca_state_reg[1], ca_state_reg[2], ca_state_reg[3]} == 0) |-> (tmp_ca_state_new[2] == update_rule_reg[0]);\n24. ({ca_state_reg[1], ca_state_reg[2], ca_state_reg[3]} == 1) |-> (tmp_ca_state_new[2] == update_rule_reg[1]);\n25. ({ca_state_reg[1], ca_state_reg[2], ca_state_reg[3]} == 2) |-> (tmp_ca_state_new[2] == update_rule_reg[2]);\n26. ({ca_state_reg[1], ca_state_reg[2], ca_state_reg[3]} == 3) |-> (tmp_ca_state_new[2] == update_rule_reg[3]);\n27. ({ca_state_reg[1], ca_state_reg[2], ca_state_reg[3]} == 4) |-> (tmp_ca_state_new[2] == update_rule_reg[4]);\n28. ({ca_state_reg[1], ca_state_reg["}, {"file_name": "mux4to1.v", "verilog_design": "module mux4to1(e, s, i0, i1, i2, i3, z); parameter WID=4; input e; input [1:0] s; input [WID:1] i0; input [WID:1] i1; input [WID:1] i2; input [WID:1] i3; output [WID:1] z; reg [WID:1] z; always @(e or s or i0 or i1 or i2 or i3) if (!e) z <= {WID{1'b0}}; else begin case(s) 2'b00: z <= i0; 2'b01: z <= i1; 2'b10: z <= i2; 2'b11: z <= i3; endcase end endmodule", "assertions_gpt_4o": "(e == 0) |-> (z == {WID{1'b0}});\n(e == 1 && s == 2'b00) |-> (z == i0);\n(e == 1 && s == 2'b01) |-> (z == i1);\n(e == 1 && s == 2'b10) |-> (z == i2);\n(e == 1 && s == 2'b11) |-> (z == i3);"}, {"file_name": "PSGBusArb.v", "verilog_design": "`timescale 1ns / 1ps module PSGBusArb(rst, clk, ce, ack, req0, req1, req2, req3, req4, req5, req6, req7, sel0, sel1, sel2, sel3, sel4, sel5, sel6, sel7, seln); input rst; input clk; input ce; input ack; input req0; input req1; input req2; input req3; input req4; input req5; input req6; input req7; output sel0; reg sel0; output sel1; reg sel1; output sel2; reg sel2; output sel3; reg sel3; output sel4; reg sel4; output sel5; reg sel5; output sel6; reg sel6; output sel7; reg sel7; output [2:0] seln; reg [2:0] seln; always @(posedge clk) begin if (rst) begin sel0 <= 1'b0; sel1 <= 1'b0; sel2 <= 1'b0; sel3 <= 1'b0; sel4 <= 1'b0; sel5 <= 1'b0; sel6 <= 1'b0; sel7 <= 1'b0; seln <= 3'd0; end else begin if (ce&ack) begin if (req0) begin sel0 <= 1'b1; sel1 <= 1'b0; sel2 <= 1'b0; sel3 <= 1'b0; sel4 <= 1'b0; sel5 <= 1'b0; sel6 <= 1'b0; sel7 <= 1'b0; seln <= 3'd0; end else if (req1) begin sel1 <= 1'b1; sel0 <= 1'b0; sel2 <= 1'b0; sel3 <= 1'b0; sel4 <= 1'b0; sel5 <= 1'b0; sel6 <= 1'b0; sel7 <= 1'b0; seln <= 3'd1; end else if (req2) begin sel2 <= 1'b1; sel0 <= 1'b0; sel1 <= 1'b0; sel3 <= 1'b0; sel4 <= 1'b0; sel5 <= 1'b0; sel6 <= 1'b0; sel7 <= 1'b0; seln <= 3'd2; end else if (req3) begin sel3 <= 1'b1; sel0 <= 1'b0; sel1 <= 1'b0; sel2 <= 1'b0; sel4 <= 1'b0; sel5 <= 1'b0; sel6 <= 1'b0; sel7 <= 1'b0; seln <= 3'd3; end else if (req4) begin sel4 <= 1'b1; sel0 <= 1'b0; sel1 <= 1'b0; sel2 <= 1'b0; sel3 <= 1'b0; sel5 <= 1'b0; sel6 <= 1'b0; sel7 <= 1'b0; seln <= 3'd4; end else if (req5) begin sel5 <= 1'b1; sel0 <= 1'b0; sel1 <= 1'b0; sel2 <= 1'b0; sel3 <= 1'b0; sel4 <= 1'b0; sel6 <= 1'b0; sel7 <= 1'b0; seln <= 3'd5; end else if (req6) begin sel6 <= 1'b1; sel0 <= 1'b0; sel1 <= 1'b0; sel2 <= 1'b0; sel3 <= 1'b0; sel4 <= 1'b0; sel5 <= 1'b0; sel7 <= 1'b0; seln <= 3'd6; end else if (req7) begin sel7 <= 1'b1; sel0 <= 1'b0; sel1 <= 1'b0; sel2 <= 1'b0; sel3 <= 1'b0; sel4 <= 1'b0; sel5 <= 1'b0; sel6 <= 1'b0; seln <= 3'd7; end else begin sel0 <= sel0; sel1 <= sel1; sel2 <= sel2; sel3 <= sel3; sel4 <= sel4; sel5 <= sel5; sel6 <= sel6; sel7 <= sel7; seln <= seln; end end end end endmodule", "assertions_gpt_4o": "(req0 == 1 & ce == 1 & ack == 1) |-> (sel0 == 1 & seln == 3'd0);\n(req1 == 1 & ce == 1 & ack == 1) |-> (sel1 == 1 & seln == 3'd1);\n(req2 == 1 & ce == 1 & ack == 1) |-> (sel2 == 1 & seln == 3'd2);\n(req3 == 1 & ce == 1 & ack == 1) |-> (sel3 == 1 & seln == 3'd3);\n(req4 == 1 & ce == 1 & ack == 1) |-> (sel4 == 1 & seln == 3'd4);\n(req5 == 1 & ce == 1 & ack == 1) |-> (sel5 == 1 & seln == 3'd5);\n(req6 == 1 & ce == 1 & ack == 1) |-> (sel6 == 1 & seln == 3'd6);\n(req7 == 1 & ce == 1 & ack == 1) |-> (sel7 == 1 & seln == 3'd7);\n(sel0 == 1) |-> (req0 == 1);\n(sel1 == 1) |-> (req1 == 1);\n(sel2 == 1) |-> (req2 == 1);\n(sel3 == 1) |-> (req3 == 1);\n(sel4 == 1) |-> (req4 == 1);\n(sel5 == 1) |-> (req5 == 1);\n(sel6 == 1) |-> (req6 == 1);\n(sel7 == 1) |-> (req7 == 1);\n(rst == 1) |-> (sel0 == 0 & sel1 == 0 & sel2 == 0 & sel3 == 0 & sel4 == 0 & sel5 == 0 & sel6 == 0 & sel7 == 0 & seln == 3'd0);"}, {"file_name": "PSGChannelSummer.v", "verilog_design": "`timescale 1ns / 1ps module PSGChannelSummer(clk_i, cnt, outctrl, tmc_i, o); input clk_i; input [7:0] cnt; input [3:0] outctrl; input [19:0] tmc_i; output [21:0] o; reg [21:0] o; wire [1:0] sel = cnt[1:0]; always @(posedge clk_i) if (cnt==8'd0) o <= 22'd0 + (tmc_i & {20{outctrl[sel]}}); else if (cnt < 8'd4) o <= o + (tmc_i & {20{outctrl[sel]}}); endmodule", "assertions_gpt_4o": "1. (cnt == 8'd0) |-> (o == 22'd0 + (tmc_i & {20{outctrl[cnt[1:0]]}}));\n2. (cnt < 8'd4 && cnt != 8'd0) |-> (o == $past(o) + (tmc_i & {20{outctrl[cnt[1:0]]}}));\n3. (cnt >= 8'd4) |-> (o == $past(o));"}, {"file_name": "PSGEnvGen.v", "verilog_design": "`include \"mux4to1.v\" `define ENV_IDLE 0 `define ENV_ATTACK 1 `define ENV_DECAY 2 `define ENV_SUSTAIN 3 `define ENV_RELEASE 4 module PSGEnvGen(rst, clk, cnt, gate, attack0, attack1, attack2, attack3, decay0, decay1, decay2, decay3, sustain0, sustain1, sustain2, sustain3, relese0, relese1, relese2, relese3, o); parameter pChannels = 4; parameter pPrescalerBits = 8; input rst; input clk; input [pPrescalerBits-1:0] cnt; input [15:0] attack0; input [15:0] attack1; input [15:0] attack2; input [15:0] attack3; input [11:0] decay0; input [11:0] decay1; input [11:0] decay2; input [11:0] decay3; input [7:0] sustain0; input [7:0] sustain1; input [7:0] sustain2; input [7:0] sustain3; input [11:0] relese0; input [11:0] relese1; input [11:0] relese2; input [11:0] relese3; input [3:0] gate; output [7:0] o; reg [7:0] sustain; reg [15:0] attack; reg [17:0] decay; reg [17:0] relese; reg [7:0] envCtr [3:0]; reg [7:0] envCtr2 [3:0]; reg [7:0] iv [3:0]; reg [2:0] icnt [3:0]; reg [19:0] envDvn [3:0]; reg [2:0] envState [3:0]; reg [2:0] envStateNxt; reg [15:0] envStepPeriod; reg [7:0] envCtrx; reg [19:0] envDvnx; wire [15:0] attack_x; wire [11:0] decay_x; wire [7:0] sustain_x; wire [11:0] relese_x; integer n; wire [1:0] sel = cnt[1:0]; mux4to1 #(16) u1 ( .e(1'b1), .s(sel), .i0(attack0), .i1(attack1), .i2(attack2), .i3(attack3), .z(attack_x) ); mux4to1 #(12) u2 ( .e(1'b1), .s(sel), .i0(decay0), .i1(decay1), .i2(decay2), .i3(decay3), .z(decay_x) ); mux4to1 #(8) u3 ( .e(1'b1), .s(sel), .i0(sustain0), .i1(sustain1), .i2(sustain2), .i3(sustain3), .z(sustain_x) ); mux4to1 #(12) u4 ( .e(1'b1), .s(sel), .i0(relese0), .i1(relese1), .i2(relese2), .i3(relese3), .z(relese_x) ); always @(attack_x) attack <= attack_x; always @(decay_x) decay <= decay_x; always @(sustain_x) sustain <= sustain_x; always @(relese_x) relese <= relese_x; always @(sel) envCtrx <= envCtr[sel]; always @(sel) envDvnx <= envDvn[sel]; always @(sel or gate or sustain) begin case (envState[sel]) `ENV_IDLE: if (gate[sel]) envStateNxt <= `ENV_ATTACK; else envStateNxt <= `ENV_IDLE; `ENV_ATTACK: if (envCtrx==8'hFE) begin if (sustain==8'hFF) envStateNxt <= `ENV_SUSTAIN; else envStateNxt <= `ENV_DECAY; end else envStateNxt <= `ENV_ATTACK; `ENV_DECAY: if (envCtrx==sustain) envStateNxt <= `ENV_SUSTAIN; else envStateNxt <= `ENV_DECAY; `ENV_SUSTAIN: if (~gate[sel]) envStateNxt <= `ENV_RELEASE; else envStateNxt <= `ENV_SUSTAIN; `ENV_RELEASE: begin if (envCtrx==8'h00) envStateNxt <= `ENV_IDLE; else if (gate[sel]) envStateNxt <= `ENV_SUSTAIN; else envStateNxt <= `ENV_RELEASE; end default: envStateNxt <= `ENV_IDLE; endcase end always @(posedge clk) if (rst) begin for (n = 0; n < pChannels; n = n + 1) envState[n] <= `ENV_IDLE; end else if (cnt < pChannels) envState[sel] <= envStateNxt; always @(posedge clk) if (rst) begin for (n = 0; n < pChannels; n = n + 1) begin envCtr[n] <= 0; envCtr2[n] <= 0; icnt[n] <= 0; iv[n] <= 0; end end else if (cnt < pChannels) begin case (envState[sel]) `ENV_IDLE: begin envCtr[sel] <= 0; envCtr2[sel] <= 0; icnt[sel] <= 0; iv[sel] <= 0; end `ENV_SUSTAIN: begin envCtr2[sel] <= 0; icnt[sel] <= 0; iv[sel] <= sustain >> 3; end `ENV_ATTACK: begin icnt[sel] <= 0; iv[sel] <= (8'hff - sustain) >> 3; if (envDvnx==20'h0) begin envCtr2[sel] <= 0; envCtr[sel] <= envCtrx + 1; end end `ENV_DECAY, `ENV_RELEASE: if (envDvnx==20'h0) begin envCtr[sel] <= envCtrx - 1; if (envCtr2[sel]==iv[sel]) begin envCtr2[sel] <= 0; if (icnt[sel] < 3'd7) icnt[sel] <= icnt[sel] + 1; end else envCtr2[sel] <= envCtr2[sel] + 1; end endcase end always @(sel or attack or decay or relese) begin case(envState[sel]) `ENV_ATTACK: envStepPeriod <= attack; `ENV_DECAY: envStepPeriod <= decay; `ENV_RELEASE: envStepPeriod <= relese; default: envStepPeriod <= 16'h0; endcase end wire [19:0] envStepPeriod1 = {4'b0,envStepPeriod} << icnt[sel]; always @(posedge clk) if (rst) begin for (n = 0; n < pChannels; n = n + 1) envDvn[n] <= 0; end else if (cnt < pChannels) begin if (envDvnx==20'h0) envDvn[sel] <= envStepPeriod1; else envDvn[sel] <= envDvnx - 1; end assign o = envCtrx; endmodule", "assertions_gpt_4o": "(envState[sel] == `ENV_IDLE && gate[sel] == 1) |-> (envStateNxt == `ENV_ATTACK);\n(envState[sel] == `ENV_IDLE && gate[sel] == 0) |-> (envStateNxt == `ENV_IDLE);\n(envState[sel] == `ENV_ATTACK && envCtrx == 8'hFE && sustain == 8'hFF) |-> (envStateNxt == `ENV_SUSTAIN);\n(envState[sel] == `ENV_ATTACK && envCtrx == 8'hFE && sustain != 8'hFF) |-> (envStateNxt == `ENV_DECAY);\n(envState[sel] == `ENV_ATTACK && envCtrx != 8'hFE) |-> (envStateNxt == `ENV_ATTACK);\n(envState[sel] == `ENV_DECAY && envCtrx == sustain) |-> (envStateNxt == `ENV_SUSTAIN);\n(envState[sel] == `ENV_DECAY && envCtrx != sustain) |-> (envStateNxt == `ENV_DECAY);\n(envState[sel] == `ENV_SUSTAIN && gate[sel] == 0) |-> (envStateNxt == `ENV_RELEASE);\n(envState[sel] == `ENV_SUSTAIN && gate[sel] == 1) |-> (envStateNxt == `ENV_SUSTAIN);\n(envState[sel] == `ENV_RELEASE && envCtrx == 8'h00) |-> (envStateNxt == `ENV_IDLE);\n(envState[sel] == `ENV_RELEASE && envCtrx != 8'h00 && gate[sel] == 1) |-> (envStateNxt == `ENV_SUSTAIN);\n(envState[sel] == `ENV_RELEASE && envCtrx != 8'h00 && gate[sel] == 0) |-> (envStateNxt == `ENV_RELEASE);\n(envState[sel] == `ENV_IDLE) |-> (envCtr[sel] == 0 && envCtr2[sel] == 0 && icnt[sel] == 0 && iv[sel] == 0);\n(envState[sel] == `ENV_SUSTAIN) |-> (envCtr2[sel] == 0 && icnt[sel] == 0 && iv[sel] == (sustain >> 3));\n(envState[sel] == `ENV_ATTACK && envDvnx == 20'h0) |-> (envCtr2[sel] == 0 && envCtr[sel] == envCtrx + 1);\n(envState[sel] == `ENV_DECAY && envDvnx == 20'h0) |-> (envCtr[sel] == envCtrx - 1);\n(envState[sel] == `ENV_RELEASE && envDvnx == 20'h0) |-> (envCtr[sel] == envCtrx - 1);\n(envState[sel] == `ENV_ATTACK) |-> (envStepPeriod == attack);\n(envState[sel] == `ENV_DECAY) |-> (envStepPeriod == decay);\n(envState[sel] == `ENV_RELEASE) |-> (envStepPeriod == relese);\n(envState[sel] != `ENV_ATTACK && envState[sel] != `ENV_DECAY && envState[sel] != `ENV_RELEASE) |-> (envStepPeriod == 16'h0);\n(envDvnx == 20'h0) |-> (envDvn[sel] == envStepPeriod1);\n(envDvnx != 20'h0) |-> (envDvn[sel] == envDvnx - 1);"}, {"file_name": "PSGFilter.v", "verilog_design": "`timescale 1ns / 1ps module PSGFilter(rst, clk, cnt, wr, adr, din, i, o); parameter pTaps = 16; input rst; input clk; input [7:0] cnt; input wr; input [3:0] adr; input [12:0] din; input [14:0] i; output [14:0] o; reg [14:0] o; reg [30:0] acc; reg [14:0] tap [0:pTaps-1]; integer n; reg [11:0] coeff [0:pTaps-1]; reg [pTaps-1:0] sgn; initial begin for (n = 0; n < pTaps; n = n + 1) begin coeff[n] <= 0; sgn[n] <= 0; end end always @(posedge clk) if (wr) begin coeff[adr] <= din[11:0]; sgn[adr] <= din[12]; end always @(posedge clk) if (cnt==8'd0) begin tap[0] <= i; for (n = 1; n < pTaps; n = n + 1) tap[n] <= tap[n-1]; end wire [26:0] mult = coeff[cnt[3:0]] * tap[cnt[3:0]]; always @(posedge clk) if (rst) acc <= 0; else if (cnt==8'd0) acc <= sgn[cnt[3:0]] ? 0 - mult : 0 + mult; else if (cnt < pTaps) acc <= sgn[cnt[3:0]] ? acc - mult : acc + mult; always @(posedge clk) if (rst) o <= 0; else if (cnt==8'd0) o <= acc[30:16]; endmodule", "assertions_gpt_4o": "1. (wr == 1) |-> (coeff[adr] == din[11:0]);\n2. (wr == 1) |-> (sgn[adr] == din[12]);\n3. (cnt == 8'd0) |-> (tap[0] == i);\n4. (cnt == 8'd0) |-> (tap[n] == tap[n-1]) [*pTaps-1];\n5. (rst == 1) |-> (acc == 0);\n6. (cnt == 8'd0 && rst == 0) |-> (acc == (sgn[cnt[3:0]] ? 0 - mult : 0 + mult));\n7. (cnt < pTaps && rst == 0) |-> (acc == (sgn[cnt[3:0]] ? acc - mult : acc + mult));\n8. (rst == 1) |-> (o == 0);\n9. (cnt == 8'd0 && rst == 0) |-> (o == acc[30:16]);"}, {"file_name": "PSGMasterVolumeControl.v", "verilog_design": "`timescale 1ns / 1ps module PSGMasterVolumeControl(rst_i, clk_i, i, volume, o); input rst_i; input clk_i; input [15:0] i; input [3:0] volume; output [19:0] o; reg [19:0] o; wire [19:0] v1 = volume[0] ? i : 20'd0; wire [19:0] v2 = volume[1] ? {i,1'b0} + v1: v1; wire [19:0] v3 = volume[2] ? {i,2'b0} + v2: v2; wire [19:0] vo = volume[3] ? {i,3'b0} + v3: v3; always @(posedge clk_i) if (rst_i) o <= 20'b0; else o <= vo; endmodule", "assertions_gpt_4o": "1. (rst_i) |-> (o == 20'b0);\n2. (!rst_i && volume[0] && i != 16'd0) |-> (o == i);\n3. (!rst_i && volume[1] && i != 16'd0) |-> (o == {i,1'b0} + (volume[0] ? i : 20'd0));\n4. (!rst_i && volume[2] && i != 16'd0) |-> (o == {i,2'b0} + (volume[1] ? {i,1'b0} + (volume[0] ? i : 20'd0) : (volume[0] ? i : 20'd0)));\n5. (!rst_i && volume[3] && i != 16'd0) |-> (o == {i,3'b0} + (volume[2] ? {i,2'b0} + (volume[1] ? {i,1'b0} + (volume[0] ? i : 20'd0) : (volume[0] ? i : 20'd0)) : (volume[1] ? {i,1'b0} + (volume[0] ? i : 20'd0) : (volume[0] ? i : 20'd0))));\n6. (!rst_i && !volume[0] && !volume[1] && !volume[2] && !volume[3]) |-> (o == 20'd0);"}, {"file_name": "PSGNoteGen.v", "verilog_design": "`timescale 1ns / 1ps `include \"mux4to1.v\" `include \"PSGNoteOutMux.v\" module PSGNoteGen(rst, clk, cnt, br, bg, bgn, ack, test, vt0, vt1, vt2, vt3, freq0, freq1, freq2, freq3, pw0, pw1, pw2, pw3, acc0, acc1, acc2, acc3, wave, sync, ringmod, o ); input rst; input clk; input [7:0] cnt; input ack; input [11:0] wave; input [2:0] bgn; output [3:0] br; input [3:0] bg; input [3:0] test; input [4:0] vt0, vt1, vt2, vt3; input [15:0] freq0, freq1, freq2, freq3; input [11:0] pw0, pw1, pw2, pw3; input [3:0] sync; input [3:0] ringmod; output [23:0] acc0, acc1, acc2, acc3; output [11:0] o; wire [15:0] freqx; wire [11:0] pwx; reg [23:0] pxacc; reg [23:0] acc; reg [11:0] outputT; reg [7:0] pxacc23x; reg [7:0] ibr; integer n; reg [23:0] accx [3:0]; reg [11:0] pacc [3:0]; wire [1:0] sel = cnt[1:0]; reg [11:0] outputW [3:0]; reg [22:0] lfsr [3:0]; assign br[0] = ibr[0] & ~bg[0]; assign br[1] = ibr[1] & ~bg[1]; assign br[2] = ibr[2] & ~bg[2]; assign br[3] = ibr[3] & ~bg[3]; wire [4:0] vtx; always @(sel) acc <= accx[sel]; mux4to1 #(16) u1 (.e(1'b1), .s(sel), .i0(freq0), .i1(freq1), .i2(freq2), .i3(freq3), .z(freqx) ); mux4to1 #(12) u2 (.e(1'b1), .s(sel), .i0(pw0), .i1(pw1), .i2(pw2), .i3(pw3), .z(pwx) ); mux4to1 #( 5) u3 (.e(1'b1), .s(sel), .i0(vt0), .i1(vt1), .i2(vt2), .i3(vt3), .z(vtx) ); wire [22:0] lfsrx = lfsr[sel]; wire [7:0] paccx = pacc[sel]; always @(sel) pxacc <= accx[sel-1]; wire pxacc23 = pxacc[23]; always @(posedge clk) if (cnt < 8'd4) pxacc23x[sel] <= pxacc23; wire synca = ~pxacc23x[sel]&pxacc23&sync[sel]; wire accTran = pacc[sel]!=acc[23:12]; always @(posedge clk) if (rst) begin for (n = 0; n < 4; n = n + 1) pacc[n] <= 0; end else if (cnt < 8'd4) pacc[sel] <= acc[23:12]; always @(posedge clk) if (rst) begin for (n = 0; n < 8'd4; n = n + 1) outputW[n] <= 0; end else if (ack) outputW[bgn] <= wave; always @(posedge clk) if (rst) begin ibr <= 0; end else if (cnt < 8'd4) begin if (accTran & vtx[4]) ibr[sel] <= 1; else ibr[bgn] <= 0; end always @(posedge clk) if (cnt < 8'd4 && paccx[2] != acc[18]) lfsr[sel] <= {lfsrx[21:0],~(lfsrx[22]^lfsrx[17])}; always @(posedge clk) if (rst) begin for (n = 0; n < 4; n = n + 1) accx[n] <= 0; end else if (cnt < 8'd4) begin if (~test[sel]) begin if (synca) accx[sel] <= 0; else accx[sel] <= acc + freqx; end else accx[sel] <= 0; end wire msb = ringmod[sel] ? acc[23]^pxacc23 : acc[23]; always @(acc or msb) outputT <= msb ? ~acc[22:11] : acc[22:11]; wire [11:0] outputP = {12{acc[23:12] < pwx}}; wire [11:0] outputS = acc[23:12]; wire [11:0] outputN = lfsrx[11:0]; wire [11:0] out; PSGNoteOutMux #(12) u4 (.s(vtx), .a(outputT), .b(outputS), .c(outputP), .d(outputN), .e(outputW[sel]), .o(out) ); assign o = out; assign acc0 = accx[0]; assign acc1 = accx[1]; assign acc2 = accx[2]; assign acc3 = accx[3]; endmodule", "assertions_gpt_4o": "(cnt < 8'd4) |-> (pxacc23x[sel] == pxacc[23]);\n(cnt < 8'd4) |-> (pacc[sel] == acc[23:12]);\n(cnt < 8'd4 && paccx[2] != acc[18]) |-> (lfsr[sel] == {lfsrx[21:0], ~(lfsrx[22] ^ lfsrx[17])});\n(cnt < 8'd4 && accTran && vtx[4]) |-> (ibr[sel] == 1);\n(cnt < 8'd4 && ~accTran && vtx[4]) |-> (ibr[sel] == 0);\n(cnt < 8'd4 && ~test[sel] && synca) |-> (accx[sel] == 0);\n(cnt < 8'd4 && ~test[sel] && ~synca) |-> (accx[sel] == acc + freqx);\n(cnt < 8'd4 && test[sel]) |-> (accx[sel] == 0);\n(msb) |-> (outputT == ~acc[22:11]);\n(~msb) |-> (outputT == acc[22:11]);\n(outputP == {12{acc[23:12] < pwx}});\n(outputS == acc[23:12]);\n(outputN == lfsrx[11:0]);\n(vtx == 0) |-> (out == outputT);\n(vtx == 1) |-> (out == outputS);\n(vtx == 2) |-> (out == outputP);\n(vtx == 3) |-> (out == outputN);\n(vtx == 4) |-> (out == outputW[sel]);\n"}, {"file_name": "PSGNoteOutMux.v", "verilog_design": "`timescale 1ns / 1ps module PSGNoteOutMux(s, a, b, c, d, e, o); parameter WID = 12; input [4:0] s; input [WID-1:0] a,b,c,d,e; output [WID-1:0] o; wire [WID-1:0] o1,o2,o3,o4,o5; assign o1 = s[4] ? e : {WID{1'b1}}; assign o2 = s[3] ? d : {WID{1'b1}}; assign o3 = s[2] ? c : {WID{1'b1}}; assign o4 = s[1] ? b : {WID{1'b1}}; assign o5 = s[0] ? a : {WID{1'b1}}; assign o = o1 & o2 & o3 & o4 & o5; endmodule", "assertions_gpt_4o": "1. (s[4] == 1) |-> (o1 == e);\n2. (s[4] == 0) |-> (o1 == {WID{1'b1}});\n3. (s[3] == 1) |-> (o2 == d);\n4. (s[3] == 0) |-> (o2 == {WID{1'b1}});\n5. (s[2] == 1) |-> (o3 == c);\n6. (s[2] == 0) |-> (o3 == {WID{1'b1}});\n7. (s[1] == 1) |-> (o4 == b);\n8. (s[1] == 0) |-> (o4 == {WID{1'b1}});\n9. (s[0] == 1) |-> (o5 == a);\n10. (s[0] == 0) |-> (o5 == {WID{1'b1}});\n11. (o == (o1 & o2 & o3 & o4 & o5));"}, {"file_name": "PSGOutputSummer.v", "verilog_design": "`timescale 1ns / 1ps module PSGOutputSummer(clk_i, cnt, ufi, fi, o); input clk_i; input [7:0] cnt; input [21:0] ufi; input [21:0] fi; output [21:0] o; reg [21:0] o; always @(posedge clk_i) if (cnt==8'd0) o <= ufi + fi; endmodule", "assertions_gpt_4o": "(cnt == 8'd0) |-> (o == ufi + fi);"}, {"file_name": "PSGShaper.v", "verilog_design": "`timescale 1ns / 1ps module PSGShaper(clk_i, ce, tgi, env, o); input clk_i; input ce; input [11:0] tgi; input [7:0] env; output [19:0] o; reg [19:0] o; always @(posedge clk_i) if (ce) o <= tgi * env; endmodule", "assertions_gpt_4o": "1. (ce == 1) |-> (o == tgi * env);\n2. (ce == 0) |-> (o == $past(o));\n3. (tgi == 0) |-> (o == 0);\n4. (env == 0) |-> (o == 0);\n5. (tgi != 0 & env != 0 & ce == 1) |-> (o == tgi * env);"}, {"file_name": "bit_reversal.v", "verilog_design": "`define size ((DATA_SIZE/4) * (2 ** (type - 1))) module bit_reversal #( parameter DATA_SIZE = 32 ) ( output [DATA_SIZE - 1 : 0] data_out, input [DATA_SIZE - 1 : 0] data_in, input [1 : 0] rev_type ); localparam NO_REVERSE = 2'b00; localparam BYTE = 2'b01; localparam HALF_WORD = 2'b10; localparam WORD = 2'b11; localparam TYPES = 4; wire [DATA_SIZE - 1 : 0] data_reversed[0 : 3]; assign data_reversed[NO_REVERSE] = data_in; generate genvar i, type; for(type = 1 ; type < TYPES; type = type + 1) for(i = 0; i < DATA_SIZE; i = i + 1) begin if(i < `size) assign data_reversed[type][i] = data_in[`size*((i/`size) + 1) - 1 - i]; else assign data_reversed[type][i] = data_in[`size*((i/`size) + 1) - 1 - (i%(`size*(i/`size)))]; end endgenerate assign data_out = data_reversed[rev_type]; endmodule", "assertions_gpt_4o": "(data_in == data_out) |-> (rev_type == 2'b00);\n(data_out == {data_in[7:0], data_in[15:8], data_in[23:16], data_in[31:24]}) |-> (rev_type == 2'b01);\n(data_out == {data_in[15:0], data_in[31:16]}) |-> (rev_type == 2'b10);\n(data_out == data_in) |-> (rev_type == 2'b11);\n(data_out == data_in) |-> (rev_type == 2'b00);\n(data_out == {data_in[7:0], data_in[15:8], data_in[23:16], data_in[31:24]}) |-> (rev_type == 2'b01);\n(data_out == {data_in[15:0], data_in[31:16]}) |-> (rev_type == 2'b10);\n(data_out == {data_in[31:24], data_in[23:16], data_in[15:8], data_in[7:0]}) |-> (rev_type == 2'b11);"}, {"file_name": "crc_comb.v", "verilog_design": "module crc_comb #( parameter CRC_SIZE = 8, parameter MASK = 8'hff )( output [CRC_SIZE - 1 : 0] crc_out, input data_in, input [CRC_SIZE - 1 : 0] crc_in, input [CRC_SIZE - 1 : 0] crc_poly, input [CRC_SIZE - 2 : 0] crc_poly_size ); wire [CRC_SIZE - 2 : 0] MASK_REVERSED; wire [CRC_SIZE - 1 : 0] feedback; wire [CRC_SIZE - 2 : 0] crc_in_masked; wire [CRC_SIZE - 2 : 0] crc_poly_size_reversed; assign crc_poly_size_reversed[0] = crc_poly_size[CRC_SIZE - 2 - 0]; assign MASK_REVERSED[0] = MASK[CRC_SIZE - 2 - 0]; assign crc_poly_size_reversed[1] = crc_poly_size[CRC_SIZE - 2 - 1]; assign MASK_REVERSED[1] = MASK[CRC_SIZE - 2 - 1]; assign crc_poly_size_reversed[2] = crc_poly_size[CRC_SIZE - 2 - 2]; assign MASK_REVERSED[2] = MASK[CRC_SIZE - 2 - 2]; assign crc_poly_size_reversed[3] = crc_poly_size[CRC_SIZE - 2 - 3]; assign MASK_REVERSED[3] = MASK[CRC_SIZE - 2 - 3]; assign crc_poly_size_reversed[4] = crc_poly_size[CRC_SIZE - 2 - 4]; assign MASK_REVERSED[4] = MASK[CRC_SIZE - 2 - 4]; assign crc_poly_size_reversed[5] = crc_poly_size[CRC_SIZE - 2 - 5]; assign MASK_REVERSED[5] = MASK[CRC_SIZE - 2 - 5]; assign crc_poly_size_reversed[6] = crc_poly_size[CRC_SIZE - 2 - 6]; assign MASK_REVERSED[6] = MASK[CRC_SIZE - 2 - 6]; assign feedback = crc_poly & {CRC_SIZE{crc_in[CRC_SIZE - 1] ^ data_in}}; assign crc_in_masked = crc_in[CRC_SIZE - 2 : 0] & (~(crc_poly_size_reversed[CRC_SIZE - 2 : 0] & MASK_REVERSED)); assign crc_out = {crc_in_masked ^ feedback[CRC_SIZE - 1 : 1], feedback[0]}; endmodule", "assertions_gpt_4o": "1. (crc_in[CRC_SIZE - 1] ^ data_in) |-> (feedback == (crc_poly & {CRC_SIZE{crc_in[CRC_SIZE - 1] ^ data_in}}));\n2. (crc_in[CRC_SIZE - 2 : 0] & (~(crc_poly_size_reversed[CRC_SIZE - 2 : 0] & MASK_REVERSED))) |-> (crc_in_masked == crc_in[CRC_SIZE - 2 : 0] & (~(crc_poly_size_reversed[CRC_SIZE - 2 : 0] & MASK_REVERSED)));\n3. (crc_in_masked ^ feedback[CRC_SIZE - 1 : 1]) |-> (crc_out[CRC_SIZE - 1 : 1] == crc_in_masked ^ feedback[CRC_SIZE - 1 : 1]);\n4. (feedback[0]) |-> (crc_out[0] == feedback[0]);\n5. (crc_poly_size[CRC_SIZE - 2 - 0]) |-> (crc_poly_size_reversed[0] == crc_poly_size[CRC_SIZE - 2 - 0]);\n6. (MASK[CRC_SIZE - 2 - 0]) |-> (MASK_REVERSED[0] == MASK[CRC_SIZE - 2 - 0]);\n7. (crc_poly_size[CRC_SIZE - 2 - 1]) |-> (crc_poly_size_reversed[1] == crc_poly_size[CRC_SIZE - 2 - 1]);\n8. (MASK[CRC_SIZE - 2 - 1]) |-> (MASK_REVERSED[1] == MASK[CRC_SIZE - 2 - 1]);\n9. (crc_poly_size[CRC_SIZE - 2 - 2]) |-> (crc_poly_size_reversed[2] == crc_poly_size[CRC_SIZE - 2 - 2]);\n10. (MASK[CRC_SIZE - 2 - 2]) |-> (MASK_REVERSED[2] == MASK[CRC_SIZE - 2 - 2]);\n11. (crc_poly_size[CRC_SIZE - 2 - 3]) |-> (crc_poly_size_reversed[3] == crc_poly_size[CRC_SIZE - 2 - 3]);\n12. (MASK[CRC_SIZE - 2 - 3]) |-> (MASK_REVERSED[3] == MASK[CRC_SIZE - 2 - 3]);\n13. (crc_poly_size[CRC_SIZE - 2 - 4]) |-> (crc_poly_size_reversed[4] == crc_poly_size[CRC_SIZE - 2 - 4]);\n14. (MASK[CRC_SIZE - 2 - 4]) |-> (MASK_REVERSED[4] == MASK[CRC_SIZE - 2 - 4]);\n15. (crc_poly_size[CRC_SIZE - 2 - 5]) |-> (crc_poly_size_reversed[5] == crc_poly_size[CRC_SIZE - 2 - 5]);\n16. (MASK[CRC_SIZE - 2 - 5]) |-> (MASK_REVERSED[5] == MASK[CRC_SIZE - 2 - 5]);\n17. (crc_poly_size[CRC_SIZE - 2 - 6]) |-> (crc_poly_size_reversed[6] == crc_poly_size[CRC_SIZE - 2 - 6]);\n18. (MASK[CRC_SIZE - 2 - 6]) |-> (MASK_REVERSED[6] == MASK[CRC_SIZE - 2 - 6]);"}, {"file_name": "crc_control_unit.v", "verilog_design": "module crc_control_unit ( output reg [1:0] byte_sel, output bypass_byte0, output buffer_full, output read_wait, output bypass_size, output set_crc_init_sel, output clear_crc_init_sel, output crc_out_en, output byte_en, output reset_pending, input [1:0] size_in, input write, input reset_chain, input clk, input rst_n ); localparam EMPTY = 2'b00; localparam WRITE_1 = 2'b01; localparam WRITE_2 = 2'b10; localparam BYPASS = 2'b11; localparam IDLE = 3'b100; localparam BYTE_0 = 3'b000; localparam BYTE_1 = 3'b001; localparam BYTE_2 = 3'b010; localparam BYTE_3 = 3'b011; localparam NO_RESET = 3'b000; localparam RESET = 3'b001; localparam WAIT = 3'b010; localparam WRITE = 3'b011; localparam RESET_2 = 3'b100; localparam BYTE = 2'b00; localparam HALF_WORD = 2'b01; localparam WORD = 2'b10; reg [1:0] state_full; reg [2:0] state_byte; reg [2:0] state_reset; reg [1:0] next_state_full; reg [2:0] next_state_byte; reg [2:0] next_state_reset; wire last_byte; wire has_data; always @(posedge clk) begin if(!rst_n) state_full <= EMPTY; else state_full <= next_state_full; end assign last_byte = (size_in == BYTE && state_byte == BYTE_0) || (size_in == HALF_WORD && state_byte == BYTE_1) || (size_in == WORD && state_byte == BYTE_3) ; always @(*) begin next_state_full = state_full; case(state_full) EMPTY : next_state_full = (write) ? WRITE_1 : EMPTY; WRITE_1: begin if(last_byte) begin if(!write) next_state_full = EMPTY; end else begin if(write) next_state_full = WRITE_2; end end WRITE_2: begin if(last_byte) next_state_full = (write) ? BYPASS : WRITE_1; end BYPASS : begin if(last_byte && !write) next_state_full = WRITE_1; end endcase end assign buffer_full = (state_full == WRITE_2 && !last_byte) || (state_full == BYPASS && !last_byte); assign read_wait = (state_byte != IDLE); assign bypass_byte0 = (state_full != BYPASS); assign has_data = (state_full == WRITE_2) || (state_full == BYPASS ) ; always @(posedge clk) begin if(!rst_n) state_byte <= IDLE; else state_byte <= next_state_byte; end always @(*) begin next_state_byte = state_byte; case(state_byte) IDLE: next_state_byte = (write) ? BYTE_0 : IDLE; BYTE_0: begin if(size_in == BYTE) begin if(!write && !has_data) next_state_byte = IDLE; end else begin next_state_byte = BYTE_1; end end BYTE_1: begin if(size_in == HALF_WORD) begin if(has_data || (write && !buffer_full)) next_state_byte = BYTE_0; else next_state_byte = IDLE; end else begin next_state_byte = BYTE_2; end end BYTE_2: begin next_state_byte = BYTE_3; end BYTE_3: begin if(has_data || (write && !buffer_full)) next_state_byte = BYTE_0; else next_state_byte = IDLE; end endcase end always @(*) begin byte_sel = 2'b00; case(state_byte) BYTE_0: byte_sel = BYTE_0; BYTE_1: byte_sel = BYTE_1; BYTE_2: byte_sel = BYTE_2; BYTE_3: byte_sel = BYTE_3; endcase end assign bypass_size = !( (state_full != BYPASS && state_byte != BYTE_0) || (state_full == BYPASS) ); assign crc_out_en = (state_byte != IDLE); assign byte_en = (state_byte == BYTE_0 && (size_in == HALF_WORD || size_in == WORD) && state_full != BYPASS) || (last_byte && has_data); always @(posedge clk) begin if(!rst_n) state_reset <= NO_RESET; else state_reset <= next_state_reset; end always @(*) begin next_state_reset = state_reset; case(state_reset) NO_RESET: begin if((reset_chain && !has_data && state_byte != IDLE && !last_byte) || (reset_chain && has_data && last_byte)) next_state_reset = RESET; if(reset_chain && has_data && !last_byte) next_state_reset = WAIT; end RESET: begin if(last_byte) next_state_reset = NO_RESET; else next_state_reset = (write) ? WRITE : RESET; end WAIT: begin if(last_byte) next_state_reset = (write) ? WRITE : RESET; else next_state_reset = WAIT; end WRITE: begin if(reset_chain) next_state_reset = (last_byte) ? RESET : RESET_2; else next_state_reset = (last_byte) ? NO_RESET : WRITE; end RESET_2: begin if(last_byte) next_state_reset = (write) ? WRITE : RESET; else next_state_reset = RESET_2; end endcase end assign set_crc_init_sel = (state_byte == BYTE_0); assign clear_crc_init_sel = (state_reset == NO_RESET && last_byte && reset_chain) || (state_byte == IDLE && reset_chain ) || (state_reset == RESET && last_byte ) || (state_reset == WRITE && last_byte ) || (state_reset == RESET_2 && last_byte ) ; assign reset_pending = (state_reset != NO_RESET); endmodule", "assertions_gpt_4o": "(size_in == BYTE && state_byte == BYTE_0) |-> (last_byte == 1);\n(size_in == HALF_WORD && state_byte == BYTE_1) |-> (last_byte == 1);\n(size_in == WORD && state_byte == BYTE_3) |-> (last_byte == 1);\n(state_full == EMPTY && write == 1) |-> (next_state_full == WRITE_1);\n(state_full == WRITE_1 && last_byte == 1 && write == 0) |-> (next_state_full == EMPTY);\n(state_full == WRITE_1 && last_byte == 0 && write == 1) |-> (next_state_full == WRITE_2);\n(state_full == WRITE_2 && last_byte == 1 && write == 1) |-> (next_state_full == BYPASS);\n(state_full == WRITE_2 && last_byte == 1 && write == 0) |-> (next_state_full == WRITE_1);\n(state_full == BYPASS && last_byte == 1 && write == 0) |-> (next_state_full == WRITE_1);\n(state_full == WRITE_2 && last_byte == 0) |-> (buffer_full == 1);\n(state_full == BYPASS && last_byte == 0) |-> (buffer_full == 1);\n(state_byte != IDLE) |-> (read_wait == 1);\n(state_full != BYPASS) |-> (bypass_byte0 == 1);\n(state_full == WRITE_2 || state_full == BYPASS) |-> (has_data == 1);\n(state_byte == IDLE && write == 1) |-> (next_state_byte == BYTE_0);\n(state_byte == BYTE_0 && size_in == BYTE && write == 0 && has_data == 0) |-> (next_state_byte == IDLE);\n(state_byte == BYTE_0 && size_in != BYTE) |-> (next_state_byte == BYTE_1);\n(state_byte == BYTE_1 && size_in == HALF_WORD && (has_data == 1 || (write == 1 && buffer_full == 0))) |-> (next_state_byte == BYTE_0);\n(state_byte == BYTE_1 && size_in == HALF_WORD && has_data == 0 && (write == 0 || buffer_full == 1)) |-> (next_state_byte == IDLE);\n(state_byte == BYTE_1 && size_in != HALF_WORD) |-> (next_state_byte == BYTE_2);\n(state_byte == BYTE_2) |-> (next_state_byte == BYTE_3);\n(state_byte == BYTE_3 && (has_data == 1 || (write == 1 && buffer_full == 0))) |-> (next_state_byte == BYTE_0);\n(state_byte == BYTE_3 && has_data == 0 && (write == 0 || buffer_full == 1)) |-> (next_state_byte == IDLE);\n(state_byte == BYTE_0) |-> (byte_sel == BYTE_0);\n(state_byte == BYTE_1) |-> (byte_sel == BYTE_1);\n(state_byte == BYTE_2) |-> (byte_sel == BYTE_2);\n(state_byte == BYTE_3) |-> (byte_sel == BYTE_3);\n((state_full != BYPASS && state_byte != BYTE_0) || state_full == BYPASS) |-> (bypass_size == 0);\n(state_byte != IDLE) |-> (crc_out_en == 1);\n(state_byte == BYTE_0 && (size_in == HALF_WORD || size_in == WORD) && state_full != BYPASS) |-> (byte_en == 1);\n(last_byte == 1 && has_data == 1) |-> (byte_en == 1);\n(state_reset == NO_RESET && reset_chain == 1 && has_data == 0 && state_byte != IDLE && last_byte == 0) |-> (next_state_reset == RESET);\n(state_reset == NO_RESET && reset_chain == 1 && has_data == 1 && last_byte == 1) |-> (next_state_reset == RESET);\n(state_reset == NO_RESET && reset_chain == 1 && has_data == 1 && last_byte == 0) |-> (next_state_reset == WAIT);\n(state_reset == RESET && last_byte == 1) |-> (next_state_reset == NO_RESET);\n(state_reset == RESET && last_byte == 0 && write == 1) |-> (next_state_reset == WRITE);\n(state_reset == WAIT && last_byte == 1 && write == 1) |-> (next_state_reset == WRITE);\n(state_reset == WAIT && last_byte == 1 && write == 0) |-> (next_state_reset == RESET);\n(state_reset == WAIT && last_byte == 0) |-> (next_state_reset == WAIT);\n(state_reset == WRITE && reset_chain == 1 && last_byte == 1) |-> (next_state_reset == RESET);\n(state_reset == WRITE && reset_chain"}, {"file_name": "host_interface.v", "verilog_design": "module host_interface ( output [31:0] HRDATA, output HREADYOUT, output HRESP, output [31:0] bus_wr, output [ 1:0] crc_poly_size, output [ 1:0] bus_size, output [ 1:0] rev_in_type, output rev_out_type, output crc_init_en, output crc_idr_en, output crc_poly_en, output buffer_write_en, output reset_chain, input [31:0] HWDATA, input [31:0] HADDR, input [ 2:0] HSIZE, input [ 1:0] HTRANS, input HWRITE, input HSElx, input HREADY, input HRESETn, input HCLK, input [31:0] crc_poly_out, input [31:0] crc_out, input [31:0] crc_init_out, input [ 7:0] crc_idr_out, input buffer_full, input reset_pending, input read_wait ); localparam RESET_CRC_CR = 6'h00; localparam CRC_DR = 3'h0; localparam CRC_IDR = 3'h1; localparam CRC_CR = 3'h2; localparam CRC_INIT = 3'h4; localparam CRC_POL = 3'h5; localparam IDLE = 2'b00; localparam BUSY = 2'b01; localparam NON_SEQ = 2'b10; localparam SEQ = 2'b11; localparam OK = 1'b0; localparam ERROR = 1'b1; reg [2:0] haddr_pp; reg [2:0] hsize_pp; reg [1:0] htrans_pp; reg hwrite_pp; reg hselx_pp; reg [4:0] crc_cr_ff; wire [31:0] crc_cr_rd; wire crc_dr_sel; wire crc_init_sel; wire crc_idr_sel; wire crc_poly_sel; wire crc_cr_sel; wire ahb_enable; wire write_en; wire read_en; wire crc_cr_en; wire sample_bus; wire buffer_read_en; always @(posedge HCLK) begin if(!HRESETn) begin hselx_pp <= 1'b0; end else if(sample_bus) begin haddr_pp <= HADDR[4:2]; hsize_pp <= HSIZE; htrans_pp <= HTRANS; hwrite_pp <= HWRITE; hselx_pp <= HSElx; end end assign ahb_enable = (htrans_pp == NON_SEQ); assign write_en = hselx_pp && hwrite_pp && ahb_enable; assign read_en = hselx_pp && !hwrite_pp && ahb_enable; assign crc_dr_sel = (haddr_pp == CRC_DR ); assign crc_init_sel = (haddr_pp == CRC_INIT); assign crc_idr_sel = (haddr_pp == CRC_IDR ); assign crc_poly_sel = (haddr_pp == CRC_POL ); assign crc_cr_sel = (haddr_pp == CRC_CR ); assign buffer_write_en = crc_dr_sel && write_en; assign crc_init_en = crc_init_sel && write_en; assign crc_idr_en = crc_idr_sel && write_en; assign crc_poly_en = crc_poly_sel && write_en; assign crc_cr_en = crc_cr_sel && write_en; assign buffer_read_en = crc_dr_sel && read_en; assign bus_size = hsize_pp; assign bus_wr = HWDATA; assign HREADYOUT = !((buffer_write_en && buffer_full ) || (buffer_read_en && read_wait ) || (crc_init_en && reset_pending ) ); assign sample_bus = HREADYOUT && HREADY; assign HRESP = OK; assign crc_cr_rd = {24'h0, crc_cr_ff[4:0], 3'h0}; assign HRDATA = ({32{crc_dr_sel }} & crc_out ) | ({32{crc_init_sel}} & crc_init_out ) | ({32{crc_idr_sel }} & {24'h0, crc_idr_out}) | ({32{crc_poly_sel}} & crc_poly_out ) | ({32{crc_cr_sel }} & crc_cr_rd ) ; always @(posedge HCLK) begin if(!HRESETn) crc_cr_ff <= RESET_CRC_CR; else if(crc_cr_en) crc_cr_ff <= {HWDATA[7], HWDATA[6:5], HWDATA[4:3]}; end assign reset_chain = (crc_cr_en && HWDATA[0]); assign crc_poly_size = crc_cr_ff[1:0]; assign rev_in_type = crc_cr_ff[3:2]; assign rev_out_type = crc_cr_ff[4]; endmodule", "assertions_gpt_4o": "1. (!HRESETn) |-> (hselx_pp == 1'b0);\n2. (sample_bus) |-> (haddr_pp == HADDR[4:2]);\n3. (sample_bus) |-> (hsize_pp == HSIZE);\n4. (sample_bus) |-> (htrans_pp == HTRANS);\n5. (sample_bus) |-> (hwrite_pp == HWRITE);\n6. (sample_bus) |-> (hselx_pp == HSElx);\n7. (htrans_pp == NON_SEQ) |-> (ahb_enable == 1'b1);\n8. (hselx_pp && hwrite_pp && ahb_enable) |-> (write_en == 1'b1);\n9. (hselx_pp && !hwrite_pp && ahb_enable) |-> (read_en == 1'b1);\n10. (haddr_pp == CRC_DR) |-> (crc_dr_sel == 1'b1);\n11. (haddr_pp == CRC_INIT) |-> (crc_init_sel == 1'b1);\n12. (haddr_pp == CRC_IDR) |-> (crc_idr_sel == 1'b1);\n13. (haddr_pp == CRC_POL) |-> (crc_poly_sel == 1'b1);\n14. (haddr_pp == CRC_CR) |-> (crc_cr_sel == 1'b1);\n15. (crc_dr_sel && write_en) |-> (buffer_write_en == 1'b1);\n16. (crc_init_sel && write_en) |-> (crc_init_en == 1'b1);\n17. (crc_idr_sel && write_en) |-> (crc_idr_en == 1'b1);\n18. (crc_poly_sel && write_en) |-> (crc_poly_en == 1'b1);\n19. (crc_cr_sel && write_en) |-> (crc_cr_en == 1'b1);\n20. (crc_dr_sel && read_en) |-> (buffer_read_en == 1'b1);\n21. (buffer_write_en && buffer_full) |-> (HREADYOUT == 1'b0);\n22. (buffer_read_en && read_wait) |-> (HREADYOUT == 1'b0);\n23. (crc_init_en && reset_pending) |-> (HREADYOUT == 1'b0);\n24. (HREADYOUT && HREADY) |-> (sample_bus == 1'b1);\n25. (crc_cr_en && HWDATA[0]) |-> (reset_chain == 1'b1);\n26. (!HRESETn) |-> (crc_cr_ff == RESET_CRC_CR);\n27. (crc_cr_en) |-> (crc_cr_ff == {HWDATA[7], HWDATA[6:5], HWDATA[4:3]});\n28. (crc_dr_sel) |-> (HRDATA == crc_out);\n29. (crc_init_sel) |-> (HRDATA == crc_init_out);\n30. (crc_idr_sel) |-> (HRDATA == {24'h0, crc_idr_out});\n31. (crc_poly_sel) |-> (HRDATA == crc_poly_out);\n32. (crc_cr_sel) |-> (HRDATA == crc_cr_rd);"}, {"file_name": "fpu_exceptions.v", "verilog_design": "`timescale 1ns / 100ps module fpu_exceptions( clk, rst, enable, rmode, opa, opb, in_except, exponent_in, mantissa_in, fpu_op, out, ex_enable, underflow, overflow, inexact, exception, invalid); input clk; input rst; input enable; input [1:0] rmode; input [63:0] opa; input [63:0] opb; input [63:0] in_except; input [11:0] exponent_in; input [1:0] mantissa_in; input [2:0] fpu_op; output [63:0] out; output ex_enable; output underflow; output overflow; output inexact; output exception; output invalid; reg [63:0] out; reg ex_enable; reg underflow; reg overflow; reg inexact; reg exception; reg invalid; reg in_et_zero; reg opa_et_zero; reg opb_et_zero; reg input_et_zero; reg add; reg subtract; reg multiply; reg divide; reg opa_QNaN; reg opb_QNaN; reg opa_SNaN; reg opb_SNaN; reg opa_pos_inf; reg opb_pos_inf; reg opa_neg_inf; reg opb_neg_inf; reg opa_inf; reg opb_inf; reg NaN_input; reg SNaN_input; reg a_NaN; reg div_by_0; reg div_0_by_0; reg div_inf_by_inf; reg div_by_inf; reg mul_0_by_inf; reg mul_inf; reg div_inf; reg add_inf; reg sub_inf; reg addsub_inf_invalid; reg addsub_inf; reg out_inf_trigger; reg out_pos_inf; reg out_neg_inf; reg round_nearest; reg round_to_zero; reg round_to_pos_inf; reg round_to_neg_inf; reg inf_round_down_trigger; reg mul_uf; reg div_uf; reg underflow_trigger; reg invalid_trigger; reg overflow_trigger; reg inexact_trigger; reg except_trigger; reg enable_trigger; reg NaN_out_trigger; reg SNaN_trigger; wire [10:0] exp_2047 = 11'b11111111111; wire [10:0] exp_2046 = 11'b11111111110; reg [62:0] NaN_output_0; reg [62:0] NaN_output; wire [51:0] mantissa_max = 52'b1111111111111111111111111111111111111111111111111111; reg [62:0] inf_round_down; reg [62:0] out_inf; reg [63:0] out_0; reg [63:0] out_1; reg [63:0] out_2; always @(posedge clk) begin if (rst) begin in_et_zero <= 0; opa_et_zero <= 0; opb_et_zero <= 0; input_et_zero <= 0; add <= 0; subtract <= 0; multiply <= 0; divide <= 0; opa_QNaN <= 0; opb_QNaN <= 0; opa_SNaN <= 0; opb_SNaN <= 0; opa_pos_inf <= 0; opb_pos_inf <= 0; opa_neg_inf <= 0; opb_neg_inf <= 0; opa_inf <= 0; opb_inf <= 0; NaN_input <= 0; SNaN_input <= 0; a_NaN <= 0; div_by_0 <= 0; div_0_by_0 <= 0; div_inf_by_inf <= 0; div_by_inf <= 0; mul_0_by_inf <= 0; mul_inf <= 0; div_inf <= 0; add_inf <= 0; sub_inf <= 0; addsub_inf_invalid <= 0; addsub_inf <= 0; out_inf_trigger <= 0; out_pos_inf <= 0; out_neg_inf <= 0; round_nearest <= 0; round_to_zero <= 0; round_to_pos_inf <= 0; round_to_neg_inf <= 0; inf_round_down_trigger <= 0; mul_uf <= 0; div_uf <= 0; underflow_trigger <= 0; invalid_trigger <= 0; overflow_trigger <= 0; inexact_trigger <= 0; except_trigger <= 0; enable_trigger <= 0; NaN_out_trigger <= 0; SNaN_trigger <= 0; NaN_output_0 <= 0; NaN_output <= 0; inf_round_down <= 0; out_inf <= 0; out_0 <= 0; out_1 <= 0; out_2 <= 0; end else if (enable) begin in_et_zero <= !(|in_except[62:0]); opa_et_zero <= !(|opa[62:0]); opb_et_zero <= !(|opb[62:0]); input_et_zero <= !(|in_except[62:0]); add <= fpu_op == 3'b000; subtract <= fpu_op == 3'b001; multiply <= fpu_op == 3'b010; divide <= fpu_op == 3'b011; opa_QNaN <= (opa[62:52] == 2047) & |opa[51:0] & opa[51]; opb_QNaN <= (opb[62:52] == 2047) & |opb[51:0] & opb[51]; opa_SNaN <= (opa[62:52] == 2047) & |opa[51:0] & !opa[51]; opb_SNaN <= (opb[62:52] == 2047) & |opb[51:0] & !opb[51]; opa_pos_inf <= !opa[63] & (opa[62:52] == 2047) & !(|opa[51:0]); opb_pos_inf <= !opb[63] & (opb[62:52] == 2047) & !(|opb[51:0]); opa_neg_inf <= opa[63] & (opa[62:52] == 2047) & !(|opa[51:0]); opb_neg_inf <= opb[63] & (opb[62:52] == 2047) & !(|opb[51:0]); opa_inf <= (opa[62:52] == 2047) & !(|opa[51:0]); opb_inf <= (opb[62:52] == 2047) & !(|opb[51:0]); NaN_input <= opa_QNaN | opb_QNaN | opa_SNaN | opb_SNaN; SNaN_input <= opa_SNaN | opb_SNaN; a_NaN <= opa_QNaN | opa_SNaN; div_by_0 <= divide & opb_et_zero & !opa_et_zero; div_0_by_0 <= divide & opb_et_zero & opa_et_zero; div_inf_by_inf <= divide & opa_inf & opb_inf; div_by_inf <= divide & !opa_inf & opb_inf; mul_0_by_inf <= multiply & ((opa_inf & opb_et_zero) | (opa_et_zero & opb_inf)); mul_inf <= multiply & (opa_inf | opb_inf) & !mul_0_by_inf; div_inf <= divide & opa_inf & !opb_inf; add_inf <= (add & (opa_inf | opb_inf)); sub_inf <= (subtract & (opa_inf | opb_inf)); addsub_inf_invalid <= (add & opa_pos_inf & opb_neg_inf) | (add & opa_neg_inf & opb_pos_inf) | (subtract & opa_pos_inf & opb_pos_inf) | (subtract & opa_neg_inf & opb_neg_inf); addsub_inf <= (add_inf | sub_inf) & !addsub_inf_invalid; out_inf_trigger <= addsub_inf | mul_inf | div_inf | div_by_0 | (exponent_in > 2046); out_pos_inf <= out_inf_trigger & !in_except[63]; out_neg_inf <= out_inf_trigger & in_except[63]; round_nearest <= (rmode == 2'b00); round_to_zero <= (rmode == 2'b01); round_to_pos_inf <= (rmode == 2'b10); round_to_neg_inf <= (rmode == 2'b11); inf_round_down_trigger <= (out_pos_inf & round_to_neg_inf) | (out_neg_inf & round_to_pos_inf) | (out_inf_trigger & round_to_zero); mul_uf <= multiply & !opa_et_zero & !opb_et_zero & in_et_zero; div_uf <= divide & !opa_et_zero & in_et_zero; underflow_trigger <= div_by_inf | mul_uf | div_uf; invalid_trigger <= SNaN_input | addsub_inf_invalid | mul_0_by_inf | div_0_by_0 | div_inf_by_inf; overflow_trigger <= out_inf_trigger & !NaN_input; inexact_trigger <= (|mantissa_in[1:0] | out_inf_trigger | underflow_trigger) & !NaN_input; except_trigger <= invalid_trigger | overflow_trigger | underflow_trigger | inexact_trigger; enable_trigger <= except_trigger | out_inf_trigger | NaN_input; NaN_out_trigger <= NaN_input | invalid_trigger; SNaN_trigger <= invalid_trigger & !SNaN_input; NaN_output_0 <= a_NaN ? { exp_2047, 1'b1, opa[50:0]} : { exp_2047, 1'b1, opb[50:0]}; NaN_output <= SNaN_trigger ? { exp_2047, 2'b01, opa[49:0]} : NaN_output_0; inf_round_down <= { exp_2046, mantissa_max }; out_inf <= inf_round_down_trigger ? inf_round_down : { exp_2047, 52'b0 }; out_0 <= underflow_trigger ? { in_except[63], 63'b0 } : in_except; out_1 <= out_inf_trigger ? { in_except[63], out_inf } : out_0; out_2 <= NaN_out_trigger ? { in_except[63], NaN_output} : out_1; end end always @(posedge clk) begin if (rst) begin ex_enable <= 0; underflow <= 0; overflow <= 0; inexact <= 0; exception <= 0; invalid <= 0; out <= 0; end else if (enable) begin ex_enable <= enable_trigger; underflow <= underflow_trigger; overflow <= overflow_trigger; inexact <= inexact_trigger; exception <= except_trigger; invalid <= invalid_trigger; out <= out_2; end end endmodule", "assertions_gpt_4o": "(enable == 1) |-> (in_et_zero == !(|in_except[62:0]));\n(enable == 1) |-> (opa_et_zero == !(|opa[62:0]));\n(enable == 1) |-> (opb_et_zero == !(|opb[62:0]));\n(enable == 1) |-> (input_et_zero == !(|in_except[62:0]));\n(enable == 1) |-> (add == (fpu_op == 3'b000));\n(enable == 1) |-> (subtract == (fpu_op == 3'b001));\n(enable == 1) |-> (multiply == (fpu_op == 3'b010));\n(enable == 1) |-> (divide == (fpu_op == 3'b011));\n(enable == 1) |-> (opa_QNaN == ((opa[62:52] == 2047) & |opa[51:0] & opa[51]));\n(enable == 1) |-> (opb_QNaN == ((opb[62:52] == 2047) & |opb[51:0] & opb[51]));\n(enable == 1) |-> (opa_SNaN == ((opa[62:52] == 2047) & |opa[51:0] & !opa[51]));\n(enable == 1) |-> (opb_SNaN == ((opb[62:52] == 2047) & |opb[51:0] & !opb[51]));\n(enable == 1) |-> (opa_pos_inf == (!opa[63] & (opa[62:52] == 2047) & !(|opa[51:0])));\n(enable == 1) |-> (opb_pos_inf == (!opb[63] & (opb[62:52] == 2047) & !(|opb[51:0])));\n(enable == 1) |-> (opa_neg_inf == (opa[63] & (opa[62:52] == 2047) & !(|opa[51:0])));\n(enable == 1) |-> (opb_neg_inf == (opb[63] & (opb[62:52] == 2047) & !(|opb[51:0])));\n(enable == 1) |-> (opa_inf == ((opa[62:52] == 2047) & !(|opa[51:0])));\n(enable == 1) |-> (opb_inf == ((opb[62:52] == 2047) & !(|opb[51:0])));\n(enable == 1) |-> (NaN_input == (opa_QNaN | opb_QNaN | opa_SNaN | opb_SNaN));\n(enable == 1) |-> (SNaN_input == (opa_SNaN | opb_SNaN));\n(enable == 1) |-> (a_NaN == (opa_QNaN | opa_SNaN));\n(enable == 1) |-> (div_by_0 == (divide & opb_et_zero & !opa_et_zero));\n(enable == 1) |-> (div_0_by_0 == (divide & opb_et_zero & opa_et_zero));\n(enable == 1) |-> (div_inf_by_inf == (divide & opa_inf & opb_inf));\n(enable == 1) |-> (div_by_inf == (divide & !opa_inf & opb_inf));\n(enable == 1) |-> (mul_0_by_inf == (multiply & ((opa_inf & opb_et_zero) | (opa_et_zero & opb_inf))));\n(enable == 1) |-> (mul_inf == (multiply & (opa_inf | opb_inf) & !mul_0_by_inf));\n(enable == 1) |-> (div_inf == (divide & opa_inf & !opb_inf));\n(enable == 1) |-> (add_inf == (add & (opa_inf | opb_inf)));\n(enable == 1) |-> (sub_inf == (subtract & (opa_inf | opb_inf)));\n(enable == 1) |-> (addsub_inf_invalid == ((add & opa_pos_inf & opb_neg_inf) | (add & opa_neg_inf & opb_pos_inf) | (subtract & opa_pos_inf & opb_pos_inf) | (subtract & opa_neg_inf & opb_neg_inf)));\n(enable == 1) |-> (addsub_inf == ((add_inf | sub_inf) & !addsub_inf_invalid));\n(enable == 1) |-> (out_inf_trigger == (addsub_inf | mul_inf | div_inf | div_by_0 | (exponent_in > 2046)));\n(enable == 1) |-> (out_pos_inf == (out_inf_trigger & !in_except[63]));\n(enable =="}, {"file_name": "fpu_sub.v", "verilog_design": "`timescale 1ns / 100ps module fpu_sub( clk, rst, enable, opa, opb, fpu_op, sign, diff_2, exponent_2); input clk; input rst; input enable; input [63:0] opa, opb; input [2:0] fpu_op; output sign; output [55:0] diff_2; output [10:0] exponent_2; reg [6:0] diff_shift; reg [6:0] diff_shift_2; reg [10:0] exponent_a; reg [10:0] exponent_b; reg [51:0] mantissa_a; reg [51:0] mantissa_b; reg expa_gt_expb; reg expa_et_expb; reg mana_gtet_manb; reg a_gtet_b; reg sign; reg [10:0] exponent_small; reg [10:0] exponent_large; reg [51:0] mantissa_small; reg [51:0] mantissa_large; reg small_is_denorm; reg large_is_denorm; reg large_norm_small_denorm; reg small_is_nonzero; reg [10:0] exponent_diff; reg [54:0] minuend; reg [54:0] subtrahend; reg [54:0] subtra_shift; wire subtra_shift_nonzero = |subtra_shift[54:0]; wire subtra_fraction_enable = small_is_nonzero & !subtra_shift_nonzero; wire [54:0] subtra_shift_2 = { 54'b0, 1'b1 }; reg [54:0] subtra_shift_3; reg [54:0] diff; reg diffshift_gt_exponent; reg diffshift_et_55; reg [54:0] diff_1; reg [10:0] exponent; reg [10:0] exponent_2; wire in_norm_out_denorm = (exponent_large > 0) & (exponent== 0); reg [55:0] diff_2; always @(posedge clk) begin if (rst) begin exponent_a <= 0; exponent_b <= 0; mantissa_a <= 0; mantissa_b <= 0; expa_gt_expb <= 0; expa_et_expb <= 0; mana_gtet_manb <= 0; a_gtet_b <= 0; sign <= 0; exponent_small <= 0; exponent_large <= 0; mantissa_small <= 0; mantissa_large <= 0; small_is_denorm <= 0; large_is_denorm <= 0; large_norm_small_denorm <= 0; small_is_nonzero <= 0; exponent_diff <= 0; minuend <= 0; subtrahend <= 0; subtra_shift <= 0; subtra_shift_3 <= 0; diff_shift_2 <= 0; diff <= 0; diffshift_gt_exponent <= 0; diffshift_et_55 <= 0; diff_1 <= 0; exponent <= 0; exponent_2 <= 0; diff_2 <= 0; end else if (enable) begin exponent_a <= opa[62:52]; exponent_b <= opb[62:52]; mantissa_a <= opa[51:0]; mantissa_b <= opb[51:0]; expa_gt_expb <= exponent_a > exponent_b; expa_et_expb <= exponent_a == exponent_b; mana_gtet_manb <= mantissa_a >= mantissa_b; a_gtet_b <= expa_gt_expb | (expa_et_expb & mana_gtet_manb); sign <= a_gtet_b ? opa[63] :!opb[63] ^ (fpu_op == 3'b000); exponent_small <= a_gtet_b ? exponent_b : exponent_a; exponent_large <= a_gtet_b ? exponent_a : exponent_b; mantissa_small <= a_gtet_b ? mantissa_b : mantissa_a; mantissa_large <= a_gtet_b ? mantissa_a : mantissa_b; small_is_denorm <= !(exponent_small > 0); large_is_denorm <= !(exponent_large > 0); large_norm_small_denorm <= (small_is_denorm == 1 && large_is_denorm == 0); small_is_nonzero <= (exponent_small > 0) | |mantissa_small[51:0]; exponent_diff <= exponent_large - exponent_small - large_norm_small_denorm; minuend <= { !large_is_denorm, mantissa_large, 2'b00 }; subtrahend <= { !small_is_denorm, mantissa_small, 2'b00 }; subtra_shift <= subtrahend >> exponent_diff; subtra_shift_3 <= subtra_fraction_enable ? subtra_shift_2 : subtra_shift; diff_shift_2 <= diff_shift; diff <= minuend - subtra_shift_3; diffshift_gt_exponent <= diff_shift_2 > exponent_large; diffshift_et_55 <= diff_shift_2 == 55; diff_1 <= diffshift_gt_exponent ? diff << exponent_large : diff << diff_shift_2; exponent <= diffshift_gt_exponent ? 0 : (exponent_large - diff_shift_2); exponent_2 <= diffshift_et_55 ? 0 : exponent; diff_2 <= in_norm_out_denorm ? { 1'b0, diff_1 >> 1} : {1'b0, diff_1}; end end always @(diff) casex(diff) 55'b1??????????????????????????????????????????????????????: diff_shift <= 0; 55'b01?????????????????????????????????????????????????????: diff_shift <= 1; 55'b001????????????????????????????????????????????????????: diff_shift <= 2; 55'b0001???????????????????????????????????????????????????: diff_shift <= 3; 55'b00001??????????????????????????????????????????????????: diff_shift <= 4; 55'b000001?????????????????????????????????????????????????: diff_shift <= 5; 55'b0000001????????????????????????????????????????????????: diff_shift <= 6; 55'b00000001???????????????????????????????????????????????: diff_shift <= 7; 55'b000000001??????????????????????????????????????????????: diff_shift <= 8; 55'b0000000001?????????????????????????????????????????????: diff_shift <= 9; 55'b00000000001????????????????????????????????????????????: diff_shift <= 10; 55'b000000000001???????????????????????????????????????????: diff_shift <= 11; 55'b0000000000001??????????????????????????????????????????: diff_shift <= 12; 55'b00000000000001?????????????????????????????????????????: diff_shift <= 13; 55'b000000000000001????????????????????????????????????????: diff_shift <= 14; 55'b0000000000000001???????????????????????????????????????: diff_shift <= 15; 55'b00000000000000001??????????????????????????????????????: diff_shift <= 16; 55'b000000000000000001?????????????????????????????????????: diff_shift <= 17; 55'b0000000000000000001????????????????????????????????????: diff_shift <= 18; 55'b00000000000000000001???????????????????????????????????: diff_shift <= 19; 55'b000000000000000000001??????????????????????????????????: diff_shift <= 20; 55'b0000000000000000000001?????????????????????????????????: diff_shift <= 21; 55'b00000000000000000000001????????????????????????????????: diff_shift <= 22; 55'b000000000000000000000001???????????????????????????????: diff_shift <= 23; 55'b0000000000000000000000001??????????????????????????????: diff_shift <= 24; 55'b00000000000000000000000001?????????????????????????????: diff_shift <= 25; 55'b000000000000000000000000001????????????????????????????: diff_shift <= 26; 55'b0000000000000000000000000001???????????????????????????: diff_shift <= 27; 55'b00000000000000000000000000001??????????????????????????: diff_shift <= 28; 55'b000000000000000000000000000001?????????????????????????: diff_shift <= 29; 55'b0000000000000000000000000000001????????????????????????: diff_shift <= 30; 55'b00000000000000000000000000000001???????????????????????: diff_shift <= 31; 55'b000000000000000000000000000000001??????????????????????: diff_shift <= 32; 55'b0000000000000000000000000000000001?????????????????????: diff_shift <= 33; 55'b00000000000000000000000000000000001????????????????????: diff_shift <= 34; 55'b000000000000000000000000000000000001???????????????????: diff_shift <= 35; 55'b0000000000000000000000000000000000001??????????????????: diff_shift <= 36; 55'b00000000000000000000000000000000000001?????????????????: diff_shift <= 37; 55'b000000000000000000000000000000000000001????????????????: diff_shift <= 38; 55'b0000000000000000000000000000000000000001???????????????: diff_shift <= 39; 55'b00000000000000000000000000000000000000001??????????????: diff_shift <= 40; 55'b000000000000000000000000000000000000000001?????????????: diff_shift <= 41; 55'b0000000000000000000000000000000000000000001????????????: diff_shift <= 42; 55'b00000000000000000000000000000000000000000001???????????: diff_shift <= 43; 55'b000000000000000000000000000000000000000000001??????????: diff_shift <= 44; 55'b0000000000000000000000000000000000000000000001?????????: diff_shift <= 45; 55'b00000000000000000000000000000000000000000000001????????: diff_shift <= 46; 55'b000000000000000000000000000000000000000000000001???????: diff_shift <= 47; 55'b0000000000000000000000000000000000000000000000001??????: diff_shift <= 48; 55'b00000000000000000000000000000000000000000000000001?????: diff_shift <= 49; 55'b000000000000000000000000000000000000000000000000001????: diff_shift <= 50; 55'b0000000000000000000000000000000000000000000000000001???: diff_shift <= 51; 55'b00000000000000000000000000000000000000000000000000001??: diff_shift <= 52; 55'b000000000000000000000000000000000000000000000000000001?: diff_shift <= 53; 55'b0000000000000000000000000000000000000000000000000000001: diff_shift <= 54; 55'b0000000000000000000000000000000000000000000000000000000: diff_shift <= 55; endcase endmodule", "assertions_gpt_4o": "(enable == 1) |-> (exponent_a == opa[62:52]);\n(enable == 1) |-> (exponent_b == opb[62:52]);\n(enable == 1) |-> (mantissa_a == opa[51:0]);\n(enable == 1) |-> (mantissa_b == opb[51:0]);\n(enable == 1) |-> (expa_gt_expb == (exponent_a > exponent_b));\n(enable == 1) |-> (expa_et_expb == (exponent_a == exponent_b));\n(enable == 1) |-> (mana_gtet_manb == (mantissa_a >= mantissa_b));\n(enable == 1) |-> (a_gtet_b == (expa_gt_expb | (expa_et_expb & mana_gtet_manb)));\n(enable == 1) |-> (sign == (a_gtet_b ? opa[63] : !opb[63] ^ (fpu_op == 3'b000)));\n(enable == 1) |-> (exponent_small == (a_gtet_b ? exponent_b : exponent_a));\n(enable == 1) |-> (exponent_large == (a_gtet_b ? exponent_a : exponent_b));\n(enable == 1) |-> (mantissa_small == (a_gtet_b ? mantissa_b : mantissa_a));\n(enable == 1) |-> (mantissa_large == (a_gtet_b ? mantissa_a : mantissa_b));\n(enable == 1) |-> (small_is_denorm == !(exponent_small > 0));\n(enable == 1) |-> (large_is_denorm == !(exponent_large > 0));\n(enable == 1) |-> (large_norm_small_denorm == (small_is_denorm == 1 && large_is_denorm == 0));\n(enable == 1) |-> (small_is_nonzero == ((exponent_small > 0) | |mantissa_small[51:0]));\n(enable == 1) |-> (exponent_diff == (exponent_large - exponent_small - large_norm_small_denorm));\n(enable == 1) |-> (minuend == { !large_is_denorm, mantissa_large, 2'b00 });\n(enable == 1) |-> (subtrahend == { !small_is_denorm, mantissa_small, 2'b00 });\n(enable == 1) |-> (subtra_shift == (subtrahend >> exponent_diff));\n(enable == 1) |-> (subtra_shift_3 == (subtra_fraction_enable ? subtra_shift_2 : subtra_shift));\n(enable == 1) |-> (diff == (minuend - subtra_shift_3));\n(enable == 1) |-> (diffshift_gt_exponent == (diff_shift_2 > exponent_large));\n(enable == 1) |-> (diffshift_et_55 == (diff_shift_2 == 55));\n(enable == 1) |-> (diff_1 == (diffshift_gt_exponent ? diff << exponent_large : diff << diff_shift_2));\n(enable == 1) |-> (exponent == (diffshift_gt_exponent ? 0 : (exponent_large - diff_shift_2)));\n(enable == 1) |-> (exponent_2 == (diffshift_et_55 ? 0 : exponent));\n(enable == 1) |-> (diff_2 == (in_norm_out_denorm ? { 1'b0, diff_1 >> 1} : {1'b0, diff_1}));\n(enable == 1) |-> (diff_shift == (diff == 55'b1?????????????????????????????????????????????????????? ? 0 :\n                                  diff == 55'b01????????????????????????????????????????????????????? ? 1 :\n                                  diff == 55'b001???????????????????????????????????????????????????? : 2 :\n                                  diff == 55'b0001??????????????????????????????????????????????????? ? 3 :\n                                  diff == 55'b00001?????????????????????????????????????????????????? ? 4 :\n                                  diff == 55'b000001????????????????????????????????????????????????? ? 5 :\n                                  diff == 55'b0000001???????????????????????????????????????????????? ? 6 :\n                                  diff == 55'b00000001??????????????????????????????????????????????? ? 7 :\n                                  diff == 55'b000000001?????????????????????????????????????????????? ? 8 :\n                                  diff == 55'b0000000001????????????????????????????????????????????? ? 9 :\n                                  diff == 55'b00000000001???????????????????????????????????????????? ? 10 :\n                                  diff == 55'b000000000001??????????????????????????????????????????? ? 11 :\n                                  diff == 55'b0000000000001?????????????????????????????????????????? ? 12 :\n                                  diff == 55'b00000000000001????????????????"}, {"file_name": "qadd.v", "verilog_design": "`timescale 1ns / 1ps module qadd( input [N-1:0] a, input [N-1:0] b, output [N-1:0] c ); parameter Q = 15; parameter N = 32; reg [N-1:0] res; assign c = res; always @(a,b) begin if(a[N-1] == 1 && b[N-1] == 1) begin res[N-1] = 1; res[N-2:0] = a[N-2:0] + b[N-2:0]; end else if(a[N-1] == 0 && b[N-1] == 0) begin res[N-1] = 0; res[N-2:0] = a[N-2:0] + b[N-2:0]; end else if(a[N-1] == 0 && b[N-1] == 1) begin if(a[N-2:0] > b[N-2:0]) res[N-1] = 1; else res[N-1] = 0; res[N-2:0] = a[N-2:0] - b[N-2:0]; end else begin if(a[N-2:0] < b[N-2:0]) res[N-1] = 1; else res[N-1] = 0; res[N-2:0] = b[N-2:0] - a[N-2:0]; end end endmodule", "assertions_gpt_4o": "(a[N-1] == 1 && b[N-1] == 1) |-> (c[N-1] == 1);\n(a[N-1] == 0 && b[N-1] == 0) |-> (c[N-1] == 0);\n(a[N-1] == 0 && b[N-1] == 1 && a[N-2:0] > b[N-2:0]) |-> (c[N-1] == 1);\n(a[N-1] == 0 && b[N-1] == 1 && a[N-2:0] <= b[N-2:0]) |-> (c[N-1] == 0);\n(a[N-1] == 1 && b[N-1] == 0 && a[N-2:0] < b[N-2:0]) |-> (c[N-1] == 1);\n(a[N-1] == 1 && b[N-1] == 0 && a[N-2:0] >= b[N-2:0]) |-> (c[N-1] == 0);\n(a[N-1] == 1 && b[N-1] == 1) |-> (c[N-2:0] == a[N-2:0] + b[N-2:0]);\n(a[N-1] == 0 && b[N-1] == 0) |-> (c[N-2:0] == a[N-2:0] + b[N-2:0]);\n(a[N-1] == 0 && b[N-1] == 1) |-> (c[N-2:0] == (a[N-2:0] > b[N-2:0] ? a[N-2:0] - b[N-2:0] : b[N-2:0] - a[N-2:0]));\n(a[N-1] == 1 && b[N-1] == 0) |-> (c[N-2:0] == (a[N-2:0] < b[N-2:0] ? b[N-2:0] - a[N-2:0] : a[N-2:0] - b[N-2:0]));"}, {"file_name": "qmult.v", "verilog_design": "`timescale 1ns / 1ps `include \"qtwosComp.v\" module qmult( input [31:0] a, input [31:0] b, output [31:0] c ); wire [63:0] a_ext; wire [63:0] b_ext; wire [63:0] r_ext; reg [63:0] a_mult; reg [63:0] b_mult; reg [63:0] result; reg [31:0] retVal; parameter Q = 15; parameter N = 32; qtwosComp #(Q,N) comp_a (.a(a[30:0]), .b(a_ext)); qtwosComp #(Q,N) comp_b (.a(b[30:0]), .b(b_ext)); qtwosComp #(Q,N) comp_r (.a(result[32-2+15:15]), .b(r_ext)); assign c = retVal; always @(a_ext,b_ext) begin if(a[32-1] == 1) a_mult <= a_ext; else a_mult <= a; if(b[32-1] == 1) b_mult <= b_ext; else b_mult <= b; end always @(a_mult,b_mult) begin result <= a_mult * b_mult; end always @(result,r_ext) begin if((a[32-1] == 1 && b[32-1] == 0) || (a[32-1] == 0 && b[32-1] == 1)) begin retVal[32-1] <= 1; retVal[32-2:0] <= r_ext[32-2:0]; end else begin retVal[32-1] <= 0; retVal[32-2:0] <= result[32-2+15:15]; end end endmodule", "assertions_gpt_4o": "(a[31] == 1) |-> (a_mult == a_ext);\n(a[31] == 0) |-> (a_mult == a);\n(b[31] == 1) |-> (b_mult == b_ext);\n(b[31] == 0) |-> (b_mult == b);\n(a_mult * b_mult == result);\n((a[31] == 1 && b[31] == 0) || (a[31] == 0 && b[31] == 1)) |-> (retVal[31] == 1);\n((a[31] == 1 && b[31] == 0) || (a[31] == 0 && b[31] == 1)) |-> (retVal[30:0] == r_ext[30:0]);\n((a[31] == 0 && b[31] == 0) || (a[31] == 1 && b[31] == 1)) |-> (retVal[31] == 0);\n((a[31] == 0 && b[31] == 0) || (a[31] == 1 && b[31] == 1)) |-> (retVal[30:0] == result[45:15]);"}, {"file_name": "qtwosComp.v", "verilog_design": "`timescale 1ns / 1ps module qtwosComp( input [30:0] a, output [63:0] b ); reg [63:0] data; reg [63:0] flip; reg [63:0] out; parameter Q = 15; parameter N = 32; assign b = out; always @(a) begin data <= a; end always @(data) begin flip <= ~a; end always @(flip) begin out <= flip + 1; end endmodule", "assertions_gpt_4o": "1. (a == 0) |-> (b == 64'h0000000000000001);\n2. (a == 31'h7FFFFFFF) |-> (b == 64'hFFFFFFFF80000001);\n3. (a == 31'h00000001) |-> (b == 64'hFFFFFFFFFFFFFFFE);\n4. (a == 31'h00000000) |-> (b == 64'h0000000000000001);\n5. (a == 31'hFFFFFFFF) |-> (b == 64'h0000000000000001);\n6. (a == 31'h80000000) |-> (b == 64'hFFFFFFFF80000000);\n7. (a == 31'h00000002) |-> (b == 64'hFFFFFFFFFFFFFFFD);\n8. (a == 31'h00000003) |-> (b == 64'hFFFFFFFFFFFFFFFC);\n9. (a == 31'h00000004) |-> (b == 64'hFFFFFFFFFFFFFFFB);\n10. (a == 31'h00000005) |-> (b == 64'hFFFFFFFFFFFFFFFA);"}, {"file_name": "dff_3_pipe.v", "verilog_design": "module dff_3_pipe #( parameter DATA_WIDTH = 8 )( input clk, input rst_n, input [DATA_WIDTH-1:0] d0, input [DATA_WIDTH-1:0] d1, input [DATA_WIDTH-1:0] d2, output reg [DATA_WIDTH-1:0] q0, output reg [DATA_WIDTH-1:0] q1, output reg [DATA_WIDTH-1:0] q2 ); always @(posedge clk or negedge rst_n) begin : register_bank_3u if(~rst_n) begin q0 <= {DATA_WIDTH{1'b0}}; q1 <= {DATA_WIDTH{1'b0}}; q2 <= {DATA_WIDTH{1'b0}}; end else begin q0 <= d0; q1 <= d1; q2 <= d2; end end endmodule", "assertions_gpt_4o": "1. (rst_n == 0) |-> (q0 == 0);\n2. (rst_n == 0) |-> (q1 == 0);\n3. (rst_n == 0) |-> (q2 == 0);\n4. (rst_n == 1) ##1 (q0 == d0);\n5. (rst_n == 1) ##1 (q1 == d1);\n6. (rst_n == 1) ##1 (q2 == d2);"}, {"file_name": "dual_port_ram.v", "verilog_design": "`timescale 1ns/10ps module dual_port_ram #( parameter DATA_WIDTH = 32, parameter ADDR_WIDTH = 14 ) ( input clk, input r_ena, input w_ena, input [DATA_WIDTH-1:0] w_data, input [ADDR_WIDTH-1:0] w_addr, input [ADDR_WIDTH-1:0] r_addr, output reg [DATA_WIDTH-1:0] r_data ); reg [DATA_WIDTH-1:0] mem[0:2**ADDR_WIDTH-1]; always @ (posedge clk) begin if (w_ena) mem[w_addr] <= w_data; if (r_ena) r_data <= mem[r_addr]; end endmodule", "assertions_gpt_4o": "1. (w_ena == 1) |-> (mem[w_addr] == w_data);\n2. (r_ena == 1) |-> (r_data == mem[r_addr]);\n3. (w_ena == 1 && r_ena == 1 && w_addr == r_addr) |-> (r_data == w_data);\n4. (w_ena == 0) |-> (mem[w_addr] == $past(mem[w_addr]));\n5. (r_ena == 0) |-> (r_data == $past(r_data));"}, {"file_name": "node.v", "verilog_design": "module node #( parameter DATA_WIDTH = 8, parameter LOW_MUX = 1, parameter HI_MUX = 1 )( input [DATA_WIDTH-1:0] data_a, input [DATA_WIDTH-1:0] data_b, output reg [DATA_WIDTH-1:0] data_hi, output reg [DATA_WIDTH-1:0] data_lo ); reg sel0; always @(*) begin : comparator if(data_a < data_b) begin sel0 = 1'b0; end else begin sel0 = 1'b1; end end always @(*) begin : mux_lo_hi case (sel0) 1'b0 : begin if(LOW_MUX == 1) data_lo = data_a; if(HI_MUX == 1) data_hi = data_b; end 1'b1 : begin if(LOW_MUX == 1) data_lo = data_b; if(HI_MUX == 1) data_hi = data_a; end default : begin data_lo = {DATA_WIDTH{1'b0}}; data_hi = {DATA_WIDTH{1'b0}}; end endcase end endmodule", "assertions_gpt_4o": "(data_a < data_b) |-> (sel0 == 1'b0);\n(data_a >= data_b) |-> (sel0 == 1'b1);\n(sel0 == 1'b0 && LOW_MUX == 1) |-> (data_lo == data_a);\n(sel0 == 1'b0 && HI_MUX == 1) |-> (data_hi == data_b);\n(sel0 == 1'b1 && LOW_MUX == 1) |-> (data_lo == data_b);\n(sel0 == 1'b1 && HI_MUX == 1) |-> (data_hi == data_a);\n(LOW_MUX == 0) |-> (data_lo == {DATA_WIDTH{1'b0}});\n(HI_MUX == 0) |-> (data_hi == {DATA_WIDTH{1'b0}});"}, {"file_name": "dpll.v", "verilog_design": "module dpll(SignalIn, SignalOut, MainClock, Positive, Negative, Lead, Lag ); input SignalIn; input MainClock; output SignalOut; output Positive, Negative; output Lead, Lag; phasecomparator inst_ph_cmp(.MainClock(MainClock), .InputSignal(SignalIn), .OutputSignal(SignalOut), .Lead(Lead), .Lag(Lag) ); variableresetrandomwalkfilter inst_zrwf(.MainClock(MainClock), .Lead(Lead), .Lag(Lag), .Positive(Positive), .Negative(Negative) ); freqdivider inst_freqdiv(.MainClock(MainClock), .FrequencyOut(SignalOut), .Positive(Positive), .Negative(Negative) ); endmodule", "assertions_gpt_4o": "(Lead == 1) |-> (Lag == 0);\n(Lag == 1) |-> (Lead == 0);\n(Positive == 1) |-> (Negative == 0);\n(Negative == 1) |-> (Positive == 0);\n(SignalIn == 1) |-> (SignalOut == 1);\n(SignalIn == 0) |-> (SignalOut == 0);\n(SignalOut == 1) |-> (Positive == 1 || Negative == 1);\n(SignalOut == 0) |-> (Positive == 0 && Negative == 0);\n(Lead == 1) |-> (SignalOut == 1);\n(Lag == 1) |-> (SignalOut == 1);"}, {"file_name": "freqdivider.v", "verilog_design": "module freqdivider(MainClock, Positive, Negative, FrequencyOut); input MainClock; input Positive, Negative; output FrequencyOut; parameter DividerLength = 7; parameter DividerMaxValue = 48; reg [DividerLength-1 : 0] DividerCounter; reg FrequencyOut; always @(posedge MainClock) begin if(DividerCounter >= (DividerMaxValue - 1)) DividerCounter <= 0; else if(Negative) DividerCounter <= DividerCounter + 2; else if(Positive) DividerCounter <= DividerCounter; else DividerCounter <= DividerCounter + 1; if(DividerCounter == 0) FrequencyOut <= ~FrequencyOut; end endmodule", "assertions_gpt_4o": "1. (DividerCounter >= (DividerMaxValue - 1)) |-> (DividerCounter == 0);\n2. (Negative) |-> (DividerCounter == $past(DividerCounter) + 2);\n3. (Positive) |-> (DividerCounter == $past(DividerCounter));\n4. (!Positive && !Negative && DividerCounter < (DividerMaxValue - 1)) |-> (DividerCounter == $past(DividerCounter) + 1);\n5. (DividerCounter == 0) |-> (FrequencyOut == ~($past(FrequencyOut)));"}, {"file_name": "variableresetrandomwalkfilter.v", "verilog_design": "`include \"randomwalkfilter.v\" module variableresetrandomwalkfilter(MainClock, Lead, Lag, Positive, Negative); input MainClock, Lead, Lag; output Positive, Negative; parameter N_FilterLength = 8; parameter N_FilterResetValue = 8; parameter N_FilterMaxValue = N_FilterResetValue; parameter N_FilterMinValue = 256 - N_FilterResetValue; parameter ResetterCounterLength = 4; parameter ResetterCounterMaxValue = 3; parameter ResetterCounterMinValue = 16 - 3; reg [N_FilterLength-1 : 0] N_FilterCounter; wire Up, Down; randomwalkfilter inst_M_Filter(.MainClock(MainClock), .Lead(Lead), .Lag(Lag), .Positive(Up), .Negative(Down)); reg [ResetterCounterLength-1 : 0] ResetterCounter; always @(posedge MainClock) begin if(Up) begin if((ResetterCounter < ResetterCounterMaxValue) || (ResetterCounter >= ResetterCounterMinValue)) ResetterCounter <= ResetterCounter + 1; end else if(Down) begin if((ResetterCounter <= ResetterCounterMaxValue) || (ResetterCounter > ResetterCounterMinValue)) ResetterCounter <= ResetterCounter - 1; end if((ResetterCounter > ResetterCounterMaxValue) && (ResetterCounter < ResetterCounterMinValue)) ResetterCounter <= 0; end reg [N_FilterLength-1 : 0] ResetterValue; always @(*) begin case(ResetterCounter) 16 - 3: ResetterValue = 256 - 7; 16 - 2: ResetterValue = 256 - 6; 16 - 1: ResetterValue = 256 - 4; 0: ResetterValue = 0; 1: ResetterValue = 4; 2: ResetterValue = 6; 3: ResetterValue = 7; default: ResetterValue = 0; endcase end always @(posedge MainClock) begin if((N_FilterCounter == N_FilterMaxValue) || (N_FilterCounter == N_FilterMinValue)) N_FilterCounter <= ResetterValue; else begin if(Lead) N_FilterCounter <= N_FilterCounter + 1; if(Lag) N_FilterCounter <= N_FilterCounter - 1; end end reg Positive, Negative; always @(posedge MainClock) begin Positive <= (N_FilterCounter == N_FilterMaxValue); Negative <= (N_FilterCounter == N_FilterMinValue); end endmodule", "assertions_gpt_4o": "1. (Up) |-> ((ResetterCounter < ResetterCounterMaxValue) || (ResetterCounter >= ResetterCounterMinValue));\n2. (Up && (ResetterCounter < ResetterCounterMaxValue || ResetterCounter >= ResetterCounterMinValue)) |-> (ResetterCounter == $past(ResetterCounter) + 1);\n3. (Down) |-> ((ResetterCounter <= ResetterCounterMaxValue) || (ResetterCounter > ResetterCounterMinValue));\n4. (Down && (ResetterCounter <= ResetterCounterMaxValue || ResetterCounter > ResetterCounterMinValue)) |-> (ResetterCounter == $past(ResetterCounter) - 1);\n5. ((ResetterCounter > ResetterCounterMaxValue) && (ResetterCounter < ResetterCounterMinValue)) |-> (ResetterCounter == 0);\n6. (ResetterCounter == 16 - 3) |-> (ResetterValue == 256 - 7);\n7. (ResetterCounter == 16 - 2) |-> (ResetterValue == 256 - 6);\n8. (ResetterCounter == 16 - 1) |-> (ResetterValue == 256 - 4);\n9. (ResetterCounter == 0) |-> (ResetterValue == 0);\n10. (ResetterCounter == 1) |-> (ResetterValue == 4);\n11. (ResetterCounter == 2) |-> (ResetterValue == 6);\n12. (ResetterCounter == 3) |-> (ResetterValue == 7);\n13. ((N_FilterCounter == N_FilterMaxValue) || (N_FilterCounter == N_FilterMinValue)) |-> (N_FilterCounter == ResetterValue);\n14. (Lead && !(N_FilterCounter == N_FilterMaxValue || N_FilterCounter == N_FilterMinValue)) |-> (N_FilterCounter == $past(N_FilterCounter) + 1);\n15. (Lag && !(N_FilterCounter == N_FilterMaxValue || N_FilterCounter == N_FilterMinValue)) |-> (N_FilterCounter == $past(N_FilterCounter) - 1);\n16. (N_FilterCounter == N_FilterMaxValue) |-> (Positive == 1);\n17. (N_FilterCounter == N_FilterMinValue) |-> (Negative == 1);\n18. (N_FilterCounter != N_FilterMaxValue) |-> (Positive == 0);\n19. (N_FilterCounter != N_FilterMinValue) |-> (Negative == 0);"}, {"file_name": "clean_rst.v", "verilog_design": "`include \"timescale.v\" module clean_rst( input clk, input rsti, output reg rsto ); reg rstt; always @(posedge clk or posedge rsti) begin rstt <= (rsti) ? 1 : 0; rsto <= (rsti) ? 1 : rstt; end endmodule", "assertions_gpt_4o": "(rsti == 1) |-> (rsto == 1);\n(rsti == 0 && rstt == 1) |-> (rsto == 1);\n(rsti == 0 && rstt == 0) |-> (rsto == 0);"}, {"file_name": "decoder_8b10b.v", "verilog_design": "`include \"timescale.v\" module decoder_8b10b ( input reset, input RBYTECLK, input [9:0] tbi, output reg K_out, output reg [7:0] ebi, output reg coding_err, output reg disparity, output disparity_err ); `ifdef MODEL_TECH wire [4:0] decoder_8b_X; wire [2:0] decoder_8b_Y; assign decoder_8b_X = ebi[4:0]; assign decoder_8b_Y = ebi[7:5]; `endif wire a,b,c,d,e,i,f,g,h,j; assign {a,b,c,d,e,i,f,g,h,j} = tbi[9:0]; wire AEQB, CEQD, P22, P13, P31; wire eeqi, c_d_e_i, cn_dn_en_in; wire P22_a_c_eeqi, P22_an_cn_eeqi; wire P22_b_c_eeqi, P22_bn_cn_eeqi, an_bn_en_in; wire a_b_e_i, P13_d_e_i, P13_in, P13_en, P31_i; wire OR12_1, OR12_2, OR12_3, OR12_4, OR12_5, OR12_6, OR12_7; wire A, B, C, D, E; wire K, F, G, H, K28p, KA, KB, KC; assign AEQB = (a & b) | (!a & !b) ; assign CEQD = (c & d) | (!c & !d) ; assign P22 = (a & b & !c & !d) | (c & d & !a & !b) | ( !AEQB & !CEQD) ; assign P13 = ( !AEQB & !c & !d) | ( !CEQD & !a & !b) ; assign P31 = ( !AEQB & c & d) | ( !CEQD & a & b) ; assign eeqi = (e == i); assign P22_a_c_eeqi = P22 & a & c & eeqi; assign P22_an_cn_eeqi = P22 & !a & !c & eeqi; assign cn_dn_en_in = (!c & !d & !e & !i); assign c_d_e_i = (c & d & e & i); assign KA = c_d_e_i | cn_dn_en_in; assign KB = P13 & (!e & i & g & h & j); assign KC = P31 & (e & !i & !g & !h & !j); assign K = KA | KB | KC; assign P22_b_c_eeqi = P22 & b & c & eeqi; assign P22_bn_cn_eeqi = P22 & !b & !c & eeqi; assign an_bn_en_in = !a & !b & !e & !i; assign a_b_e_i = a & b & e & i; assign P13_d_e_i = P13 & d & e & i; assign P13_in = P13 & !i; assign P13_en = P13 & !e; assign P31_i = P31 & i; assign OR12_1 = P22_an_cn_eeqi | P13_en; assign OR12_2 = a_b_e_i | cn_dn_en_in | P31_i; assign OR12_3 = P31_i | P22_b_c_eeqi | P13_d_e_i; assign OR12_4 = P22_a_c_eeqi | P13_en; assign OR12_5 = P13_en | cn_dn_en_in | an_bn_en_in; assign OR12_6 = P22_an_cn_eeqi | P13_in; assign OR12_7 = P13_d_e_i | P22_bn_cn_eeqi; assign A = a ^ (OR12_7 | OR12_1 | OR12_2); assign B = b ^ (OR12_2 | OR12_3 | OR12_4); assign C = c ^ (OR12_1 | OR12_3 | OR12_5); assign D = d ^ (OR12_2 | OR12_4 | OR12_7); assign E = e ^ (OR12_5 | OR12_6 | OR12_7); assign K28p = ! (c | d | e | i) ; assign F = (j & !f & (h | !g | K28p)) | (f & !j & (!h | g | !K28p)) | (K28p & g & h) | (!K28p & !g & !h) ; assign G = (j & !f & (h | !g | !K28p)) | (f & !j & (!h | g |K28p)) | (!K28p & g & h) | (K28p & !g & !h) ; assign H = ((j ^ h) & ! ((!f & g & !h & j & !K28p) | (!f & g & h & !j & K28p) | (f & !g & !h & j & !K28p) | (f & !g & h & !j & K28p))) | (!f & g & h & j) | (f & !g & !h & !j) ; always @(posedge RBYTECLK or posedge reset) if (reset) begin K_out <= 0; ebi[7:0] <= 8'b0; end else begin K_out <= K; ebi[7:0] <= { H, G, F, E, D, C, B, A } ; end wire heqj, fghjP13, fghjP31, fghj22; wire DISPARITY6p, DISPARITY6n, DISPARITY4p, DISPARITY4n; wire DISPARITY6b, DISPARITY6a2, DISPARITY6a0; assign feqg = (f & g) | (!f & !g); assign heqj = (h & j) | (!h & !j); assign fghjP13 = ( !feqg & !h & !j) | ( !heqj & !f & !g) ; assign fghjP31 = ( (!feqg) & h & j) | ( !heqj & f & g) ; assign fghj22 = (f & g & !h & !j) | (!f & !g & h & j) | ( !feqg & !heqj) ; assign DISPARITY6p = (P31 & (e | i)) | (P22 & e & i) ; assign DISPARITY6n = (P13 & ! (e & i)) | (P22 & !e & !i); assign DISPARITY4p = fghjP31 ; assign DISPARITY4n = fghjP13 ; assign DISPARITY6a = P31 | (P22 & disparity); assign DISPARITY6a2 = P31 & disparity; assign DISPARITY6a0 = P13 & ! disparity; assign DISPARITY6b = (e & i & ! DISPARITY6a0) | (DISPARITY6a & (e | i)) | DISPARITY6a2; wire derr1,derr2,derr3,derr4,derr5,derr6,derr7,derr8; assign derr1 = (disparity & DISPARITY6p) | (DISPARITY6n & !disparity); assign derr2 = (disparity & !DISPARITY6n & f & g); assign derr3 = (disparity & a & b & c); assign derr4 = (disparity & !DISPARITY6n & DISPARITY4p); assign derr5 = (!disparity & !DISPARITY6p & !f & !g); assign derr6 = (!disparity & !a & !b & !c); assign derr7 = (!disparity & !DISPARITY6p & DISPARITY4n); assign derr8 = (DISPARITY6p & DISPARITY4p) | (DISPARITY6n & DISPARITY4n); reg derr12, derr34, derr56, derr78; always @(posedge RBYTECLK or posedge reset) if (reset) begin disparity <= 1'b0; derr12 <= 1; derr34 <= 1; derr56 <= 1; derr78 <= 1; end else begin disparity <= fghjP31 | (DISPARITY6b & fghj22) ; derr12 <= derr1 | derr2; derr34 <= derr3 | derr4; derr56 <= derr5 | derr6; derr78 <= derr7 | derr8; end assign disparity_err = derr12|derr34|derr56|derr78; wire cerr1, cerr2, cerr3, cerr4, cerr5, cerr6, cerr7, cerr8, cerr9; assign cerr1 = (a & b & c & d) | (!a & !b & !c & !d); assign cerr2 = (P13 & !e & !i); assign cerr3 = (P31 & e & i); assign cerr4 = (f & g & h & j) | (!f & !g & !h & !j); assign cerr5 = (e & i & f & g & h) | (!e & !i & !f & !g & !h); assign cerr6 = (e & !i & g & h & j) | (!e & i & !g & !h & !j); assign cerr7 = (((e & i & !g & !h & !j) | (!e & !i & g & h & j)) & !((c & d & e) | (!c & !d & !e))); assign cerr8 = (!P31 & e & !i & !g & !h & !j); assign cerr9 = (!P13 & !e & i & g & h & j); reg cerr; always @(posedge RBYTECLK or posedge reset) if (reset) cerr <= 0; else cerr <= cerr1|cerr2|cerr3|cerr4|cerr5|cerr6|cerr7|cerr8|cerr9; wire zerr1, zerr2, zerr3; assign zerr1 = (DISPARITY6p & DISPARITY4p) | (DISPARITY6n & DISPARITY4n); assign zerr2 = (f & g & !h & !j & DISPARITY6p); assign zerr3 = (!f & !g & h & j & DISPARITY6n); reg zerr; always @(posedge RBYTECLK or posedge reset) if (reset) zerr <= 0; else zerr <= zerr1|zerr2|zerr3; wire xerr1, xerr2, xerr3, xerr4; reg xerr; assign xerr1 = (a & b & c & !e & !i & ((!f & !g) | fghjP13)); assign xerr2 =(!a & !b & !c & e & i & ((f & g) | fghjP31)); assign xerr3 = (c & d & e & i & !f & !g & !h); assign xerr4 = (!c & !d & !e & !i & f & g & h); always @(posedge RBYTECLK or posedge reset) if (reset) xerr <= 0; else xerr <= xerr1|xerr2|xerr3|xerr4; always @(posedge RBYTECLK or posedge reset) if (reset) coding_err <= 1'b1; else coding_err <= cerr | zerr | xerr; endmodule", "assertions_gpt_4o": "(req1 == 1 & state == 0) |-> (gnt1 == 1);\n(req1 == 0) |-> (gnt1 == 0);\n(req1 == 1 & req2 == 0) |-> (gnt1 == 1);\n(req1 == 1 & state == 0) |-> (gnt2 == 0);\n(req2 == 1 & state == 1) |-> (gnt2 == 1);\n(req2 == 0) |-> (gnt2 == 0);\n(req2 == 1 & req1 == 0) |-> (gnt2 == 1);\n(gnt2) |-> (req2);\n(gnt1) |-> (req1);\n(reset) |-> (K_out == 0);\n(reset) |-> (ebi == 8'b0);\n(!reset & K) |-> (K_out == 1);\n(!reset & !K) |-> (K_out == 0);\n(!reset & (H | G | F | E | D | C | B | A)) |-> (ebi == {H, G, F, E, D, C, B, A});\n(disparity & DISPARITY6p) |-> (derr1 == 1);\n(DISPARITY6n & !disparity) |-> (derr1 == 1);\n(disparity & !DISPARITY6n & f & g) |-> (derr2 == 1);\n(disparity & a & b & c) |-> (derr3 == 1);\n(disparity & !DISPARITY6n & DISPARITY4p) |-> (derr4 == 1);\n(!disparity & !DISPARITY6p & !f & !g) |-> (derr5 == 1);\n(!disparity & !a & !b & !c) |-> (derr6 == 1);\n(!disparity & !DISPARITY6p & DISPARITY4n) |-> (derr7 == 1);\n(DISPARITY6p & DISPARITY4p) |-> (derr8 == 1);\n(DISPARITY6n & DISPARITY4n) |-> (derr8 == 1);\n(disparity & fghjP31) |-> (disparity == 1);\n(DISPARITY6b & fghj22) |-> (disparity == 1);\n(a & b & c & d) |-> (cerr1 == 1);\n(!a & !b & !c & !d) |-> (cerr1 == 1);\n(P13 & !e & !i) |-> (cerr2 == 1);\n(P31 & e & i) |-> (cerr3 == 1);\n(f & g & h & j) |-> (cerr4 == 1);\n(!f & !g & !h & !j) |-> (cerr4 == 1);\n(e & i & f & g & h) |-> (cerr5 == 1);\n(!e & !i & !f & !g & !h) |-> (cerr5 == 1);\n(e & !i & g & h & j) |-> (cerr6 == 1);\n(!e & i & !g & !h & !j) |-> (cerr6 == 1);\n((e & i & !g & !h & !j) | (!e & !i & g & h & j)) & !((c & d & e) | (!c & !d & !e)) |-> (cerr7 == 1);\n(!P31 & e & !i & !g & !h & !j) |-> (cerr8 == 1);\n(!P13 & !e & i & g & h & j) |-> (cerr9 == 1);\n(DISPARITY6p & DISPARITY4p) |-> (zerr1 == 1);\n(DISPARITY6n & DISPARITY4n) |-> (zerr1 == 1);\n(f & g & !h & !j & DISPARITY6p) |-> (zerr2 == 1);\n(!f & !g & h & j & DISPARITY6n) |-> (zerr3 == 1);\n(a & b & c & !e & !i & ((!f & !g) | fghjP13)) |-> (xerr1 == 1);\n(!a & !b & !c & e & i & ((f & g) | fghjP31)) |-> (xerr2 == 1);\n(c & d & e & i & !f & !g & !h) |-> (xerr3 == 1);\n(!c & !d & !e"}, {"file_name": "encoder_8b10b.v", "verilog_design": "`include \"timescale.v\" module encoder_8b10b ( input reset, input SBYTECLK, input K, input [7:0] ebi, output [9:0] tbi, output reg disparity ); wire L40, L04, L13, L31, L22, AeqB, CeqD; wire PD_1S6, NDOS6, PDOS6, ND_1S6; wire ND_1S4, PD_1S4, NDOS4, PDOS4; wire illegalk, DISPARITY6; reg COMPLS6, COMPLS4; wire NAO, NBO, NCO, NDO, NEO, NIO; wire NFO, NGO, NHO, NJO; wire A,B,C,D,E,F,G,H; assign {H,G,F,E,D,C,B,A} = ebi[7:0]; reg a,b,c,d,e,i,f,g,h,j; assign tbi[9:0] = {a,b,c,d,e,i,f,g,h,j}; wire [9:0] tst; assign tst[9:0] = {NAO,NBO,NCO,NDO,NEO,NIO,NFO,NGO,NHO,NJO}; always @(posedge SBYTECLK or posedge reset) if (reset) begin disparity <= 1'b0; {a,b,c,d,e,i,f,g,h,j} <= 10'b0; end else begin disparity <= (PDOS4 | NDOS4) ^ DISPARITY6; {a,b,c,d,e,i,f,g,h,j} <= { NAO^COMPLS6, NBO^COMPLS6, NCO^COMPLS6, NDO^COMPLS6, NEO^COMPLS6, NIO^COMPLS6, NFO^COMPLS4, NGO^COMPLS4, NHO^COMPLS4, NJO^COMPLS4 }; end assign AeqB = (A & B) | (!A & !B); assign CeqD = (C & D) | (!C & !D); assign L40 = A & B & C & D ; assign L04 = !A & !B & !C & !D; assign L13 = (!AeqB & !C & !D) | (!CeqD & !A & !B); assign L31 = (!AeqB & C & D) | (!CeqD & A & B); assign L22 = (A & B & !C & !D) | (C & D & !A & !B) | ( !AeqB & !CeqD) ; assign PD_1S6 = (E & D & !C & !B & !A) | (!E & !L22 & !L31) ; assign NDOS6 = PD_1S6 ; assign PDOS6 = K | (E & !L22 & !L13) ; assign ND_1S6 = K | (E & !L22 & !L13) | (!E & !D & C & B & A) ; assign ND_1S4 = F & G ; assign NDOS4 = (!F & !G) ; assign PD_1S4 = (!F & !G) | (K & ((F & !G) | (!F & G))); assign PDOS4 = F & G & H ; assign illegalk = K & (A | B | !C | !D | !E) & (!F | !G | !H | !E | !L31); assign DISPARITY6 = disparity ^ (NDOS6 | PDOS6) ; always @(posedge SBYTECLK or posedge reset) if(reset) begin COMPLS4 <= 0; COMPLS6 <= 0; end else begin COMPLS4 <= (PD_1S4 & !DISPARITY6) | (ND_1S4 & DISPARITY6); COMPLS6 <= (PD_1S6 & !disparity) | (ND_1S6 & disparity); end reg tNAO, tNBOx, tNBOy, tNCOx, tNCOy, tNDO , tNEOx, tNEOy, tNIOw, tNIOx, tNIOy, tNIOz; always @(posedge SBYTECLK or posedge reset) if(reset) begin tNAO <= 0; tNBOx <= 0; tNBOy <= 0; tNCOx <= 0; tNCOy <= 0; tNDO <= 0; tNEOx <= 0; tNEOy <= 0; tNIOw <= 0; tNIOx <= 0; tNIOy <= 0; tNIOz <= 0; end else begin tNAO <= A ; tNBOx <= B & !L40; tNBOy <= L04 ; tNCOx <= L04 | C ; tNCOy <= E & D & !C & !B & !A ; tNDO <= D & ! (A & B & C) ; tNEOx <= E | L13; tNEOy <= !(E & D & !C & !B & !A) ; tNIOw <= (L22 & !E) | (E & L40) ; tNIOx <= E & !D & !C & !(A & B) ; tNIOy <= K & E & D & C & !B & !A ; tNIOz <= E & !D & C & !B & !A ; end assign NAO = tNAO ; assign NBO = tNBOx | tNBOy ; assign NCO = tNCOx | tNCOy ; assign NDO = tNDO ; assign NEO = tNEOx & tNEOy ; assign NIO = tNIOw | tNIOx | tNIOy | tNIOz; reg alt7, tNFO, tNGO, tNHO, tNJO; always @(posedge SBYTECLK or posedge reset) if(reset) begin alt7 <= 0; tNFO <= 0; tNGO <= 0; tNHO <= 0; tNJO <= 0; end else begin alt7 <= F & G & H & (K | (disparity ? (!E & D & L31) : (E & !D & L13))) ; tNFO <= F; tNGO <= G | (!F & !G & !H) ; tNHO <= H ; tNJO <= !H & (G ^ F) ; end assign NFO = tNFO & !alt7 ; assign NGO = tNGO ; assign NHO = tNHO ; assign NJO = tNJO | alt7 ; endmodule", "assertions_gpt_4o": "(reset) |-> (disparity == 0);\n(reset) |-> ({a,b,c,d,e,i,f,g,h,j} == 10'b0);\n(!reset && PDOS4 | NDOS4) |-> (disparity == !DISPARITY6);\n(!reset) |-> ({a,b,c,d,e,i,f,g,h,j} == {NAO^COMPLS6, NBO^COMPLS6, NCO^COMPLS6, NDO^COMPLS6, NEO^COMPLS6, NIO^COMPLS6, NFO^COMPLS4, NGO^COMPLS4, NHO^COMPLS4, NJO^COMPLS4});\n(reset) |-> (COMPLS4 == 0 && COMPLS6 == 0);\n(!reset && PD_1S4 & !DISPARITY6) |-> (COMPLS4 == 1);\n(!reset && ND_1S4 & DISPARITY6) |-> (COMPLS4 == 1);\n(!reset && PD_1S6 & !disparity) |-> (COMPLS6 == 1);\n(!reset && ND_1S6 & disparity) |-> (COMPLS6 == 1);\n(reset) |-> (tNAO == 0 && tNBOx == 0 && tNBOy == 0 && tNCOx == 0 && tNCOy == 0 && tNDO == 0 && tNEOx == 0 && tNEOy == 0 && tNIOw == 0 && tNIOx == 0 && tNIOy == 0 && tNIOz == 0);\n(!reset) |-> (tNAO == A);\n(!reset) |-> (tNBOx == B & !L40);\n(!reset) |-> (tNBOy == L04);\n(!reset) |-> (tNCOx == L04 | C);\n(!reset) |-> (tNCOy == E & D & !C & !B & !A);\n(!reset) |-> (tNDO == D & !(A & B & C));\n(!reset) |-> (tNEOx == E | L13);\n(!reset) |-> (tNEOy == !(E & D & !C & !B & !A));\n(!reset) |-> (tNIOw == (L22 & !E) | (E & L40));\n(!reset) |-> (tNIOx == E & !D & !C & !(A & B));\n(!reset) |-> (tNIOy == K & E & D & C & !B & !A);\n(!reset) |-> (tNIOz == E & !D & C & !B & !A);\n(reset) |-> (alt7 == 0 && tNFO == 0 && tNGO == 0 && tNHO == 0 && tNJO == 0);\n(!reset) |-> (alt7 == F & G & H & (K | (disparity ? (!E & D & L31) : (E & !D & L13))));\n(!reset) |-> (tNFO == F);\n(!reset) |-> (tNGO == G | (!F & !G & !H));\n(!reset) |-> (tNHO == H);\n(!reset) |-> (tNJO == !H & (G ^ F));\n(!reset) |-> (NFO == tNFO & !alt7);\n(!reset) |-> (NGO == tNGO);\n(!reset) |-> (NHO == tNHO);\n(!reset) |-> (NJO == tNJO | alt7);"}, {"file_name": "ge_1000baseX_mdio.v", "verilog_design": "`include \"ge_1000baseX_constants.v\" `include \"timescale.v\" module ge_1000baseX_mdio #( parameter PHY_ADDR = 5'b00000 ) ( input reset, input mdc, input mdio, output mdio_out, output mdio_oe, output [4:0] data_addr, input [15:0] data_rd, output [15:0] data_wr, output reg strobe_wr ); `ifdef MODEL_TECH enum logic [3:0] { `else localparam `endif S_PREAMBLE = 0, S_ST = 1, S_OP_CODE = 2, S_PHY_ADDR = 3, S_REG_ADDR = 4, S_TA = 5, S_WR_DATA = 6, S_RD_DATA = 7, S_WR_COMMIT = 8 `ifdef MODEL_TECH } present, next; `else ; reg [3:0] present, next; `endif reg [5:0] preamble_cnt; assign preamble_match = (preamble_cnt == 31); always @(posedge mdc or posedge reset) if (reset) preamble_cnt = 0; else preamble_cnt <= (mdio & ~preamble_match) ? preamble_cnt + 1 : (mdio & preamble_match) ? preamble_cnt : 0; reg pos_cnt_inc; reg [4:0] pos_cnt; always @(posedge mdc or posedge reset) if (reset) pos_cnt <= 0; else pos_cnt <= (pos_cnt_inc) ? pos_cnt + 1 : 0; assign op_code_done = (pos_cnt == 1); assign phy_addr_done = (pos_cnt == 6); assign reg_addr_done = (pos_cnt == 11); assign ta0_done = (pos_cnt == 12); assign ta1_done = (pos_cnt == 13); assign data_done = (pos_cnt == 29); reg st; reg st_latch; always @(posedge mdc or posedge reset) if (reset) st <= 0; else if (st_latch) st <= mdio; assign st_match = ~st & mdio; reg [1:0] op_code; reg op_code_shift; always @(posedge mdc or posedge reset) if (reset) op_code <= 0; else if (op_code_shift) op_code <= { op_code[0], mdio}; assign op_is_rd = (op_code == 2'b10); assign op_is_wr = (op_code == 2'b01); assign op_is_invalid = ~op_is_rd & ~op_is_wr; reg [4:0] phy_addr; reg phy_addr_shift; always @(posedge mdc or posedge reset) if (reset) phy_addr <= 0; else if (phy_addr_shift) phy_addr <= { phy_addr[3:0], mdio}; assign phy_addr_match = (phy_addr == PHY_ADDR); reg [4:0] reg_addr; reg reg_addr_shift; always @(posedge mdc or posedge reset) if (reset) reg_addr <= 0; else if (reg_addr_shift) reg_addr <= { reg_addr[3:0], mdio}; assign data_addr = reg_addr; reg [15:0] data_in; reg data_in_shift; always @(posedge mdc or posedge reset) if (reset) data_in <= 0; else if (data_in_shift) data_in <= { data_in[14:0], mdio}; assign data_wr = data_in; reg [15:0] data_out; reg data_out_load, data_out_shift; always @(posedge mdc or posedge reset) if (reset) data_out <= 0; else if (data_out_load) data_out <= data_rd; else if (data_out_shift) data_out <= { data_out[14:0], 1'b0 }; assign mdio_oe = (ta1_done & op_is_rd) | data_out_shift; assign mdio_out = (ta1_done & op_is_rd) ? 1'b1 : data_out[15]; always @(posedge mdc or posedge reset) present <= (reset) ? S_PREAMBLE : next; always @* begin next = present; pos_cnt_inc = 0; st_latch = 0; op_code_shift = 0; phy_addr_shift = 0; reg_addr_shift = 0; data_in_shift = 0; data_out_load = 0; data_out_shift = 0; strobe_wr = 0; case (present) S_PREAMBLE: begin next = (preamble_match & ~mdio) ? S_ST : S_PREAMBLE; end S_ST: begin next = (mdio) ? S_OP_CODE: S_PREAMBLE; end S_OP_CODE: begin pos_cnt_inc = 1; op_code_shift = 1; next = (op_code_done) ? S_PHY_ADDR : S_OP_CODE; end S_PHY_ADDR: begin pos_cnt_inc = 1; phy_addr_shift = 1; next = (phy_addr_done) ? S_REG_ADDR : S_PHY_ADDR; end S_REG_ADDR: begin if (phy_addr_match) begin pos_cnt_inc = 1; reg_addr_shift = 1; next = (reg_addr_done) ? S_TA : S_REG_ADDR; end else next = S_PREAMBLE; end S_TA: begin pos_cnt_inc = 1; if (ta1_done) begin data_out_load = op_is_rd; next = (op_is_rd) ? S_RD_DATA : (op_is_wr) ? S_WR_DATA : S_PREAMBLE; end end S_WR_DATA: begin pos_cnt_inc = 1; data_in_shift = 1; next = (data_done) ? S_WR_COMMIT : S_WR_DATA; end S_RD_DATA: begin pos_cnt_inc = 1; data_out_shift = 1; next = (data_done) ? S_PREAMBLE : S_RD_DATA; end S_WR_COMMIT: begin strobe_wr = 1; next = S_PREAMBLE; end endcase end endmodule", "assertions_gpt_4o": "(op_code_done) |-> (present == S_PHY_ADDR);\n(phy_addr_done) |-> (present == S_REG_ADDR);\n(reg_addr_done) |-> (present == S_TA);\n(ta1_done & op_is_rd) |-> (present == S_RD_DATA);\n(ta1_done & op_is_wr) |-> (present == S_WR_DATA);\n(data_done & op_is_rd) |-> (present == S_PREAMBLE);\n(data_done & op_is_wr) |-> (present == S_WR_COMMIT);\n(preamble_match & ~mdio) |-> (present == S_ST);\n(mdio & present == S_ST) |-> (next == S_OP_CODE);\n(~mdio & present == S_ST) |-> (next == S_PREAMBLE);\n(preamble_cnt == 31) |-> (preamble_match == 1);\n(pos_cnt == 1) |-> (op_code_done == 1);\n(pos_cnt == 6) |-> (phy_addr_done == 1);\n(pos_cnt == 11) |-> (reg_addr_done == 1);\n(pos_cnt == 12) |-> (ta0_done == 1);\n(pos_cnt == 13) |-> (ta1_done == 1);\n(pos_cnt == 29) |-> (data_done == 1);\n(ta1_done & op_is_rd) |-> (mdio_oe == 1);\n(ta1_done & op_is_rd) |-> (mdio_out == 1);\n(data_out_shift) |-> (mdio_out == data_out[15]);\n(reset) |-> (present == S_PREAMBLE);\n(reset) |-> (preamble_cnt == 0);\n(reset) |-> (pos_cnt == 0);\n(reset) |-> (op_code == 0);\n(reset) |-> (phy_addr == 0);\n(reset) |-> (reg_addr == 0);\n(reset) |-> (data_in == 0);\n(reset) |-> (data_out == 0);\n(reset) |-> (st == 0);\n(st_latch) |-> (st == mdio);\n(op_code_shift) |-> (op_code == {op_code[0], mdio});\n(phy_addr_shift) |-> (phy_addr == {phy_addr[3:0], mdio});\n(reg_addr_shift) |-> (reg_addr == {reg_addr[3:0], mdio});\n(data_in_shift) |-> (data_in == {data_in[14:0], mdio});\n(data_out_load) |-> (data_out == data_rd);\n(data_out_shift) |-> (data_out == {data_out[14:0], 1'b0});\n(phy_addr == PHY_ADDR) |-> (phy_addr_match == 1);\n(op_code == 2'b10) |-> (op_is_rd == 1);\n(op_code == 2'b01) |-> (op_is_wr == 1);\n(~op_is_rd & ~op_is_wr) |-> (op_is_invalid == 1);\n(strobe_wr) |-> (next == S_PREAMBLE);"}, {"file_name": "ge_1000baseX_rx.v", "verilog_design": "`include \"timescale.v\" `include \"ge_1000baseX_regs.v\" `include \"ge_1000baseX_constants.v\" module ge_1000baseX_rx( input ck, input reset, input [7:0] ebi_rxd, input ebi_K, input rx_even, input carrier_detect, input sync_status, input signal_detect, output rx_frame_pulse, output reg [7:0] gmii_rxd, output reg gmii_rx_dv, output reg gmii_rx_er, output reg receiving, input [2:0] xmit, output reg [15:0] rx_config, output reg rx_config_set, input mr_main_reset, output reg [2:0] rudi, output reg ability_match, output reg acknowledge_match, output consistency_match, output idle_match ); `define RX_FRAME_CNT 16'h0000 `define RX_DATA_CNT 16'h0001 `define EARLY_END_CNT 16'h0002 `define CHECK_END_T_R_K28_5_CNT 16'h0003 `define CHECK_END_R_R_K28_5_CNT 16'h0004 `define CHECK_END_T_R_R_CNT 16'h0005 `define CHECK_END_R_R_R_CNT 16'h0006 `define CHECK_END_R_R_S_CNT 16'h0007 `define RESET 16'hffff reg [7:0] ge_x_pcs_rx_stats_inc; reg [15:0] rx_frame_cnt; reg [15:0] rx_data_cnt; reg [15:0] early_end_cnt; reg [15:0] check_end_T_R_K28_5_cnt; reg [15:0] check_end_R_R_K28_5_cnt; reg [15:0] check_end_T_R_R_cnt; reg [15:0] check_end_R_R_R_cnt; reg [15:0] check_end_R_R_S_cnt; always @(posedge ck or posedge reset) if (reset) begin rx_frame_cnt <= 0; rx_data_cnt <= 0; early_end_cnt <= 0; check_end_T_R_K28_5_cnt <= 0; check_end_R_R_K28_5_cnt <= 0; check_end_T_R_R_cnt <= 0; check_end_R_R_R_cnt <= 0; check_end_R_R_S_cnt <= 0; end else begin if (ge_x_pcs_rx_stats_inc[0]) rx_frame_cnt <= rx_frame_cnt + 1; else if (ge_x_pcs_rx_stats_inc[1]) rx_data_cnt <= rx_data_cnt + 1; else if (ge_x_pcs_rx_stats_inc[2]) early_end_cnt <= early_end_cnt + 1; else if (ge_x_pcs_rx_stats_inc[3]) check_end_T_R_K28_5_cnt <= check_end_T_R_K28_5_cnt + 1; else if (ge_x_pcs_rx_stats_inc[4]) check_end_R_R_K28_5_cnt <= check_end_R_R_K28_5_cnt + 1; else if (ge_x_pcs_rx_stats_inc[5]) check_end_T_R_R_cnt <= check_end_T_R_R_cnt + 1; else if (ge_x_pcs_rx_stats_inc[6]) check_end_R_R_R_cnt <= check_end_R_R_R_cnt + 1; else if (ge_x_pcs_rx_stats_inc[7]) check_end_R_R_S_cnt <= check_end_R_R_S_cnt + 1; end assign rx_frame_pulse = ge_x_pcs_rx_stats_inc[0]; reg soft_reset; always @(posedge ck or posedge reset) if (reset) soft_reset <= 0; else soft_reset <= mr_main_reset; reg [7:0] ebi_rxd_d1; reg [7:0] ebi_rxd_d2; reg [7:0] ebi_rxd_d3; reg ebi_K_d1, ebi_K_d2, ebi_K_d3; reg rx_even_d1, rx_even_d2, rx_even_d3; reg sync_status_d1, sync_status_d2, sync_status_d3; reg carrier_detect_d1, carrier_detect_d2, carrier_detect_d3; always @(posedge ck or posedge reset) if (reset) begin ebi_K_d1 <= 0; ebi_K_d2 <= 0; ebi_K_d3 <= 0; rx_even_d1 <= 0; rx_even_d2 <= 0; rx_even_d3 <= 0; ebi_rxd_d1 <= 0; ebi_rxd_d2 <= 0; ebi_rxd_d3 <= 0; sync_status_d1 <= 0; sync_status_d2 <= 0; sync_status_d3 <= 0; carrier_detect_d1 <= 0; carrier_detect_d2 <= 0; carrier_detect_d3 <= 0; end else begin ebi_K_d3 <= ebi_K_d2; ebi_K_d2 <= ebi_K_d1; ebi_K_d1 <= ebi_K; rx_even_d3 <= rx_even_d2; rx_even_d2 <= rx_even_d1; rx_even_d1 <= rx_even; ebi_rxd_d3 <= ebi_rxd_d2; ebi_rxd_d2 <= ebi_rxd_d1; ebi_rxd_d1 <= ebi_rxd; sync_status_d3 <= sync_status_d2; sync_status_d2 <= sync_status_d1; sync_status_d1 <= sync_status; carrier_detect_d3 <= carrier_detect_d2; carrier_detect_d2 <= carrier_detect_d1; carrier_detect_d1 <= carrier_detect; end `ifdef MODEL_TECH wire [4:0] ebi_rxd_d1_X; wire [2:0] ebi_rxd_d1_Y; wire [4:0] ebi_rxd_d2_X; wire [2:0] ebi_rxd_d2_Y; wire [4:0] ebi_rxd_d3_X; wire [2:0] ebi_rxd_d3_Y; assign {ebi_rxd_d1_Y, ebi_rxd_d1_X} = ebi_rxd_d1; assign {ebi_rxd_d2_Y, ebi_rxd_d2_X} = ebi_rxd_d2; assign {ebi_rxd_d3_Y, ebi_rxd_d3_X} = ebi_rxd_d3; `endif wire early_end_idle; assign early_end_idle = (ebi_K_d2 & ebi_rxd_d2 == `K28_5_symbol) & ~(ebi_K_d1) & (ebi_K & ebi_rxd == `K28_5_symbol); wire early_end_config; assign early_end_config = (( ebi_K_d2 & ebi_rxd_d2 == `K28_5_symbol) & (~ebi_K_d1 & (ebi_rxd_d1 == `D21_5_symbol | ebi_rxd_d1 == `D2_2_symbol)) & (~ebi_K & ebi_rxd == `D0_0_symbol)); reg early_end; always @(posedge ck or posedge reset) if (reset) early_end <= 0; else early_end <= (early_end_idle | early_end_config) & rx_even; reg check_end_T_R_K28_5; always @(posedge ck or posedge reset) if (reset) check_end_T_R_K28_5 <= 0; else check_end_T_R_K28_5 <= ((ebi_K_d2 & ebi_rxd_d2 == `K29_7_symbol) & (ebi_K_d1 & ebi_rxd_d1 == `K23_7_symbol) & (ebi_K & ebi_rxd == `K28_5_symbol) & rx_even); reg check_end_T_R_R; always @(posedge ck or posedge reset) if (reset) check_end_T_R_R <= 0; else check_end_T_R_R <= ((ebi_K_d2 & ebi_rxd_d2 == `K29_7_symbol) & (ebi_K_d1 & ebi_rxd_d1 == `K23_7_symbol) & (ebi_K & ebi_rxd == `K23_7_symbol)); reg check_end_R_R_R; always @(posedge ck or posedge reset) if (reset) check_end_R_R_R <= 0; else check_end_R_R_R <= ((ebi_K_d2 & ebi_rxd_d2 == `K23_7_symbol) & (ebi_K_d1 & ebi_rxd_d1 == `K23_7_symbol) & (ebi_K & ebi_rxd == `K23_7_symbol)); reg check_end_R_R_K28_5; always @(posedge ck or posedge reset) if (reset) check_end_R_R_K28_5 <= 0; else check_end_R_R_K28_5 <= ((ebi_K_d2 & ebi_rxd_d2 == `K23_7_symbol) & (ebi_K_d1 & ebi_rxd_d1 == `K23_7_symbol) & (ebi_K & ebi_rxd == `K28_5_symbol) & rx_even); reg check_end_R_R_S; always @(posedge ck or posedge reset) if (reset) check_end_R_R_S <= 0; else check_end_R_R_S <= ((ebi_K_d2 & ebi_rxd_d2 == `K23_7_symbol) & (ebi_K_d1 & ebi_rxd_d1 == `K23_7_symbol) & (ebi_K & ebi_rxd == `K27_7_symbol)); reg K28_5_match, D2_2_match, D21_5_match, D5_6_match, D16_2_match; always @(posedge ck or posedge reset) if (reset) begin K28_5_match <= 0; D2_2_match <= 0; D21_5_match <= 0; D5_6_match <= 0; D16_2_match <= 0; end else begin K28_5_match <= (ebi_K_d2 & ebi_rxd_d2 == `K28_5_symbol); D2_2_match <= ~ebi_K_d2 & (ebi_rxd_d2 == `D2_2_symbol); D21_5_match <= ~ebi_K_d2 & (ebi_rxd_d2 == `D21_5_symbol); D5_6_match <= ~ebi_K_d2 & (ebi_rxd_d2 == `D5_6_symbol); D16_2_match <= ~ebi_K_d2 & (ebi_rxd_d2 == `D16_2_symbol); end reg CE_match, SPD_match, EPD_match; always @(posedge ck or posedge reset) if (reset) begin CE_match <= 0; SPD_match <= 0; EPD_match <= 0; end else begin CE_match <= ebi_K_d2 & (ebi_rxd_d2 == `K23_7_symbol); SPD_match <= ebi_K_d2 & (ebi_rxd_d2 == `K27_7_symbol); EPD_match <= ebi_K_d2 & (ebi_rxd_d2 == `K29_7_symbol); end `ifdef MODEL_TECH wire [4:0] ebi_rxd_X; wire [2:0] ebi_rxd_Y; assign ebi_rxd_X = ebi_rxd[4:0]; assign ebi_rxd_Y = ebi_rxd[7:5]; `endif reg [15:0] rx_config_d1; reg [15:0] rx_config_d2; reg [7:0] rx_config_lo; reg rx_config_lo_read, rx_config_hi_read; wire [15:0] rx_config_tmp = { ebi_rxd_d3, rx_config_lo }; always @(posedge ck or posedge reset) if (reset) begin rx_config <= 0; rx_config_set <= 0; rx_config_lo <= 0; rx_config_d1 <= 0; rx_config_d2 <= 0; end else begin if (rx_config_lo_read) begin rx_config_d2 <= rx_config_d1; rx_config_d1 <= rx_config; rx_config_lo <= ebi_rxd_d3; end else if (rx_config_hi_read) begin rx_config <= rx_config_tmp; rx_config_set <= |rx_config_tmp; end end reg [2:0] rx_config_cnt; reg rx_config_cnt_m_inc, rx_config_cnt_m_rst; always @(posedge ck or posedge reset) if (reset) rx_config_cnt <= 0; else begin if (rx_config_cnt_m_inc) rx_config_cnt <= rx_config_cnt + 1; else if (rx_config_cnt_m_rst) rx_config_cnt <= 0; end wire rx_config_cnt_done; assign rx_config_cnt_done = (rx_config_cnt == 3); wire [6:0] ability; wire [6:0] ability_d1; wire [6:0] ability_d2; assign ability = { rx_config[15], rx_config[13:12], rx_config[8:5] }; assign ability_d1 = { rx_config_d1[15], rx_config_d1[13:12], rx_config_d1[8:5]}; assign ability_d2 = { rx_config_d2[15], rx_config_d2[13:12], rx_config_d2[8:5]}; assign ability_matched1 = ~| (ability ^ ability_d1); assign ability_matched2 = ~| (ability ^ ability_d2); assign ability_matched = rx_config_cnt_done & ability_matched1 & ability_matched2; reg [6:0] ability_matched_reg; always @(posedge ck or posedge reset) if (reset) ability_matched_reg <= 0; else begin ability_match <= ability_matched; if (ability_matched) ability_matched_reg <= ability; end assign rx_config_match1 = ability_matched1 & ~(rx_config[14] ^ rx_config_d1[14]); assign rx_config_match2 = ability_matched2 & ~(rx_config[14] ^ rx_config_d2[14]); assign rx_config_match = rx_config_match1 & rx_config_match2; always @(posedge ck or posedge reset) acknowledge_match <= (reset) ? 0 : ( rx_config_match & rx_config_d2[14] ); assign consistency_match = ability_match & ~|(ability_matched_reg ^ ability); reg [1:0] idle_cnt; reg idle_cnt_m_inc, idle_cnt_m_clr; always @(posedge ck or posedge reset) if (reset) idle_cnt <= 0; else begin if (idle_cnt_m_clr) idle_cnt <= 0; else if (idle_cnt_m_inc) idle_cnt <= idle_cnt + 1; end assign idle_match = (idle_cnt == 3); reg rudi_INVALID_m_set; reg rudi_IDLE_m_set; reg rudi_CONF_m_set; always @(posedge ck or posedge reset) if (reset) rudi <= `RUDI_INVALID; else begin if (rudi_INVALID_m_set) rudi <= `RUDI_INVALID; else if (rudi_IDLE_m_set) rudi <= `RUDI_IDLE; else if (rudi_CONF_m_set) rudi <= `RUDI_CONF; end reg gmii_rxd_false_carrier_m_set, gmii_rxd_preamble_m_set, gmii_rxd_ext_err_m_set; reg gmii_rxd_packet_burst_m_set, gmii_rxd_trr_extend_m_set, gmii_rxd_m_set; always @(posedge ck or posedge reset) if (reset) gmii_rxd <= 0; else begin gmii_rxd <= (gmii_rxd_m_set) ? ebi_rxd_d3 : (gmii_rxd_false_carrier_m_set) ? 8'b00001110 : (gmii_rxd_preamble_m_set) ? 8'b01010101 : (gmii_rxd_ext_err_m_set) ? 8'b00011111 : (gmii_rxd_trr_extend_m_set) ? 8'b00001111 : (gmii_rxd_packet_burst_m_set) ? 8'b00001111 : 0; end reg receiving_m_set, receiving_m_clr; always @(posedge ck or posedge reset) if (reset) receiving <= 0; else begin if (receiving_m_set) receiving <= 1; else if (receiving_m_clr) receiving <= 0; end `ifdef MODEL_TECH enum logic [4:0] { `else localparam `endif S_PCS_RX_START = 0, S_PCS_RX_LINK_FAILED = 1, S_PCS_RX_WAIT_K = 2, S_PCS_RX_K = 3, S_PCS_RX_CONFIG_CB = 4, S_PCS_RX_CONFIG_CC = 5, S_PCS_RX_CONFIG_CD = 6, S_PCS_RX_INVALID = 7, S_PCS_RX_IDLE_D = 8, S_PCS_RX_FALSE_CARRIER = 9, S_PCS_RX_START_OF_PACKET = 10, S_PCS_RX_RECEIVE = 11, S_PCS_RX_EARLY_END = 12, S_PCS_RX_TRI_RRI = 13, S_PCS_RX_TRR_EXTEND = 14, S_PCS_RX_EPD2_CHECK_END = 15, S_PCS_RX_PACKET_BURST_RRS = 16, S_PCS_RX_EXTEND_ERR = 17, S_PCS_RX_EARLY_END_EXT = 18, S_PCS_RX_DATA_ERROR = 19, S_PCS_RX_DATA = 20 `ifdef MODEL_TECH } pcs_rx_present, pcs_rx_next; `else ; reg [4:0] pcs_rx_present, pcs_rx_next; `endif reg gmii_rx_er_m_set, gmii_rx_er_m_clr; always @(posedge ck or posedge reset) if (reset) gmii_rx_er <= 0; else begin if (gmii_rx_er_m_set) gmii_rx_er <= 1; else if (gmii_rx_er_m_clr) gmii_rx_er <= 0; end reg gmii_rx_dv_m_set, gmii_rx_dv_m_clr; always @(posedge ck or posedge reset) if (reset) gmii_rx_dv <= 0; else begin if (gmii_rx_dv_m_set) gmii_rx_dv <= 1; else if (gmii_rx_dv_m_clr) gmii_rx_dv <= 0; end wire xmit_DATA, xmit_nDATA, xmit_DATA_CD, xmit_DATA_nCD; assign xmit_DATA = (xmit == `XMIT_DATA); assign xmit_nDATA = (xmit != `XMIT_DATA); assign xmit_DATA_CD = (xmit_DATA & carrier_detect_d3); assign xmit_DATA_nCD = (xmit_DATA & ~carrier_detect_d3); wire xmit_DATA_CD_SPD, xmit_DATA_CD_nSPD, xmit_DATA_CD_nSPD_nK28_5; assign xmit_DATA_CD_SPD = xmit_DATA_CD & SPD_match; assign xmit_DATA_CD_nSPD = xmit_DATA_CD & ~SPD_match; assign xmit_DATA_CD_nSPD_nK28_5 = xmit_DATA_CD_nSPD & ~K28_5_match; always @(posedge ck or posedge reset) pcs_rx_present <= (reset) ? S_PCS_RX_START : pcs_rx_next; always @* begin pcs_rx_next = pcs_rx_present; rx_config_lo_read = 0; rx_config_hi_read = 0; receiving_m_set = 0; receiving_m_clr = 0; gmii_rxd_false_carrier_m_set = 0; gmii_rxd_preamble_m_set = 0; gmii_rxd_ext_err_m_set = 0; gmii_rxd_packet_burst_m_set = 0; gmii_rxd_trr_extend_m_set = 0; gmii_rxd_m_set = 0; idle_cnt_m_clr = 0; idle_cnt_m_inc = 0; gmii_rx_er_m_set = 0; gmii_rx_er_m_clr = 0; gmii_rx_dv_m_set = 0; gmii_rx_dv_m_clr = 0; rudi_INVALID_m_set = 0; rudi_IDLE_m_set = 0; rudi_CONF_m_set = 0; rx_config_cnt_m_inc = 0; rx_config_cnt_m_rst = 0; ge_x_pcs_rx_stats_inc = 16'h0000; case (pcs_rx_present) S_PCS_RX_START: begin pcs_rx_next = S_PCS_RX_LINK_FAILED; end S_PCS_RX_LINK_FAILED: begin rudi_INVALID_m_set = (xmit_nDATA); if (receiving) begin receiving_m_clr = 1; gmii_rx_er_m_set = 1; end else begin gmii_rx_dv_m_clr = 1; gmii_rx_er_m_clr = 1; end pcs_rx_next = S_PCS_RX_WAIT_K; end S_PCS_RX_WAIT_K: begin rx_config_cnt_m_rst = 1; receiving_m_clr = 1; gmii_rx_dv_m_clr = 1; gmii_rx_er_m_clr = 1; pcs_rx_next = (K28_5_match & rx_even_d3) ? S_PCS_RX_K : S_PCS_RX_WAIT_K; end S_PCS_RX_K: begin receiving_m_clr = 1; gmii_rx_dv_m_clr = 1; gmii_rx_er_m_clr = 1; rudi_IDLE_m_set = (xmit_nDATA & ~ebi_K_d3 & ~D21_5_match & ~D2_2_match) | (xmit_DATA & ~D21_5_match & ~D2_2_match); pcs_rx_next = (D21_5_match | D2_2_match) ? S_PCS_RX_CONFIG_CB : ((xmit_nDATA) & ~ebi_K_d3 & ~D21_5_match & ~D2_2_match) ? S_PCS_RX_IDLE_D : ((xmit_DATA) & ~D21_5_match & ~D2_2_match) ? S_PCS_RX_IDLE_D : ((xmit_nDATA) & ebi_K_d3) ? S_PCS_RX_INVALID : S_PCS_RX_INVALID; end S_PCS_RX_CONFIG_CB: begin rx_config_cnt_m_inc = ~rx_config_cnt_done; rx_config_lo_read = ~ebi_K_d3; receiving_m_clr = 1; gmii_rx_dv_m_clr = 1; gmii_rx_er_m_clr = 1; pcs_rx_next = (ebi_K_d3) ? S_PCS_RX_INVALID : S_PCS_RX_CONFIG_CC; end S_PCS_RX_CONFIG_CC: begin rx_config_hi_read = ~ebi_K_d3; idle_cnt_m_clr = 1; rudi_CONF_m_set = ~ebi_K_d3; pcs_rx_next = (ebi_K_d3) ? S_PCS_RX_INVALID : S_PCS_RX_CONFIG_CD; end S_PCS_RX_CONFIG_CD: begin pcs_rx_next = (K28_5_match & rx_even_d3) ? S_PCS_RX_K : S_PCS_RX_INVALID; end S_PCS_RX_INVALID: begin rudi_INVALID_m_set = (xmit == `XMIT_CONFIGURATION); receiving_m_set = (xmit_DATA); pcs_rx_next = (K28_5_match & rx_even_d3) ? S_PCS_RX_K : (~K28_5_match & rx_even_d3) ? S_PCS_RX_WAIT_K : S_PCS_RX_INVALID; end S_PCS_RX_IDLE_D: begin rx_config_cnt_m_rst = 1; idle_cnt_m_inc = ~idle_match; rudi_IDLE_m_set = 1; if (xmit_DATA_CD_SPD) gmii_rx_dv_m_set = 1; else gmii_rx_dv_m_clr = 1; if (xmit_DATA_CD_nSPD_nK28_5) gmii_rx_er_m_set = 1; else gmii_rx_er_m_clr = 1; if (xmit_DATA_CD) begin if (~K28_5_match) begin receiving_m_set = 1; if (SPD_match) gmii_rxd_preamble_m_set = 1; else gmii_rxd_false_carrier_m_set = 1; end end else receiving_m_clr = 1; pcs_rx_next = (~K28_5_match & ~xmit_DATA ) ? S_PCS_RX_INVALID : ( xmit_DATA_CD_SPD ) ? S_PCS_RX_RECEIVE : ( xmit_DATA_nCD | K28_5_match ) ? S_PCS_RX_K : ( xmit_DATA_CD_nSPD ) ? S_PCS_RX_FALSE_CARRIER : S_PCS_RX_IDLE_D; ge_x_pcs_rx_stats_inc[0] = xmit_DATA_CD_SPD; end S_PCS_RX_FALSE_CARRIER: begin gmii_rx_er_m_set = 1; gmii_rxd_false_carrier_m_set = 1; pcs_rx_next = (K28_5_match & rx_even_d3) ? S_PCS_RX_K : S_PCS_RX_FALSE_CARRIER; end S_PCS_RX_START_OF_PACKET: begin gmii_rx_dv_m_set = 1; gmii_rx_er_m_clr = 1; gmii_rxd_preamble_m_set = 1; pcs_rx_next = S_PCS_RX_RECEIVE; end S_PCS_RX_RECEIVE: begin if (early_end) begin ge_x_pcs_rx_stats_inc[2] = 1; gmii_rx_er_m_set = 1; pcs_rx_next = S_PCS_RX_EARLY_END; end else if (check_end_T_R_K28_5) begin ge_x_pcs_rx_stats_inc[3] = 1; receiving_m_clr = 1; gmii_rx_dv_m_clr = 1; gmii_rx_er_m_clr = 1; pcs_rx_next = S_PCS_RX_TRI_RRI; end else if (check_end_T_R_R) begin ge_x_pcs_rx_stats_inc[5] = 1; gmii_rx_dv_m_clr = 1; gmii_rx_er_m_set = 1; gmii_rxd_trr_extend_m_set = 1; pcs_rx_next = S_PCS_RX_EPD2_CHECK_END; end else if (check_end_R_R_R) begin ge_x_pcs_rx_stats_inc[6] = 1; gmii_rx_er_m_set = 1; pcs_rx_next = S_PCS_RX_EPD2_CHECK_END; end else if (~ebi_K_d3) begin ge_x_pcs_rx_stats_inc[1] = 1; gmii_rx_er_m_clr = 1; gmii_rxd_m_set = 1; end else gmii_rx_er_m_set = 1; end S_PCS_RX_EARLY_END: begin pcs_rx_next = (D21_5_match | D2_2_match) ? S_PCS_RX_CONFIG_CB : S_PCS_RX_IDLE_D; end S_PCS_RX_TRI_RRI: begin pcs_rx_next = (K28_5_match) ? S_PCS_RX_K : S_PCS_RX_TRI_RRI; end S_PCS_RX_TRR_EXTEND: begin gmii_rx_dv_m_clr = 1; gmii_rx_er_m_set = 1; gmii_rxd_trr_extend_m_set = 1; pcs_rx_next = S_PCS_RX_EPD2_CHECK_END; end S_PCS_RX_EPD2_CHECK_END: begin if (check_end_R_R_R) begin gmii_rx_dv_m_clr = 1; gmii_rx_er_m_set = 1; gmii_rxd_trr_extend_m_set = 1; end else if (check_end_R_R_K28_5) begin ge_x_pcs_rx_stats_inc[4] = 1; receiving_m_clr = 1; gmii_rx_dv_m_clr = 1; gmii_rx_er_m_clr = 1; end else if (check_end_R_R_S) begin ge_x_pcs_rx_stats_inc[7] = 1; end pcs_rx_next = (check_end_R_R_R) ? S_PCS_RX_TRR_EXTEND : (check_end_R_R_K28_5) ? S_PCS_RX_TRI_RRI : (check_end_R_R_S) ? S_PCS_RX_PACKET_BURST_RRS : S_PCS_RX_EXTEND_ERR; end S_PCS_RX_PACKET_BURST_RRS: begin gmii_rx_dv_m_clr = 1; gmii_rxd_packet_burst_m_set = 1; pcs_rx_next = (SPD_match) ? S_PCS_RX_START_OF_PACKET : S_PCS_RX_PACKET_BURST_RRS; end S_PCS_RX_EXTEND_ERR: begin gmii_rx_dv_m_clr = 1; gmii_rxd_ext_err_m_set = 1; pcs_rx_next = (SPD_match) ? S_PCS_RX_START_OF_PACKET : (K28_5_match & rx_even_d3) ? S_PCS_RX_K : (~SPD_match & ~K28_5_match & rx_even_d3) ? S_PCS_RX_EPD2_CHECK_END : S_PCS_RX_EXTEND_ERR; end S_PCS_RX_EARLY_END_EXT: begin gmii_rx_er_m_set = 1; pcs_rx_next = S_PCS_RX_EPD2_CHECK_END; end S_PCS_RX_DATA_ERROR: begin gmii_rx_er_m_set = 1; pcs_rx_next = S_PCS_RX_RECEIVE; end S_PCS_RX_DATA: begin gmii_rx_er_m_clr = 1; gmii_rxd_m_set = 1; pcs_rx_next = S_PCS_RX_RECEIVE; end endcase if (~signal_detect) pcs_rx_next = S_PCS_RX_LINK_FAILED; else if (~sync_status_d3) pcs_rx_next = S_PCS_RX_LINK_FAILED; else if (soft_reset) pcs_rx_next = S_PCS_RX_WAIT_K; end endmodule", "assertions_gpt_4o": "1. (reset) |-> (rx_frame_cnt == 0);\n2. (reset) |-> (rx_data_cnt == 0);\n3. (reset) |-> (early_end_cnt == 0);\n4. (reset) |-> (check_end_T_R_K28_5_cnt == 0);\n5. (reset) |-> (check_end_R_R_K28_5_cnt == 0);\n6. (reset) |-> (check_end_T_R_R_cnt == 0);\n7. (reset) |-> (check_end_R_R_R_cnt == 0);\n8. (reset) |-> (check_end_R_R_S_cnt == 0);\n9. (ge_x_pcs_rx_stats_inc[0]) |-> (rx_frame_cnt == $past(rx_frame_cnt) + 1);\n10. (ge_x_pcs_rx_stats_inc[1]) |-> (rx_data_cnt == $past(rx_data_cnt) + 1);\n11. (ge_x_pcs_rx_stats_inc[2]) |-> (early_end_cnt == $past(early_end_cnt) + 1);\n12. (ge_x_pcs_rx_stats_inc[3]) |-> (check_end_T_R_K28_5_cnt == $past(check_end_T_R_K28_5_cnt) + 1);\n13. (ge_x_pcs_rx_stats_inc[4]) |-> (check_end_R_R_K28_5_cnt == $past(check_end_R_R_K28_5_cnt) + 1);\n14. (ge_x_pcs_rx_stats_inc[5]) |-> (check_end_T_R_R_cnt == $past(check_end_T_R_R_cnt) + 1);\n15. (ge_x_pcs_rx_stats_inc[6]) |-> (check_end_R_R_R_cnt == $past(check_end_R_R_R_cnt) + 1);\n16. (ge_x_pcs_rx_stats_inc[7]) |-> (check_end_R_R_S_cnt == $past(check_end_R_R_S_cnt) + 1);\n17. (reset) |-> (soft_reset == 0);\n18. (mr_main_reset) |-> (soft_reset == 1);\n19. (reset) |-> (ebi_K_d1 == 0);\n20. (reset) |-> (ebi_K_d2 == 0);\n21. (reset) |-> (ebi_K_d3 == 0);\n22. (reset) |-> (rx_even_d1 == 0);\n23. (reset) |-> (rx_even_d2 == 0);\n24. (reset) |-> (rx_even_d3 == 0);\n25. (reset) |-> (ebi_rxd_d1 == 0);\n26. (reset) |-> (ebi_rxd_d2 == 0);\n27. (reset) |-> (ebi_rxd_d3 == 0);\n28. (reset) |-> (sync_status_d1 == 0);\n29. (reset) |-> (sync_status_d2 == 0);\n30. (reset) |-> (sync_status_d3 == 0);\n31. (reset) |-> (carrier_detect_d1 == 0);\n32. (reset) |-> (carrier_detect_d2 == 0);\n33. (reset) |-> (carrier_detect_d3 == 0);\n34. (reset) |-> (early_end == 0);\n35. (reset) |-> (check_end_T_R_K28_5 == 0);\n36. (reset) |-> (check_end_T_R_R == 0);\n37. (reset) |-> (check_end_R_R_R == 0);\n38. (reset) |-> (check_end_R_R_K28_5 == 0);\n39. (reset) |-> (check_end_R_R_S == 0);\n40. (reset) |-> (K28_5_match == 0);\n41. (reset) |-> (D2_2_match == 0);\n42. (reset) |-> (D21_5_match == 0);\n43. (reset) |-> (D5_6_match == 0);\n44. (reset) |-> (D16_2_match == 0);\n45. (reset) |-> (CE_match == 0);\n46. (reset) |-> (SPD_match == 0);\n47. (reset) |-> (EPD_match == 0);\n48. (reset) |-> (rx_config == 0);\n49. (reset) |-> (rx_config_set == 0);\n50. (reset) |-> (rx_config_lo == 0);\n51. (reset) |-> (rx_config_d1 == 0);\n52. (reset) |-> (rx_config_d2 == 0);\n53. (reset) |-> (rx_config_cnt == 0);\n54. ("}, {"file_name": "ge_1000baseX_sync.v", "verilog_design": "`include \"ge_1000baseX_constants.v\" `include \"timescale.v\" module ge_1000baseX_sync( input ck, input reset, input startup_enable, input signal_detect, input [7:0] ebi_rxd, input ebi_K, output reg [7:0] ebi_rxd_out, output reg ebi_K_out, input decoder_disparity_err, input decoder_coding_err, output reg sync_status, output reg rx_even, input loopback ); reg running_disparity; reg running_disparity_positive_m_set; reg running_disparity_negative_m_set; always @(posedge ck or posedge reset) if (reset) running_disparity <= 0; else begin if (running_disparity_positive_m_set) running_disparity <= 1; else if (running_disparity_negative_m_set) running_disparity <= 0; end reg sync_m_acquired, sync_m_lost; always @(posedge ck or posedge reset) if (reset) sync_status <= 0; else begin if (sync_m_acquired) begin sync_status <= 1; end else if (sync_m_lost) begin sync_status <= 0; end end reg rx_even_m_init, rx_even_m_set, rx_even_m_clr, rx_even_m_toggle; always @(posedge ck or posedge reset) if (reset) rx_even <= 1; else begin if (rx_even_m_init) rx_even <= 1; else if (rx_even_m_set) rx_even <= 1; else if (rx_even_m_clr) rx_even <= 0; else if (rx_even_m_toggle) rx_even <= ~rx_even; end reg [7:0] ebi_rxd_d1; reg ebi_K_d1; always @(posedge ck or posedge reset) if (reset) begin ebi_rxd_d1 <= 0; ebi_K_d1 <= 0; end else begin ebi_rxd_d1 <= ebi_rxd; ebi_K_d1 <= ebi_K; end always @(posedge ck or posedge reset) if (reset) begin ebi_rxd_out <= 0; ebi_K_out <=0; end else begin ebi_rxd_out <= ebi_rxd_d1; ebi_K_out <= ebi_K_d1; end assign K28_1_RX = (ebi_rxd_d1 == `K28_1_symbol); assign K28_5_RX = (ebi_rxd_d1 == `K28_5_symbol); assign K28_7_RX = (ebi_rxd_d1 == `K28_7_symbol); assign COMMA_RX = K28_1_RX | K28_5_RX | K28_7_RX; assign COMMA_match = COMMA_RX & ebi_K_d1; `ifdef MODEL_TECH wire [4:0] ebi_rxd_X; wire [2:0] ebi_rxd_Y; assign ebi_rxd_X = ebi_rxd[4:0]; assign ebi_rxd_Y = ebi_rxd[7:5]; `endif reg INVALID; always @(posedge ck or posedge reset) INVALID <= (reset) ? 0 : decoder_disparity_err | decoder_coding_err; assign VALID = ~INVALID; reg [2:0] good_cgs; reg good_cgs_m_init, good_cgs_m_inc, good_cgs_m_cnt; always @(posedge ck or posedge reset) if (reset) good_cgs <= 0; else begin if (good_cgs_m_init) good_cgs <= 0; else if (good_cgs_m_cnt) good_cgs <= 1; else if (good_cgs_m_inc) good_cgs <= good_cgs + 1 ; end assign good_cgs_done = (good_cgs == 3); assign cgbad = INVALID | (COMMA_match & rx_even); assign cggood = ~cgbad; `ifdef MODEL_TECH enum logic [3:0] { `else localparam `endif S_PCS_SYNC_RUN = 0, S_PCS_SYNC_LOSS_OF_SYNC = 1, S_PCS_SYNC_COMMA_DETECT_1 = 2, S_PCS_SYNC_ACQUIRE_SYNC_1 = 3, S_PCS_SYNC_COMMA_DETECT_2 = 4, S_PCS_SYNC_ACQUIRE_SYNC_2 = 5, S_PCS_SYNC_COMMA_DETECT_3 = 6, S_PCS_SYNC_ACQUIRED_1 = 7, S_PCS_SYNC_ACQUIRED_2 = 8, S_PCS_SYNC_ACQUIRED_3 = 9, S_PCS_SYNC_ACQUIRED_4 = 10, S_PCS_SYNC_ACQUIRED_2A = 11, S_PCS_SYNC_ACQUIRED_3A = 12, S_PCS_SYNC_ACQUIRED_4A = 13 `ifdef MODEL_TECH } pcs_sync_present, pcs_sync_next; `else ; reg [3:0] pcs_sync_present, pcs_sync_next; `endif always @(posedge ck or posedge reset) pcs_sync_present <= (reset) ? S_PCS_SYNC_RUN : pcs_sync_next; always @* begin pcs_sync_next = pcs_sync_present; good_cgs_m_init = 0; good_cgs_m_inc = 0; good_cgs_m_cnt = 0; sync_m_acquired = 0; sync_m_lost = 0; rx_even_m_init = 0; rx_even_m_set = 0; rx_even_m_clr = 0; rx_even_m_toggle = 0; running_disparity_negative_m_set = 0; running_disparity_positive_m_set = 0; case (pcs_sync_present) S_PCS_SYNC_RUN: begin if (startup_enable) pcs_sync_next = S_PCS_SYNC_LOSS_OF_SYNC; end S_PCS_SYNC_LOSS_OF_SYNC : begin sync_m_lost = sync_status; if ((signal_detect | loopback) & COMMA_match) begin rx_even_m_set = 1; pcs_sync_next = S_PCS_SYNC_COMMA_DETECT_1; end else rx_even_m_toggle = 1; end S_PCS_SYNC_COMMA_DETECT_1 : begin rx_even_m_toggle = 1; pcs_sync_next = (~ebi_K_d1 & ~cgbad) ? S_PCS_SYNC_ACQUIRE_SYNC_1 : S_PCS_SYNC_LOSS_OF_SYNC; end S_PCS_SYNC_ACQUIRE_SYNC_1: begin if (~rx_even & COMMA_match) begin rx_even_m_set = 1; pcs_sync_next = S_PCS_SYNC_COMMA_DETECT_2; end else begin rx_even_m_toggle = 1; pcs_sync_next = (~COMMA_match & ~INVALID) ? S_PCS_SYNC_ACQUIRE_SYNC_1 : S_PCS_SYNC_LOSS_OF_SYNC; end end S_PCS_SYNC_COMMA_DETECT_2: begin rx_even_m_toggle = 1; pcs_sync_next = (~ebi_K_d1 & ~cgbad) ? S_PCS_SYNC_ACQUIRE_SYNC_2 : S_PCS_SYNC_LOSS_OF_SYNC; end S_PCS_SYNC_ACQUIRE_SYNC_2: begin if (~rx_even & COMMA_match) begin rx_even_m_set = 1; pcs_sync_next = S_PCS_SYNC_COMMA_DETECT_3; end else begin rx_even_m_toggle = 1; pcs_sync_next = (~COMMA_match & ~INVALID) ? S_PCS_SYNC_ACQUIRE_SYNC_2 : S_PCS_SYNC_LOSS_OF_SYNC; end end S_PCS_SYNC_COMMA_DETECT_3: begin rx_even_m_toggle = 1; pcs_sync_next = (~ebi_K_d1 & ~cgbad) ? S_PCS_SYNC_ACQUIRED_1 : S_PCS_SYNC_LOSS_OF_SYNC; sync_m_acquired = ~ebi_K_d1; end S_PCS_SYNC_ACQUIRED_1: begin rx_even_m_toggle = 1; pcs_sync_next = cggood ? S_PCS_SYNC_ACQUIRED_1 : S_PCS_SYNC_ACQUIRED_2; end S_PCS_SYNC_ACQUIRED_2: begin rx_even_m_toggle = 1; if (cggood) good_cgs_m_cnt = 1; else good_cgs_m_init = 1; pcs_sync_next = cggood ? S_PCS_SYNC_ACQUIRED_2A : S_PCS_SYNC_ACQUIRED_3; end S_PCS_SYNC_ACQUIRED_3: begin rx_even_m_toggle = 1; if (cggood) good_cgs_m_cnt = 1; else good_cgs_m_init = 1; pcs_sync_next = cggood ? S_PCS_SYNC_ACQUIRED_3A: S_PCS_SYNC_ACQUIRED_4; end S_PCS_SYNC_ACQUIRED_4: begin rx_even_m_toggle = 1; if (cggood) good_cgs_m_cnt = 1; else good_cgs_m_init = 1; pcs_sync_next = cggood ? S_PCS_SYNC_ACQUIRED_4A: S_PCS_SYNC_LOSS_OF_SYNC; end S_PCS_SYNC_ACQUIRED_2A: begin rx_even_m_toggle = 1; good_cgs_m_inc = 1; pcs_sync_next = (cgbad) ? S_PCS_SYNC_ACQUIRED_3 : (good_cgs_done) ? S_PCS_SYNC_ACQUIRED_1 : S_PCS_SYNC_ACQUIRED_2A; end S_PCS_SYNC_ACQUIRED_3A: begin rx_even_m_toggle = 1; good_cgs_m_inc = 1; pcs_sync_next = (cgbad) ? S_PCS_SYNC_ACQUIRED_4 : (good_cgs_done) ? S_PCS_SYNC_ACQUIRED_2 : S_PCS_SYNC_ACQUIRED_3A; end S_PCS_SYNC_ACQUIRED_4A: begin rx_even_m_toggle = 1; good_cgs_m_inc = 1; pcs_sync_next = (cgbad) ? S_PCS_SYNC_LOSS_OF_SYNC : (good_cgs_done) ? S_PCS_SYNC_ACQUIRED_3 : S_PCS_SYNC_ACQUIRED_4A; end endcase if (~signal_detect) pcs_sync_next = S_PCS_SYNC_LOSS_OF_SYNC; end endmodule", "assertions_gpt_4o": "1. (reset) |-> (running_disparity == 0);\n2. (running_disparity_positive_m_set) |-> (running_disparity == 1);\n3. (running_disparity_negative_m_set) |-> (running_disparity == 0);\n4. (reset) |-> (sync_status == 0);\n5. (sync_m_acquired) |-> (sync_status == 1);\n6. (sync_m_lost) |-> (sync_status == 0);\n7. (reset) |-> (rx_even == 1);\n8. (rx_even_m_init) |-> (rx_even == 1);\n9. (rx_even_m_set) |-> (rx_even == 1);\n10. (rx_even_m_clr) |-> (rx_even == 0);\n11. (rx_even_m_toggle) |-> (rx_even == ~rx_even);\n12. (reset) |-> (ebi_rxd_d1 == 0);\n13. (reset) |-> (ebi_K_d1 == 0);\n14. (reset) |-> (ebi_rxd_out == 0);\n15. (reset) |-> (ebi_K_out == 0);\n16. (ebi_rxd_d1 == `K28_1_symbol) |-> (K28_1_RX == 1);\n17. (ebi_rxd_d1 == `K28_5_symbol) |-> (K28_5_RX == 1);\n18. (ebi_rxd_d1 == `K28_7_symbol) |-> (K28_7_RX == 1);\n19. (COMMA_RX & ebi_K_d1) |-> (COMMA_match == 1);\n20. (reset) |-> (INVALID == 0);\n21. (decoder_disparity_err | decoder_coding_err) |-> (INVALID == 1);\n22. (~INVALID) |-> (VALID == 1);\n23. (reset) |-> (good_cgs == 0);\n24. (good_cgs_m_init) |-> (good_cgs == 0);\n25. (good_cgs_m_cnt) |-> (good_cgs == 1);\n26. (good_cgs_m_inc) |-> (good_cgs == good_cgs + 1);\n27. (good_cgs == 3) |-> (good_cgs_done == 1);\n28. (INVALID | (COMMA_match & rx_even)) |-> (cgbad == 1);\n29. (~cgbad) |-> (cggood == 1);\n30. (pcs_sync_present == S_PCS_SYNC_RUN & startup_enable) |-> (pcs_sync_next == S_PCS_SYNC_LOSS_OF_SYNC);\n31. (pcs_sync_present == S_PCS_SYNC_LOSS_OF_SYNC & (signal_detect | loopback) & COMMA_match) |-> (pcs_sync_next == S_PCS_SYNC_COMMA_DETECT_1);\n32. (pcs_sync_present == S_PCS_SYNC_COMMA_DETECT_1 & ~ebi_K_d1 & ~cgbad) |-> (pcs_sync_next == S_PCS_SYNC_ACQUIRE_SYNC_1);\n33. (pcs_sync_present == S_PCS_SYNC_ACQUIRE_SYNC_1 & ~rx_even & COMMA_match) |-> (pcs_sync_next == S_PCS_SYNC_COMMA_DETECT_2);\n34. (pcs_sync_present == S_PCS_SYNC_COMMA_DETECT_2 & ~ebi_K_d1 & ~cgbad) |-> (pcs_sync_next == S_PCS_SYNC_ACQUIRE_SYNC_2);\n35. (pcs_sync_present == S_PCS_SYNC_ACQUIRE_SYNC_2 & ~rx_even & COMMA_match) |-> (pcs_sync_next == S_PCS_SYNC_COMMA_DETECT_3);\n36. (pcs_sync_present == S_PCS_SYNC_COMMA_DETECT_3 & ~ebi_K_d1 & ~cgbad) |-> (pcs_sync_next == S_PCS_SYNC_ACQUIRED_1);\n37. (pcs_sync_present == S_PCS_SYNC_ACQUIRED_1 & cggood) |-> (pcs_sync_next == S_PCS_SYNC_ACQUIRED_1);\n38. (pcs_sync_present == S_PCS_SYNC_ACQUIRED_2 & cggood) |-> (pcs_sync_next == S_PCS_SYNC_ACQUIRED_2A);\n39. (pcs_sync_present == S_PCS_SYNC_ACQUIRED_3 & cggood) |-> (pcs_sync_next == S_PCS_SYNC_ACQUIRED_3A);\n40. (pcs_sync_present == S_PCS_SYNC_ACQUIRED_4 & cggood) |-> (pcs_sync_next == S_PCS_SYNC_ACQUIRED_4A);\n41. (pcs_sync_present == S_PCS_SYNC_ACQUIRED_2A & cgbad) |-> (pcs_sync_next =="}, {"file_name": "eth_cop.v", "verilog_design": "module eth_cop ( wb_clk_i, wb_rst_i, m1_wb_adr_i, m1_wb_sel_i, m1_wb_we_i, m1_wb_dat_o, m1_wb_dat_i, m1_wb_cyc_i, m1_wb_stb_i, m1_wb_ack_o, m1_wb_err_o, m2_wb_adr_i, m2_wb_sel_i, m2_wb_we_i, m2_wb_dat_o, m2_wb_dat_i, m2_wb_cyc_i, m2_wb_stb_i, m2_wb_ack_o, m2_wb_err_o, s1_wb_adr_o, s1_wb_sel_o, s1_wb_we_o, s1_wb_cyc_o, s1_wb_stb_o, s1_wb_ack_i, s1_wb_err_i, s1_wb_dat_i, s1_wb_dat_o, s2_wb_adr_o, s2_wb_sel_o, s2_wb_we_o, s2_wb_cyc_o, s2_wb_stb_o, s2_wb_ack_i, s2_wb_err_i, s2_wb_dat_i, s2_wb_dat_o ); parameter ETH_BASE = 32'hd0000000; parameter ETH_WIDTH = 32'h800; parameter MEMORY_BASE = 32'h2000; parameter MEMORY_WIDTH = 32'h10000; input wb_clk_i, wb_rst_i; input [31:0] m1_wb_adr_i, m1_wb_dat_i; input [3:0] m1_wb_sel_i; input m1_wb_cyc_i, m1_wb_stb_i, m1_wb_we_i; output [31:0] m1_wb_dat_o; output m1_wb_ack_o, m1_wb_err_o; input [31:0] m2_wb_adr_i, m2_wb_dat_i; input [3:0] m2_wb_sel_i; input m2_wb_cyc_i, m2_wb_stb_i, m2_wb_we_i; output [31:0] m2_wb_dat_o; output m2_wb_ack_o, m2_wb_err_o; input [31:0] s1_wb_dat_i; input s1_wb_ack_i, s1_wb_err_i; output [31:0] s1_wb_adr_o, s1_wb_dat_o; output [3:0] s1_wb_sel_o; output s1_wb_we_o, s1_wb_cyc_o, s1_wb_stb_o; input [31:0] s2_wb_dat_i; input s2_wb_ack_i, s2_wb_err_i; output [31:0] s2_wb_adr_o, s2_wb_dat_o; output [3:0] s2_wb_sel_o; output s2_wb_we_o, s2_wb_cyc_o, s2_wb_stb_o; reg m1_in_progress; reg m2_in_progress; reg [31:0] s1_wb_adr_o; reg [3:0] s1_wb_sel_o; reg s1_wb_we_o; reg [31:0] s1_wb_dat_o; reg s1_wb_cyc_o; reg s1_wb_stb_o; reg [31:0] s2_wb_adr_o; reg [3:0] s2_wb_sel_o; reg s2_wb_we_o; reg [31:0] s2_wb_dat_o; reg s2_wb_cyc_o; reg s2_wb_stb_o; reg m1_wb_ack_o; reg [31:0] m1_wb_dat_o; reg m2_wb_ack_o; reg [31:0] m2_wb_dat_o; reg m1_wb_err_o; reg m2_wb_err_o; wire m_wb_access_finished; wire m1_addressed_s1 = (m1_wb_adr_i >= ETH_BASE) & (m1_wb_adr_i < (ETH_BASE + ETH_WIDTH)); wire m1_addressed_s2 = (m1_wb_adr_i >= MEMORY_BASE) & (m1_wb_adr_i < (MEMORY_BASE + MEMORY_WIDTH)); wire m2_addressed_s1 = (m2_wb_adr_i >= ETH_BASE) & (m2_wb_adr_i < (ETH_BASE + ETH_WIDTH)); wire m2_addressed_s2 = (m2_wb_adr_i >= MEMORY_BASE) & (m2_wb_adr_i < (MEMORY_BASE + MEMORY_WIDTH)); wire m1_req = m1_wb_cyc_i & m1_wb_stb_i & (m1_addressed_s1 | m1_addressed_s2); wire m2_req = m2_wb_cyc_i & m2_wb_stb_i & (m2_addressed_s1 | m2_addressed_s2); always @ (posedge wb_clk_i or posedge wb_rst_i) begin if(wb_rst_i) begin m1_in_progress <= 0; m2_in_progress <= 0; s1_wb_adr_o <= 0; s1_wb_sel_o <= 0; s1_wb_we_o <= 0; s1_wb_dat_o <= 0; s1_wb_cyc_o <= 0; s1_wb_stb_o <= 0; s2_wb_adr_o <= 0; s2_wb_sel_o <= 0; s2_wb_we_o <= 0; s2_wb_dat_o <= 0; s2_wb_cyc_o <= 0; s2_wb_stb_o <= 0; end else begin case({m1_in_progress, m2_in_progress, m1_req, m2_req, m_wb_access_finished}) 5'b00_10_0, 5'b00_11_0 : begin m1_in_progress <= 1'b1; if(m1_addressed_s1) begin s1_wb_adr_o <= m1_wb_adr_i; s1_wb_sel_o <= m1_wb_sel_i; s1_wb_we_o <= m1_wb_we_i; s1_wb_dat_o <= m1_wb_dat_i; s1_wb_cyc_o <= 1'b1; s1_wb_stb_o <= 1'b1; end else if(m1_addressed_s2) begin s2_wb_adr_o <= m1_wb_adr_i; s2_wb_sel_o <= m1_wb_sel_i; s2_wb_we_o <= m1_wb_we_i; s2_wb_dat_o <= m1_wb_dat_i; s2_wb_cyc_o <= 1'b1; s2_wb_stb_o <= 1'b1; end else $display(\"(%t)(%m)WISHBONE ERROR: Unspecified address space accessed\", $time); end 5'b00_01_0 : begin m2_in_progress <= 1'b1; if(m2_addressed_s1) begin s1_wb_adr_o <= m2_wb_adr_i; s1_wb_sel_o <= m2_wb_sel_i; s1_wb_we_o <= m2_wb_we_i; s1_wb_dat_o <= m2_wb_dat_i; s1_wb_cyc_o <= 1'b1; s1_wb_stb_o <= 1'b1; end else if(m2_addressed_s2) begin s2_wb_adr_o <= m2_wb_adr_i; s2_wb_sel_o <= m2_wb_sel_i; s2_wb_we_o <= m2_wb_we_i; s2_wb_dat_o <= m2_wb_dat_i; s2_wb_cyc_o <= 1'b1; s2_wb_stb_o <= 1'b1; end else $display(\"(%t)(%m)WISHBONE ERROR: Unspecified address space accessed\", $time); end 5'b10_10_1, 5'b10_11_1 : begin m1_in_progress <= 1'b0; if(m1_addressed_s1) begin s1_wb_cyc_o <= 1'b0; s1_wb_stb_o <= 1'b0; end else if(m1_addressed_s2) begin s2_wb_cyc_o <= 1'b0; s2_wb_stb_o <= 1'b0; end end 5'b01_01_1, 5'b01_11_1 : begin m2_in_progress <= 1'b0; if(m2_addressed_s1) begin s1_wb_cyc_o <= 1'b0; s1_wb_stb_o <= 1'b0; end else if(m2_addressed_s2) begin s2_wb_cyc_o <= 1'b0; s2_wb_stb_o <= 1'b0; end end endcase end end always @ (m1_in_progress or m1_wb_adr_i or s1_wb_ack_i or s2_wb_ack_i or s1_wb_dat_i or s2_wb_dat_i or m1_addressed_s1 or m1_addressed_s2) begin if(m1_in_progress) begin if(m1_addressed_s1) begin m1_wb_ack_o <= s1_wb_ack_i; m1_wb_dat_o <= s1_wb_dat_i; end else if(m1_addressed_s2) begin m1_wb_ack_o <= s2_wb_ack_i; m1_wb_dat_o <= s2_wb_dat_i; end end else m1_wb_ack_o <= 0; end always @ (m2_in_progress or m2_wb_adr_i or s1_wb_ack_i or s2_wb_ack_i or s1_wb_dat_i or s2_wb_dat_i or m2_addressed_s1 or m2_addressed_s2) begin if(m2_in_progress) begin if(m2_addressed_s1) begin m2_wb_ack_o <= s1_wb_ack_i; m2_wb_dat_o <= s1_wb_dat_i; end else if(m2_addressed_s2) begin m2_wb_ack_o <= s2_wb_ack_i; m2_wb_dat_o <= s2_wb_dat_i; end end else m2_wb_ack_o <= 0; end always @ (m1_in_progress or m1_wb_adr_i or s1_wb_err_i or s2_wb_err_i or m2_addressed_s1 or m2_addressed_s2 or m1_wb_cyc_i or m1_wb_stb_i) begin if(m1_in_progress) begin if(m1_addressed_s1) m1_wb_err_o <= s1_wb_err_i; else if(m1_addressed_s2) m1_wb_err_o <= s2_wb_err_i; end else if(m1_wb_cyc_i & m1_wb_stb_i & ~m1_addressed_s1 & ~m1_addressed_s2) m1_wb_err_o <= 1'b1; else m1_wb_err_o <= 1'b0; end always @ (m2_in_progress or m2_wb_adr_i or s1_wb_err_i or s2_wb_err_i or m2_addressed_s1 or m2_addressed_s2 or m2_wb_cyc_i or m2_wb_stb_i) begin if(m2_in_progress) begin if(m2_addressed_s1) m2_wb_err_o <= s1_wb_err_i; else if(m2_addressed_s2) m2_wb_err_o <= s2_wb_err_i; end else if(m2_wb_cyc_i & m2_wb_stb_i & ~m2_addressed_s1 & ~m2_addressed_s2) m2_wb_err_o <= 1'b1; else m2_wb_err_o <= 1'b0; end assign m_wb_access_finished = m1_wb_ack_o | m1_wb_err_o | m2_wb_ack_o | m2_wb_err_o; integer cnt; always @ (posedge wb_clk_i or posedge wb_rst_i) begin if(wb_rst_i) cnt <= 0; else if(s1_wb_ack_i | s1_wb_err_i | s2_wb_ack_i | s2_wb_err_i) cnt <= 0; else if(s1_wb_cyc_o | s2_wb_cyc_o) cnt <= cnt+1; end always @ (posedge wb_clk_i) begin if(cnt==1000) begin $display(\"(%0t)(%m) ERROR: WB activity ??? \", $time); if(s1_wb_cyc_o) begin $display(\"s1_wb_dat_o = 0x%0x\", s1_wb_dat_o); $display(\"s1_wb_adr_o = 0x%0x\", s1_wb_adr_o); $display(\"s1_wb_sel_o = 0x%0x\", s1_wb_sel_o); $display(\"s1_wb_we_o = 0x%0x\", s1_wb_we_o); end else if(s2_wb_cyc_o) begin $display(\"s2_wb_dat_o = 0x%0x\", s2_wb_dat_o); $display(\"s2_wb_adr_o = 0x%0x\", s2_wb_adr_o); $display(\"s2_wb_sel_o = 0x%0x\", s2_wb_sel_o); $display(\"s2_wb_we_o = 0x%0x\", s2_wb_we_o); end $stop; end end always @ (posedge wb_clk_i) begin if(s1_wb_err_i & s1_wb_cyc_o) begin $display(\"(%0t) ERROR: WB cycle finished with error acknowledge \", $time); $display(\"s1_wb_dat_o = 0x%0x\", s1_wb_dat_o); $display(\"s1_wb_adr_o = 0x%0x\", s1_wb_adr_o); $display(\"s1_wb_sel_o = 0x%0x\", s1_wb_sel_o); $display(\"s1_wb_we_o = 0x%0x\", s1_wb_we_o); $stop; end if(s2_wb_err_i & s2_wb_cyc_o) begin $display(\"(%0t) ERROR: WB cycle finished with error acknowledge \", $time); $display(\"s2_wb_dat_o = 0x%0x\", s2_wb_dat_o); $display(\"s2_wb_adr_o = 0x%0x\", s2_wb_adr_o); $display(\"s2_wb_sel_o = 0x%0x\", s2_wb_sel_o); $display(\"s2_wb_we_o = 0x%0x\", s2_wb_we_o); $stop; end end endmodule", "assertions_gpt_4o": "1. (m1_req & ~m1_in_progress & ~m2_in_progress) |-> (m1_in_progress == 1);\n2. (m2_req & ~m1_in_progress & ~m2_in_progress) |-> (m2_in_progress == 1);\n3. (m1_in_progress & m_wb_access_finished) |-> (m1_in_progress == 0);\n4. (m2_in_progress & m_wb_access_finished) |-> (m2_in_progress == 0);\n5. (m1_in_progress & m1_addressed_s1) |-> (s1_wb_cyc_o == 1 & s1_wb_stb_o == 1);\n6. (m1_in_progress & m1_addressed_s2) |-> (s2_wb_cyc_o == 1 & s2_wb_stb_o == 1);\n7. (m2_in_progress & m2_addressed_s1) |-> (s1_wb_cyc_o == 1 & s1_wb_stb_o == 1);\n8. (m2_in_progress & m2_addressed_s2) |-> (s2_wb_cyc_o == 1 & s2_wb_stb_o == 1);\n9. (m1_in_progress & m1_addressed_s1 & s1_wb_ack_i) |-> (m1_wb_ack_o == 1 & m1_wb_dat_o == s1_wb_dat_i);\n10. (m1_in_progress & m1_addressed_s2 & s2_wb_ack_i) |-> (m1_wb_ack_o == 1 & m1_wb_dat_o == s2_wb_dat_i);\n11. (m2_in_progress & m2_addressed_s1 & s1_wb_ack_i) |-> (m2_wb_ack_o == 1 & m2_wb_dat_o == s1_wb_dat_i);\n12. (m2_in_progress & m2_addressed_s2 & s2_wb_ack_i) |-> (m2_wb_ack_o == 1 & m2_wb_dat_o == s2_wb_dat_i);\n13. (m1_in_progress & m1_addressed_s1 & s1_wb_err_i) |-> (m1_wb_err_o == 1);\n14. (m1_in_progress & m1_addressed_s2 & s2_wb_err_i) |-> (m1_wb_err_o == 1);\n15. (m2_in_progress & m2_addressed_s1 & s1_wb_err_i) |-> (m2_wb_err_o == 1);\n16. (m2_in_progress & m2_addressed_s2 & s2_wb_err_i) |-> (m2_wb_err_o == 1);\n17. (m1_wb_cyc_i & m1_wb_stb_i & ~m1_addressed_s1 & ~m1_addressed_s2) |-> (m1_wb_err_o == 1);\n18. (m2_wb_cyc_i & m2_wb_stb_i & ~m2_addressed_s1 & ~m2_addressed_s2) |-> (m2_wb_err_o == 1);\n19. (s1_wb_cyc_o & (s1_wb_ack_i | s1_wb_err_i)) |-> (cnt == 0);\n20. (s2_wb_cyc_o & (s2_wb_ack_i | s2_wb_err_i)) |-> (cnt == 0);\n21. (cnt == 1000) |-> $stop;\n22. (s1_wb_err_i & s1_wb_cyc_o) |-> $stop;\n23. (s2_wb_err_i & s2_wb_cyc_o) |-> $stop."}, {"file_name": "eth_crc.v", "verilog_design": "module eth_crc (Clk, Reset, Data, Enable, Initialize, Crc, CrcError); input Clk; input Reset; input [3:0] Data; input Enable; input Initialize; output [31:0] Crc; output CrcError; reg [31:0] Crc; wire [31:0] CrcNext; assign CrcNext[0] = Enable & (Data[0] ^ Crc[28]); assign CrcNext[1] = Enable & (Data[1] ^ Data[0] ^ Crc[28] ^ Crc[29]); assign CrcNext[2] = Enable & (Data[2] ^ Data[1] ^ Data[0] ^ Crc[28] ^ Crc[29] ^ Crc[30]); assign CrcNext[3] = Enable & (Data[3] ^ Data[2] ^ Data[1] ^ Crc[29] ^ Crc[30] ^ Crc[31]); assign CrcNext[4] = (Enable & (Data[3] ^ Data[2] ^ Data[0] ^ Crc[28] ^ Crc[30] ^ Crc[31])) ^ Crc[0]; assign CrcNext[5] = (Enable & (Data[3] ^ Data[1] ^ Data[0] ^ Crc[28] ^ Crc[29] ^ Crc[31])) ^ Crc[1]; assign CrcNext[6] = (Enable & (Data[2] ^ Data[1] ^ Crc[29] ^ Crc[30])) ^ Crc[ 2]; assign CrcNext[7] = (Enable & (Data[3] ^ Data[2] ^ Data[0] ^ Crc[28] ^ Crc[30] ^ Crc[31])) ^ Crc[3]; assign CrcNext[8] = (Enable & (Data[3] ^ Data[1] ^ Data[0] ^ Crc[28] ^ Crc[29] ^ Crc[31])) ^ Crc[4]; assign CrcNext[9] = (Enable & (Data[2] ^ Data[1] ^ Crc[29] ^ Crc[30])) ^ Crc[5]; assign CrcNext[10] = (Enable & (Data[3] ^ Data[2] ^ Data[0] ^ Crc[28] ^ Crc[30] ^ Crc[31])) ^ Crc[6]; assign CrcNext[11] = (Enable & (Data[3] ^ Data[1] ^ Data[0] ^ Crc[28] ^ Crc[29] ^ Crc[31])) ^ Crc[7]; assign CrcNext[12] = (Enable & (Data[2] ^ Data[1] ^ Data[0] ^ Crc[28] ^ Crc[29] ^ Crc[30])) ^ Crc[8]; assign CrcNext[13] = (Enable & (Data[3] ^ Data[2] ^ Data[1] ^ Crc[29] ^ Crc[30] ^ Crc[31])) ^ Crc[9]; assign CrcNext[14] = (Enable & (Data[3] ^ Data[2] ^ Crc[30] ^ Crc[31])) ^ Crc[10]; assign CrcNext[15] = (Enable & (Data[3] ^ Crc[31])) ^ Crc[11]; assign CrcNext[16] = (Enable & (Data[0] ^ Crc[28])) ^ Crc[12]; assign CrcNext[17] = (Enable & (Data[1] ^ Crc[29])) ^ Crc[13]; assign CrcNext[18] = (Enable & (Data[2] ^ Crc[30])) ^ Crc[14]; assign CrcNext[19] = (Enable & (Data[3] ^ Crc[31])) ^ Crc[15]; assign CrcNext[20] = Crc[16]; assign CrcNext[21] = Crc[17]; assign CrcNext[22] = (Enable & (Data[0] ^ Crc[28])) ^ Crc[18]; assign CrcNext[23] = (Enable & (Data[1] ^ Data[0] ^ Crc[29] ^ Crc[28])) ^ Crc[19]; assign CrcNext[24] = (Enable & (Data[2] ^ Data[1] ^ Crc[30] ^ Crc[29])) ^ Crc[20]; assign CrcNext[25] = (Enable & (Data[3] ^ Data[2] ^ Crc[31] ^ Crc[30])) ^ Crc[21]; assign CrcNext[26] = (Enable & (Data[3] ^ Data[0] ^ Crc[31] ^ Crc[28])) ^ Crc[22]; assign CrcNext[27] = (Enable & (Data[1] ^ Crc[29])) ^ Crc[23]; assign CrcNext[28] = (Enable & (Data[2] ^ Crc[30])) ^ Crc[24]; assign CrcNext[29] = (Enable & (Data[3] ^ Crc[31])) ^ Crc[25]; assign CrcNext[30] = Crc[26]; assign CrcNext[31] = Crc[27]; always @ (posedge Clk or posedge Reset) begin if (Reset) Crc <= 32'hffffffff; else if(Initialize) Crc <= 32'hffffffff; else Crc <= CrcNext; end assign CrcError = Crc[31:0] != 32'hc704dd7b; endmodule", "assertions_gpt_4o": "(Reset) |-> (Crc == 32'hffffffff);\n(Initialize) |-> (Crc == 32'hffffffff);\n(Enable & (Data[0] ^ Crc[28])) |-> (CrcNext[0] == 1);\n(Enable & (Data[1] ^ Data[0] ^ Crc[28] ^ Crc[29])) |-> (CrcNext[1] == 1);\n(Enable & (Data[2] ^ Data[1] ^ Data[0] ^ Crc[28] ^ Crc[29] ^ Crc[30])) |-> (CrcNext[2] == 1);\n(Enable & (Data[3] ^ Data[2] ^ Data[1] ^ Crc[29] ^ Crc[30] ^ Crc[31])) |-> (CrcNext[3] == 1);\n(Enable & (Data[3] ^ Data[2] ^ Data[0] ^ Crc[28] ^ Crc[30] ^ Crc[31])) |-> (CrcNext[4] == Crc[0]);\n(Enable & (Data[3] ^ Data[1] ^ Data[0] ^ Crc[28] ^ Crc[29] ^ Crc[31])) |-> (CrcNext[5] == Crc[1]);\n(Enable & (Data[2] ^ Data[1] ^ Crc[29] ^ Crc[30])) |-> (CrcNext[6] == Crc[2]);\n(Enable & (Data[3] ^ Data[2] ^ Data[0] ^ Crc[28] ^ Crc[30] ^ Crc[31])) |-> (CrcNext[7] == Crc[3]);\n(Enable & (Data[3] ^ Data[1] ^ Data[0] ^ Crc[28] ^ Crc[29] ^ Crc[31])) |-> (CrcNext[8] == Crc[4]);\n(Enable & (Data[2] ^ Data[1] ^ Crc[29] ^ Crc[30])) |-> (CrcNext[9] == Crc[5]);\n(Enable & (Data[3] ^ Data[2] ^ Data[0] ^ Crc[28] ^ Crc[30] ^ Crc[31])) |-> (CrcNext[10] == Crc[6]);\n(Enable & (Data[3] ^ Data[1] ^ Data[0] ^ Crc[28] ^ Crc[29] ^ Crc[31])) |-> (CrcNext[11] == Crc[7]);\n(Enable & (Data[2] ^ Data[1] ^ Data[0] ^ Crc[28] ^ Crc[29] ^ Crc[30])) |-> (CrcNext[12] == Crc[8]);\n(Enable & (Data[3] ^ Data[2] ^ Data[1] ^ Crc[29] ^ Crc[30] ^ Crc[31])) |-> (CrcNext[13] == Crc[9]);\n(Enable & (Data[3] ^ Data[2] ^ Crc[30] ^ Crc[31])) |-> (CrcNext[14] == Crc[10]);\n(Enable & (Data[3] ^ Crc[31])) |-> (CrcNext[15] == Crc[11]);\n(Enable & (Data[0] ^ Crc[28])) |-> (CrcNext[16] == Crc[12]);\n(Enable & (Data[1] ^ Crc[29])) |-> (CrcNext[17] == Crc[13]);\n(Enable & (Data[2] ^ Crc[30])) |-> (CrcNext[18] == Crc[14]);\n(Enable & (Data[3] ^ Crc[31])) |-> (CrcNext[19] == Crc[15]);\n(CrcNext[20] == Crc[16]);\n(CrcNext[21] == Crc[17]);\n(Enable & (Data[0] ^ Crc[28])) |-> (CrcNext[22] == Crc[18]);\n(Enable & (Data[1] ^ Data[0] ^ Crc[29] ^ Crc[28])) |-> (CrcNext[23] == Crc[19]);\n(Enable & (Data[2] ^ Data[1] ^ Crc[30] ^ Crc[29])) |-> (CrcNext[24] == Crc[20]);\n(Enable & (Data[3] ^ Data[2] ^ Crc[31] ^ Crc[30])) |->"}, {"file_name": "eth_l3_checksum.v", "verilog_design": "module eth_l3_checksum ( MRxClk ,Reset, RxData , ByteCnt, CheckSum ,CSready ); input MRxClk; input Reset; input [7:0] RxData; input [15:0] ByteCnt; output [15:0] CheckSum; output CSready; reg [15:0] CheckSum; reg [31:0] Sum; reg CSready; reg [1:0] StartCalc; reg Divided_2_clk ; reg Divided_4_clk ; reg [7:0] prev_latched_Rx; reg [7:0] prev_latched_Rx1; initial Divided_2_clk=0; initial Divided_4_clk=0; always @ (posedge MRxClk) begin Divided_2_clk <= MRxClk^Divided_2_clk; if (ByteCnt[15:0] >= 16'h17 & ByteCnt[15:0] < (16'h17+16'd20)) begin prev_latched_Rx[7:0] <= RxData[7:0]; prev_latched_Rx1[7:0] <= prev_latched_Rx[7:0]; end end always @ (posedge Divided_2_clk) Divided_4_clk <= Divided_4_clk ^ Divided_2_clk; always @ (posedge Divided_2_clk or posedge Reset ) begin if (Reset) begin CheckSum[15:0] <= 16'd0; CSready <= 1'd0; end else if (ByteCnt[15:0]==16'h15) StartCalc[0] <= (RxData[7:0] == 8'h8); else if (ByteCnt[15:0]==16'h16) begin StartCalc[0] <= (RxData[7:0] == 8'h0) & StartCalc[0] ; CheckSum[15:0] <= 16'h0; Sum[31:0] <= 32'h0; CSready <= 1'b0; end else if (ByteCnt[15:0] >= 16'h17 & ByteCnt[15:0] < (16'h17+16'd20)) begin StartCalc[1]<= (ByteCnt[15:0] > 16'h17) & StartCalc[0] ; end else StartCalc[1:0] <= 2'h0; if (ByteCnt[15:0]-16'h17== 16'd20) begin CSready <= 1'b1; CheckSum[15:0] <= ~(Sum[15:0]+Sum[31:16]); end end always @ (negedge Divided_4_clk) begin if (&StartCalc) Sum[31:0]<= Sum[31:0] + {prev_latched_Rx1[7:0] , RxData[7:0]}; end endmodule", "assertions_gpt_4o": "1. (Reset) |-> (CheckSum == 16'd0 && CSready == 1'd0);\n2. (ByteCnt == 16'h15) |-> (StartCalc[0] == (RxData == 8'h8));\n3. (ByteCnt == 16'h16) |-> (StartCalc[0] == ((RxData == 8'h0) && StartCalc[0]) && CheckSum == 16'h0 && Sum == 32'h0 && CSready == 1'b0);\n4. (ByteCnt >= 16'h17 && ByteCnt < (16'h17 + 16'd20)) |-> (StartCalc[1] == ((ByteCnt > 16'h17) && StartCalc[0]));\n5. (ByteCnt - 16'h17 == 16'd20) |-> (CSready == 1'b1 && CheckSum == ~(Sum[15:0] + Sum[31:16]));\n6. (posedge MRxClk && ByteCnt >= 16'h17 && ByteCnt < (16'h17 + 16'd20)) |-> (prev_latched_Rx == RxData);\n7. (posedge MRxClk && ByteCnt >= 16'h17 && ByteCnt < (16'h17 + 16'd20)) |-> (prev_latched_Rx1 == prev_latched_Rx);\n8. (negedge Divided_4_clk && &StartCalc) |-> (Sum == Sum + {prev_latched_Rx1, RxData});\n9. (posedge Divided_2_clk) |-> (Divided_4_clk == (Divided_4_clk ^ Divided_2_clk));\n10. (posedge MRxClk) |-> (Divided_2_clk == (MRxClk ^ Divided_2_clk));"}, {"file_name": "eth_maccontrol.v", "verilog_design": "`include \"eth_transmitcontrol.v\" `include \"eth_receivecontrol.v\" module eth_maccontrol (MTxClk, MRxClk, TxReset, RxReset, TPauseRq, TxDataIn, TxStartFrmIn, TxUsedDataIn, TxEndFrmIn, TxDoneIn, TxAbortIn, RxData, RxValid, RxStartFrm, RxEndFrm, ReceiveEnd, ReceivedPacketGood, ReceivedLengthOK, TxFlow, RxFlow, DlyCrcEn, TxPauseTV, MAC, DMAC, PadIn, PadOut, CrcEnIn, CrcEnOut, TxDataOut, TxStartFrmOut, TxEndFrmOut, TxDoneOut, TxAbortOut, TxUsedDataOut, WillSendControlFrame, TxCtrlEndFrm, ReceivedPauseFrm, ControlFrmAddressOK, SetPauseTimer, r_PassAll, RxStatusWriteLatched_sync2 ); input MTxClk; input MRxClk; input TxReset; input RxReset; input TPauseRq; input [7:0] TxDataIn; input TxStartFrmIn; input TxUsedDataIn; input TxEndFrmIn; input TxDoneIn; input TxAbortIn; input PadIn; input CrcEnIn; input [7:0] RxData; input RxValid; input RxStartFrm; input RxEndFrm; input ReceiveEnd; input ReceivedPacketGood; input ReceivedLengthOK; input TxFlow; input RxFlow; input DlyCrcEn; input [15:0] TxPauseTV; input [47:0] MAC , DMAC; input RxStatusWriteLatched_sync2; input r_PassAll; output [7:0] TxDataOut; output TxStartFrmOut; output TxEndFrmOut; output TxDoneOut; output TxAbortOut; output TxUsedDataOut; output PadOut; output CrcEnOut; output WillSendControlFrame; output TxCtrlEndFrm; output ReceivedPauseFrm; output ControlFrmAddressOK; output SetPauseTimer; reg TxUsedDataOutDetected; reg TxAbortInLatched; reg TxDoneInLatched; reg MuxedDone; reg MuxedAbort; wire [7:0] TxData_wrapped_out; wire TxEndFrmOut_uc; wire Pause; wire TxCtrlStartFrm; wire [7:0] ControlData; wire CtrlMux; wire SendingCtrlFrm; wire BlockTxDone; wire L2_wrap_en; always @ (posedge MTxClk or posedge TxReset) begin if(TxReset) TxUsedDataOutDetected <= 1'b0; else if(TxDoneIn | TxAbortIn) TxUsedDataOutDetected <= 1'b0; else if(TxUsedDataOut) TxUsedDataOutDetected <= 1'b1; end always @ (posedge MTxClk or posedge TxReset) begin if(TxReset) begin TxAbortInLatched <= 1'b0; TxDoneInLatched <= 1'b0; end else begin TxAbortInLatched <= TxAbortIn; TxDoneInLatched <= TxDoneIn; end end always @ (posedge MTxClk or posedge TxReset) begin if(TxReset) MuxedAbort <= 1'b0; else if(TxStartFrmIn) MuxedAbort <= 1'b0; else if(TxAbortIn & ~TxAbortInLatched & TxUsedDataOutDetected) MuxedAbort <= 1'b1; end always @ (posedge MTxClk or posedge TxReset) begin if(TxReset) MuxedDone <= 1'b0; else if(TxStartFrmIn) MuxedDone <= 1'b0; else if(TxDoneIn & (~TxDoneInLatched) & TxUsedDataOutDetected) MuxedDone <= 1'b1; end assign TxDoneOut = CtrlMux? ((~TxStartFrmIn) & (~BlockTxDone) & MuxedDone) : ((~TxStartFrmIn) & (~BlockTxDone) & TxDoneIn); assign TxAbortOut = CtrlMux? ((~TxStartFrmIn) & (~BlockTxDone) & MuxedAbort) : ((~TxStartFrmIn) & (~BlockTxDone) & TxAbortIn); assign TxUsedDataOut = ~CtrlMux & TxUsedDataIn; assign TxStartFrmOut = CtrlMux? TxCtrlStartFrm : (TxStartFrmIn & ~Pause); assign TxEndFrmOut = CtrlMux? TxCtrlEndFrm : TxEndFrmOut_uc; assign L2_wrap_en = 1; assign TxDataOut[7:0] = CtrlMux? ControlData[7:0] :(L2_wrap_en? TxData_wrapped_out[7:0]:TxDataIn); assign PadOut = PadIn | SendingCtrlFrm; assign CrcEnOut = CrcEnIn | SendingCtrlFrm; eth_receivecontrol receivecontrol1 ( .MTxClk(MTxClk), .MRxClk(MRxClk), .TxReset(TxReset), .RxReset(RxReset), .RxData(RxData), .RxValid(RxValid), .RxStartFrm(RxStartFrm), .RxEndFrm(RxEndFrm), .RxFlow(RxFlow), .ReceiveEnd(ReceiveEnd), .MAC(MAC), .DlyCrcEn(DlyCrcEn), .TxDoneIn(TxDoneIn), .TxAbortIn(TxAbortIn), .TxStartFrmOut(TxStartFrmOut), .ReceivedLengthOK(ReceivedLengthOK), .ReceivedPacketGood(ReceivedPacketGood), .TxUsedDataOutDetected(TxUsedDataOutDetected), .Pause(Pause), .ReceivedPauseFrm(ReceivedPauseFrm), .AddressOK(ControlFrmAddressOK), .r_PassAll(r_PassAll), .RxStatusWriteLatched_sync2(RxStatusWriteLatched_sync2), .SetPauseTimer(SetPauseTimer) ); eth_transmitcontrol transmitcontrol1 ( .MTxClk(MTxClk), .TxReset(TxReset), .TxUsedDataIn(TxUsedDataIn), .TxUsedDataOut(TxUsedDataOut), .TxDoneIn(TxDoneIn), .TxAbortIn(TxAbortIn), .TxStartFrmIn(TxStartFrmIn), .TPauseRq(TPauseRq), .TxUsedDataOutDetected(TxUsedDataOutDetected), .TxFlow(TxFlow), .DlyCrcEn(DlyCrcEn), .TxPauseTV(TxPauseTV), .MAC(MAC), .TxCtrlStartFrm(TxCtrlStartFrm), .TxCtrlEndFrm(TxCtrlEndFrm), .SendingCtrlFrm(SendingCtrlFrm), .CtrlMux(CtrlMux), .ControlData(ControlData), .WillSendControlFrame(WillSendControlFrame), .BlockTxDone(BlockTxDone) ); eth_L2_Uc_Wrapper L2_UC_wrapper(.MTxClk(MTxClk), .TxReset(TxReset), .TxDataIn(TxDataIn), .MAC(MAC),.DMAC(DMAC), .TxData_wrapped_out(TxData_wrapped_out), .TxAbortIn(TxAbortIn), .TxStartFrmIn(TxStartFrmIn), .TxEndFrmOut_uc(TxEndFrmOut_uc),.TxEndFrmIn(TxEndFrmIn) ); endmodule", "assertions_gpt_4o": "(TxReset) |-> (TxUsedDataOutDetected == 0);\n(TxDoneIn | TxAbortIn) |-> (TxUsedDataOutDetected == 0);\n(TxUsedDataOut) |-> (TxUsedDataOutDetected == 1);\n\n(TxReset) |-> (TxAbortInLatched == 0 && TxDoneInLatched == 0);\n(TxAbortIn) |-> (TxAbortInLatched == 1);\n(TxDoneIn) |-> (TxDoneInLatched == 1);\n\n(TxReset) |-> (MuxedAbort == 0);\n(TxStartFrmIn) |-> (MuxedAbort == 0);\n(TxAbortIn & ~TxAbortInLatched & TxUsedDataOutDetected) |-> (MuxedAbort == 1);\n\n(TxReset) |-> (MuxedDone == 0);\n(TxStartFrmIn) |-> (MuxedDone == 0);\n(TxDoneIn & ~TxDoneInLatched & TxUsedDataOutDetected) |-> (MuxedDone == 1);\n\n(CtrlMux & ~TxStartFrmIn & ~BlockTxDone & MuxedDone) |-> (TxDoneOut == 1);\n(~CtrlMux & ~TxStartFrmIn & ~BlockTxDone & TxDoneIn) |-> (TxDoneOut == 1);\n\n(CtrlMux & ~TxStartFrmIn & ~BlockTxDone & MuxedAbort) |-> (TxAbortOut == 1);\n(~CtrlMux & ~TxStartFrmIn & ~BlockTxDone & TxAbortIn) |-> (TxAbortOut == 1);\n\n(~CtrlMux & TxUsedDataIn) |-> (TxUsedDataOut == 1);\n\n(CtrlMux & TxCtrlStartFrm) |-> (TxStartFrmOut == 1);\n(~CtrlMux & TxStartFrmIn & ~Pause) |-> (TxStartFrmOut == 1);\n\n(CtrlMux & TxCtrlEndFrm) |-> (TxEndFrmOut == 1);\n(~CtrlMux & TxEndFrmOut_uc) |-> (TxEndFrmOut == 1);\n\n(CtrlMux & ControlData[7:0]) |-> (TxDataOut[7:0] == ControlData[7:0]);\n(~CtrlMux & L2_wrap_en & TxData_wrapped_out[7:0]) |-> (TxDataOut[7:0] == TxData_wrapped_out[7:0]);\n(~CtrlMux & ~L2_wrap_en & TxDataIn) |-> (TxDataOut[7:0] == TxDataIn);\n\n(PadIn | SendingCtrlFrm) |-> (PadOut == 1);\n(CrcEnIn | SendingCtrlFrm) |-> (CrcEnOut == 1);"}, {"file_name": "eth_random.v", "verilog_design": "module eth_random (MTxClk, Reset, StateJam, StateJam_q, RetryCnt, NibCnt, ByteCnt, RandomEq0, RandomEqByteCnt); input MTxClk; input Reset; input StateJam; input StateJam_q; input [3:0] RetryCnt; input [15:0] NibCnt; input [9:0] ByteCnt; output RandomEq0; output RandomEqByteCnt; wire Feedback; reg [9:0] x; wire [9:0] Random; reg [9:0] RandomLatched; always @ (posedge MTxClk or posedge Reset) begin if(Reset) x[9:0] <= 0; else x[9:0] <= {x[8:0], Feedback}; end assign Feedback = ~(x[2] ^ x[9]); assign Random [0] = x[0]; assign Random [1] = (RetryCnt > 1) ? x[1] : 1'b0; assign Random [2] = (RetryCnt > 2) ? x[2] : 1'b0; assign Random [3] = (RetryCnt > 3) ? x[3] : 1'b0; assign Random [4] = (RetryCnt > 4) ? x[4] : 1'b0; assign Random [5] = (RetryCnt > 5) ? x[5] : 1'b0; assign Random [6] = (RetryCnt > 6) ? x[6] : 1'b0; assign Random [7] = (RetryCnt > 7) ? x[7] : 1'b0; assign Random [8] = (RetryCnt > 8) ? x[8] : 1'b0; assign Random [9] = (RetryCnt > 9) ? x[9] : 1'b0; always @ (posedge MTxClk or posedge Reset) begin if(Reset) RandomLatched <= 10'h000; else begin if(StateJam & StateJam_q) RandomLatched <= Random; end end assign RandomEq0 = RandomLatched == 10'h0; assign RandomEqByteCnt = ByteCnt[9:0] == RandomLatched & (&NibCnt[6:0]); endmodule", "assertions_gpt_4o": "1. (Reset) |-> (x == 10'h000);\n2. (!Reset && $rose(MTxClk)) |-> (x == {x[8:0], ~(x[2] ^ x[9])});\n3. (RetryCnt <= 1) |-> (Random[1:0] == {1'b0, x[0]});\n4. (RetryCnt <= 2) |-> (Random[2:0] == {2'b00, x[0]});\n5. (RetryCnt <= 3) |-> (Random[3:0] == {3'b000, x[0]});\n6. (RetryCnt <= 4) |-> (Random[4:0] == {4'b0000, x[0]});\n7. (RetryCnt <= 5) |-> (Random[5:0] == {5'b00000, x[0]});\n8. (RetryCnt <= 6) |-> (Random[6:0] == {6'b000000, x[0]});\n9. (RetryCnt <= 7) |-> (Random[7:0] == {7'b0000000, x[0]});\n10. (RetryCnt <= 8) |-> (Random[8:0] == {8'b00000000, x[0]});\n11. (RetryCnt <= 9) |-> (Random[9:0] == {9'b000000000, x[0]});\n12. (RetryCnt > 1) |-> (Random[1] == x[1]);\n13. (RetryCnt > 2) |-> (Random[2] == x[2]);\n14. (RetryCnt > 3) |-> (Random[3] == x[3]);\n15. (RetryCnt > 4) |-> (Random[4] == x[4]);\n16. (RetryCnt > 5) |-> (Random[5] == x[5]);\n17. (RetryCnt > 6) |-> (Random[6] == x[6]);\n18. (RetryCnt > 7) |-> (Random[7] == x[7]);\n19. (RetryCnt > 8) |-> (Random[8] == x[8]);\n20. (RetryCnt > 9) |-> (Random[9] == x[9]);\n21. (Reset) |-> (RandomLatched == 10'h000);\n22. (StateJam && StateJam_q && !Reset && $rose(MTxClk)) |-> (RandomLatched == Random);\n23. (RandomLatched == 10'h0) |-> (RandomEq0 == 1);\n24. (ByteCnt[9:0] == RandomLatched && (&NibCnt[6:0])) |-> (RandomEqByteCnt == 1);"}, {"file_name": "eth_receivecontrol.v", "verilog_design": "module eth_receivecontrol (MTxClk, MRxClk, TxReset, RxReset, RxData, RxValid, RxStartFrm, RxEndFrm, RxFlow, ReceiveEnd, MAC, DlyCrcEn, TxDoneIn, TxAbortIn, TxStartFrmOut, ReceivedLengthOK, ReceivedPacketGood, TxUsedDataOutDetected, Pause, ReceivedPauseFrm, AddressOK, RxStatusWriteLatched_sync2, r_PassAll, SetPauseTimer ); input MTxClk; input MRxClk; input TxReset; input RxReset; input [7:0] RxData; input RxValid; input RxStartFrm; input RxEndFrm; input RxFlow; input ReceiveEnd; input [47:0]MAC; input DlyCrcEn; input TxDoneIn; input TxAbortIn; input TxStartFrmOut; input ReceivedLengthOK; input ReceivedPacketGood; input TxUsedDataOutDetected; input RxStatusWriteLatched_sync2; input r_PassAll; output Pause; output ReceivedPauseFrm; output AddressOK; output SetPauseTimer; reg Pause; reg AddressOK; reg TypeLengthOK; reg DetectionWindow; reg OpCodeOK; reg [2:0] DlyCrcCnt; reg [4:0] ByteCnt; reg [15:0] AssembledTimerValue; reg [15:0] LatchedTimerValue; reg ReceivedPauseFrm; reg ReceivedPauseFrmWAddr; reg PauseTimerEq0_sync1; reg PauseTimerEq0_sync2; reg [15:0] PauseTimer; reg Divider2; reg [5:0] SlotTimer; wire [47:0] ReservedMulticast; wire [15:0] TypeLength; wire ResetByteCnt; wire IncrementByteCnt; wire ByteCntEq0; wire ByteCntEq1; wire ByteCntEq2; wire ByteCntEq3; wire ByteCntEq4; wire ByteCntEq5; wire ByteCntEq12; wire ByteCntEq13; wire ByteCntEq14; wire ByteCntEq15; wire ByteCntEq16; wire ByteCntEq17; wire ByteCntEq18; wire DecrementPauseTimer; wire PauseTimerEq0; wire ResetSlotTimer; wire IncrementSlotTimer; wire SlotFinished; assign ReservedMulticast = 48'h0180C2000001; assign TypeLength = 16'h8808; always @ (posedge MRxClk or posedge RxReset) begin if(RxReset) AddressOK <= 1'b0; else if(DetectionWindow & ByteCntEq0) AddressOK <= RxData[7:0] == ReservedMulticast[47:40] | RxData[7:0] == MAC[47:40]; else if(DetectionWindow & ByteCntEq1) AddressOK <= (RxData[7:0] == ReservedMulticast[39:32] | RxData[7:0] == MAC[39:32]) & AddressOK; else if(DetectionWindow & ByteCntEq2) AddressOK <= (RxData[7:0] == ReservedMulticast[31:24] | RxData[7:0] == MAC[31:24]) & AddressOK; else if(DetectionWindow & ByteCntEq3) AddressOK <= (RxData[7:0] == ReservedMulticast[23:16] | RxData[7:0] == MAC[23:16]) & AddressOK; else if(DetectionWindow & ByteCntEq4) AddressOK <= (RxData[7:0] == ReservedMulticast[15:8] | RxData[7:0] == MAC[15:8]) & AddressOK; else if(DetectionWindow & ByteCntEq5) AddressOK <= (RxData[7:0] == ReservedMulticast[7:0] | RxData[7:0] == MAC[7:0]) & AddressOK; else if(ReceiveEnd) AddressOK <= 1'b0; end always @ (posedge MRxClk or posedge RxReset ) begin if(RxReset) TypeLengthOK <= 1'b0; else if(DetectionWindow & ByteCntEq12) TypeLengthOK <= ByteCntEq12 & (RxData[7:0] == TypeLength[15:8]); else if(DetectionWindow & ByteCntEq13) TypeLengthOK <= ByteCntEq13 & (RxData[7:0] == TypeLength[7:0]) & TypeLengthOK; else if(ReceiveEnd) TypeLengthOK <= 1'b0; end always @ (posedge MRxClk or posedge RxReset ) begin if(RxReset) OpCodeOK <= 1'b0; else if(ByteCntEq16) OpCodeOK <= 1'b0; else begin if(DetectionWindow & ByteCntEq14) OpCodeOK <= ByteCntEq14 & RxData[7:0] == 8'h00; if(DetectionWindow & ByteCntEq15) OpCodeOK <= ByteCntEq15 & RxData[7:0] == 8'h01 & OpCodeOK; end end always @ (posedge MRxClk or posedge RxReset ) begin if(RxReset) ReceivedPauseFrmWAddr <= 1'b0; else if(ReceiveEnd) ReceivedPauseFrmWAddr <= 1'b0; else if(ByteCntEq16 & TypeLengthOK & OpCodeOK & AddressOK) ReceivedPauseFrmWAddr <= 1'b1; end always @ (posedge MRxClk or posedge RxReset ) begin if(RxReset) AssembledTimerValue[15:0] <= 16'h0; else if(RxStartFrm) AssembledTimerValue[15:0] <= 16'h0; else begin if(DetectionWindow & ByteCntEq16) AssembledTimerValue[15:8] <= RxData[7:0]; if(DetectionWindow & ByteCntEq17) AssembledTimerValue[7:0] <= RxData[7:0]; end end always @ (posedge MRxClk or posedge RxReset ) begin if(RxReset) DetectionWindow <= 1'b1; else if(ByteCntEq18) DetectionWindow <= 1'b0; else if(ReceiveEnd) DetectionWindow <= 1'b1; end always @ (posedge MRxClk or posedge RxReset ) begin if(RxReset) LatchedTimerValue[15:0] <= 16'h0; else if(DetectionWindow & ReceivedPauseFrmWAddr & ByteCntEq18) LatchedTimerValue[15:0] <= AssembledTimerValue[15:0]; else if(ReceiveEnd) LatchedTimerValue[15:0] <= 16'h0; end always @ (posedge MRxClk or posedge RxReset) begin if(RxReset) DlyCrcCnt <= 3'h0; else if(RxValid & RxEndFrm) DlyCrcCnt <= 3'h0; else if(RxValid & ~RxEndFrm & ~DlyCrcCnt[2]) DlyCrcCnt <= DlyCrcCnt + 3'd1; end assign ResetByteCnt = RxEndFrm; assign IncrementByteCnt = RxValid & DetectionWindow & ~ByteCntEq18 & (~DlyCrcEn | DlyCrcEn & DlyCrcCnt[2]); always @ (posedge MRxClk or posedge RxReset) begin if(RxReset) ByteCnt[4:0] <= 5'h0; else if(ResetByteCnt) ByteCnt[4:0] <= 5'h0; else if(IncrementByteCnt) ByteCnt[4:0] <= ByteCnt[4:0] + 5'd1; end assign ByteCntEq0 = RxValid & ByteCnt[4:0] == 5'h0; assign ByteCntEq1 = RxValid & ByteCnt[4:0] == 5'h1; assign ByteCntEq2 = RxValid & ByteCnt[4:0] == 5'h2; assign ByteCntEq3 = RxValid & ByteCnt[4:0] == 5'h3; assign ByteCntEq4 = RxValid & ByteCnt[4:0] == 5'h4; assign ByteCntEq5 = RxValid & ByteCnt[4:0] == 5'h5; assign ByteCntEq12 = RxValid & ByteCnt[4:0] == 5'h0C; assign ByteCntEq13 = RxValid & ByteCnt[4:0] == 5'h0D; assign ByteCntEq14 = RxValid & ByteCnt[4:0] == 5'h0E; assign ByteCntEq15 = RxValid & ByteCnt[4:0] == 5'h0F; assign ByteCntEq16 = RxValid & ByteCnt[4:0] == 5'h10; assign ByteCntEq17 = RxValid & ByteCnt[4:0] == 5'h11; assign ByteCntEq18 = RxValid & ByteCnt[4:0] == 5'h12 & DetectionWindow; assign SetPauseTimer = ReceiveEnd & ReceivedPauseFrmWAddr & ReceivedPacketGood & ReceivedLengthOK & RxFlow; assign DecrementPauseTimer = SlotFinished & |PauseTimer; always @ (posedge MRxClk or posedge RxReset) begin if(RxReset) PauseTimer[15:0] <= 16'h0; else if(SetPauseTimer) PauseTimer[15:0] <= LatchedTimerValue[15:0]; else if(DecrementPauseTimer) PauseTimer[15:0] <= PauseTimer[15:0] - 16'd1; end assign PauseTimerEq0 = ~(|PauseTimer[15:0]); always @ (posedge MTxClk or posedge TxReset) begin if(TxReset) begin PauseTimerEq0_sync1 <= 1'b1; PauseTimerEq0_sync2 <= 1'b1; end else begin PauseTimerEq0_sync1 <= PauseTimerEq0; PauseTimerEq0_sync2 <= PauseTimerEq0_sync1; end end always @ (posedge MTxClk or posedge TxReset) begin if(TxReset) Pause <= 1'b0; else if((TxDoneIn | TxAbortIn | ~TxUsedDataOutDetected) & ~TxStartFrmOut) Pause <= RxFlow & ~PauseTimerEq0_sync2; end always @ (posedge MRxClk or posedge RxReset) begin if(RxReset) Divider2 <= 1'b0; else if(|PauseTimer[15:0] & RxFlow) Divider2 <= ~Divider2; else Divider2 <= 1'b0; end assign ResetSlotTimer = RxReset; assign IncrementSlotTimer = Pause & RxFlow & Divider2; always @ (posedge MRxClk or posedge RxReset) begin if(RxReset) SlotTimer[5:0] <= 6'h0; else if(ResetSlotTimer) SlotTimer[5:0] <= 6'h0; else if(IncrementSlotTimer) SlotTimer[5:0] <= SlotTimer[5:0] + 6'd1; end assign SlotFinished = &SlotTimer[5:0] & IncrementSlotTimer; always @ (posedge MRxClk or posedge RxReset) begin if(RxReset) ReceivedPauseFrm <= 1'b0; else if(RxStatusWriteLatched_sync2 & r_PassAll | ReceivedPauseFrm & (~r_PassAll)) ReceivedPauseFrm <= 1'b0; else if(ByteCntEq16 & TypeLengthOK & OpCodeOK) ReceivedPauseFrm <= 1'b1; end endmodule", "assertions_gpt_4o": "(ByteCntEq0 & DetectionWindow) |-> (AddressOK == (RxData[7:0] == ReservedMulticast[47:40] | RxData[7:0] == MAC[47:40]));\n(ByteCntEq1 & DetectionWindow) |-> (AddressOK == ((RxData[7:0] == ReservedMulticast[39:32] | RxData[7:0] == MAC[39:32]) & AddressOK));\n(ByteCntEq2 & DetectionWindow) |-> (AddressOK == ((RxData[7:0] == ReservedMulticast[31:24] | RxData[7:0] == MAC[31:24]) & AddressOK));\n(ByteCntEq3 & DetectionWindow) |-> (AddressOK == ((RxData[7:0] == ReservedMulticast[23:16] | RxData[7:0] == MAC[23:16]) & AddressOK));\n(ByteCntEq4 & DetectionWindow) |-> (AddressOK == ((RxData[7:0] == ReservedMulticast[15:8] | RxData[7:0] == MAC[15:8]) & AddressOK));\n(ByteCntEq5 & DetectionWindow) |-> (AddressOK == ((RxData[7:0] == ReservedMulticast[7:0] | RxData[7:0] == MAC[7:0]) & AddressOK));\n(ReceiveEnd) |-> (AddressOK == 1'b0);\n(ByteCntEq12 & DetectionWindow) |-> (TypeLengthOK == (RxData[7:0] == TypeLength[15:8]));\n(ByteCntEq13 & DetectionWindow) |-> (TypeLengthOK == ((RxData[7:0] == TypeLength[7:0]) & TypeLengthOK));\n(ReceiveEnd) |-> (TypeLengthOK == 1'b0);\n(ByteCntEq14 & DetectionWindow) |-> (OpCodeOK == (RxData[7:0] == 8'h00));\n(ByteCntEq15 & DetectionWindow) |-> (OpCodeOK == ((RxData[7:0] == 8'h01) & OpCodeOK));\n(ByteCntEq16) |-> (OpCodeOK == 1'b0);\n(ByteCntEq16 & TypeLengthOK & OpCodeOK & AddressOK) |-> (ReceivedPauseFrmWAddr == 1'b1);\n(ReceiveEnd) |-> (ReceivedPauseFrmWAddr == 1'b0);\n(ByteCntEq16 & DetectionWindow) |-> (AssembledTimerValue[15:8] == RxData[7:0]);\n(ByteCntEq17 & DetectionWindow) |-> (AssembledTimerValue[7:0] == RxData[7:0]);\n(ByteCntEq18 & DetectionWindow & ReceivedPauseFrmWAddr) |-> (LatchedTimerValue[15:0] == AssembledTimerValue[15:0]);\n(ReceiveEnd) |-> (LatchedTimerValue[15:0] == 16'h0);\n(RxValid & RxEndFrm) |-> (DlyCrcCnt == 3'h0);\n(RxValid & ~RxEndFrm & ~DlyCrcCnt[2]) |-> (DlyCrcCnt == DlyCrcCnt + 3'd1);\n(RxEndFrm) |-> (ByteCnt[4:0] == 5'h0);\n(IncrementByteCnt) |-> (ByteCnt[4:0] == ByteCnt[4:0] + 5'd1);\n(ReceiveEnd & ReceivedPauseFrmWAddr & ReceivedPacketGood & ReceivedLengthOK & RxFlow) |-> (SetPauseTimer == 1'b1);\n(SlotFinished & |PauseTimer) |-> (DecrementPauseTimer == 1'b1);\n(SetPauseTimer) |-> (PauseTimer[15:0] == LatchedTimerValue[15:0]);\n(DecrementPauseTimer) |-> (PauseTimer[15:0] == PauseTimer[15:0] - 16'd1);\n(PauseTimerEq0) |-> (PauseTimer[15:0] == 16'h0);\n(TxDoneIn | TxAbortIn | ~TxUsedDataOutDetected) & ~TxStartFrmOut |-> (Pause == (RxFlow & ~PauseTimerEq0_sync2));\n(|PauseTimer[15:0] & RxFlow) |-> (Divider2 == ~Divider2);\n(ReceiveEnd) |-> (Divider2 == 1'b0);\n(IncrementSlotTimer) |-> (SlotTimer[5:0] == SlotTimer[5:0] + 6'd1);\n(SlotFinished) |-> (SlotTimer[5:0] == 6'h0);\n(RxStatusWriteLatched_sync2 & r_PassAll | ReceivedPauseFrm & (~r"}, {"file_name": "eth_rxaddrcheck.v", "verilog_design": "`include \"timescale.v\" module eth_rxaddrcheck(MRxClk, Reset, RxData, Broadcast ,r_Bro ,r_Pro, ByteCntEq2, ByteCntEq3, ByteCntEq4, ByteCntEq5, ByteCntEq6, ByteCntEq7, HASH0, HASH1, ByteCntEq0, CrcHash, CrcHashGood, StateData, RxEndFrm, Multicast, MAC, RxAbort, AddressMiss, PassAll, ControlFrmAddressOK ); input MRxClk; input Reset; input [7:0] RxData; input Broadcast; input r_Bro; input r_Pro; input ByteCntEq0; input ByteCntEq2; input ByteCntEq3; input ByteCntEq4; input ByteCntEq5; input ByteCntEq6; input ByteCntEq7; input [31:0] HASH0; input [31:0] HASH1; input [5:0] CrcHash; input CrcHashGood; input Multicast; input [47:0] MAC; input [1:0] StateData; input RxEndFrm; input PassAll; input ControlFrmAddressOK; output RxAbort; output AddressMiss; wire BroadcastOK; wire ByteCntEq2; wire ByteCntEq3; wire ByteCntEq4; wire ByteCntEq5; wire RxAddressInvalid; wire RxCheckEn; wire HashBit; wire [31:0] IntHash; reg [7:0] ByteHash; reg MulticastOK; reg UnicastOK; reg RxAbort; reg AddressMiss; assign RxAddressInvalid = ~(UnicastOK | BroadcastOK | MulticastOK | r_Pro); assign BroadcastOK = Broadcast & ~r_Bro; assign RxCheckEn = | StateData; always @ (posedge MRxClk or posedge Reset) begin if(Reset) RxAbort <= 1'b0; else if(RxAddressInvalid & ByteCntEq7 & RxCheckEn) RxAbort <= 1'b1; else RxAbort <= 1'b0; end always @ (posedge MRxClk or posedge Reset) begin if(Reset) AddressMiss <= 1'b0; else if(ByteCntEq0) AddressMiss <= 1'b0; else if(ByteCntEq7 & RxCheckEn) AddressMiss <= (~(UnicastOK | BroadcastOK | MulticastOK | (PassAll & ControlFrmAddressOK))); end always @ (posedge MRxClk or posedge Reset) begin if(Reset) MulticastOK <= 1'b0; else if(RxEndFrm | RxAbort) MulticastOK <= 1'b0; else if(CrcHashGood & Multicast) MulticastOK <= HashBit; end always @ (posedge MRxClk or posedge Reset) begin if(Reset) UnicastOK <= 1'b0; else if(RxCheckEn & ByteCntEq2) UnicastOK <= RxData[7:0] == MAC[47:40]; else if(RxCheckEn & ByteCntEq3) UnicastOK <= ( RxData[7:0] == MAC[39:32]) & UnicastOK; else if(RxCheckEn & ByteCntEq4) UnicastOK <= ( RxData[7:0] == MAC[31:24]) & UnicastOK; else if(RxCheckEn & ByteCntEq5) UnicastOK <= ( RxData[7:0] == MAC[23:16]) & UnicastOK; else if(RxCheckEn & ByteCntEq6) UnicastOK <= ( RxData[7:0] == MAC[15:8]) & UnicastOK; else if(RxCheckEn & ByteCntEq7) UnicastOK <= ( RxData[7:0] == MAC[7:0]) & UnicastOK; else if(RxEndFrm | RxAbort) UnicastOK <= 1'b0; end assign IntHash = (CrcHash[5])? HASH1 : HASH0; always@(CrcHash or IntHash) begin case(CrcHash[4:3]) 2'b00: ByteHash = IntHash[7:0]; 2'b01: ByteHash = IntHash[15:8]; 2'b10: ByteHash = IntHash[23:16]; 2'b11: ByteHash = IntHash[31:24]; endcase end assign HashBit = ByteHash[CrcHash[2:0]]; endmodule", "assertions_gpt_4o": "(ByteCntEq7 & RxCheckEn & RxAddressInvalid) |-> (RxAbort == 1);\n(ByteCntEq7 & RxCheckEn & ~RxAddressInvalid) |-> (RxAbort == 0);\n(ByteCntEq0) |-> (AddressMiss == 0);\n(ByteCntEq7 & RxCheckEn & ~(UnicastOK | BroadcastOK | MulticastOK | (PassAll & ControlFrmAddressOK))) |-> (AddressMiss == 1);\n(ByteCntEq7 & RxCheckEn & (UnicastOK | BroadcastOK | MulticastOK | (PassAll & ControlFrmAddressOK))) |-> (AddressMiss == 0);\n(CrcHashGood & Multicast) |-> (MulticastOK == HashBit);\n(RxEndFrm | RxAbort) |-> (MulticastOK == 0);\n(RxCheckEn & ByteCntEq2) |-> (UnicastOK == (RxData[7:0] == MAC[47:40]));\n(RxCheckEn & ByteCntEq3) |-> (UnicastOK == ((RxData[7:0] == MAC[39:32]) & UnicastOK));\n(RxCheckEn & ByteCntEq4) |-> (UnicastOK == ((RxData[7:0] == MAC[31:24]) & UnicastOK));\n(RxCheckEn & ByteCntEq5) |-> (UnicastOK == ((RxData[7:0] == MAC[23:16]) & UnicastOK));\n(RxCheckEn & ByteCntEq6) |-> (UnicastOK == ((RxData[7:0] == MAC[15:8]) & UnicastOK));\n(RxCheckEn & ByteCntEq7) |-> (UnicastOK == ((RxData[7:0] == MAC[7:0]) & UnicastOK));\n(RxEndFrm | RxAbort) |-> (UnicastOK == 0);"}, {"file_name": "eth_rxcounters.v", "verilog_design": "`include \"timescale.v\" module eth_rxcounters ( MRxClk, Reset, MRxDV, StateIdle, StateSFD, StateData, StateDrop, StatePreamble, MRxDEqD, DlyCrcEn, DlyCrcCnt, Transmitting, MaxFL, r_IFG, HugEn, IFGCounterEq24, ByteCntEq0, ByteCntEq1, ByteCntEq2,ByteCntEq3,ByteCntEq4,ByteCntEq5, ByteCntEq6, ByteCntEq7, ByteCntGreat2, ByteCntSmall7, ByteCntMaxFrame, ByteCntOut ); input MRxClk; input Reset; input MRxDV; input StateSFD; input [1:0] StateData; input MRxDEqD; input StateIdle; input StateDrop; input DlyCrcEn; input StatePreamble; input Transmitting; input HugEn; input [15:0] MaxFL; input r_IFG; output IFGCounterEq24; output [3:0] DlyCrcCnt; output ByteCntEq0; output ByteCntEq1; output ByteCntEq2; output ByteCntEq3; output ByteCntEq4; output ByteCntEq5; output ByteCntEq6; output ByteCntEq7; output ByteCntGreat2; output ByteCntSmall7; output ByteCntMaxFrame; output [15:0] ByteCntOut; wire ResetByteCounter; wire IncrementByteCounter; wire ResetIFGCounter; wire IncrementIFGCounter; wire ByteCntMax; reg [15:0] ByteCnt; reg [3:0] DlyCrcCnt; reg [4:0] IFGCounter; wire [15:0] ByteCntDelayed; assign ResetByteCounter = MRxDV & (StateSFD & MRxDEqD | StateData[0] & ByteCntMaxFrame); assign IncrementByteCounter = ~ResetByteCounter & MRxDV & (StatePreamble | StateSFD | StateIdle & ~Transmitting | StateData[1] & ~ByteCntMax & ~(DlyCrcEn & |DlyCrcCnt) ); always @ (posedge MRxClk or posedge Reset) begin if(Reset) ByteCnt[15:0] <= 16'd0; else begin if(ResetByteCounter) ByteCnt[15:0] <= 16'd0; else if(IncrementByteCounter) ByteCnt[15:0] <= ByteCnt[15:0] + 16'd1; end end assign ByteCntDelayed = ByteCnt + 16'd4; assign ByteCntOut = DlyCrcEn ? ByteCntDelayed : ByteCnt; assign ByteCntEq0 = ByteCnt == 16'd0; assign ByteCntEq1 = ByteCnt == 16'd1; assign ByteCntEq2 = ByteCnt == 16'd2; assign ByteCntEq3 = ByteCnt == 16'd3; assign ByteCntEq4 = ByteCnt == 16'd4; assign ByteCntEq5 = ByteCnt == 16'd5; assign ByteCntEq6 = ByteCnt == 16'd6; assign ByteCntEq7 = ByteCnt == 16'd7; assign ByteCntGreat2 = ByteCnt > 16'd2; assign ByteCntSmall7 = ByteCnt < 16'd7; assign ByteCntMax = ByteCnt == 16'hffff; assign ByteCntMaxFrame = ByteCnt == MaxFL[15:0] & ~HugEn; assign ResetIFGCounter = StateSFD & MRxDV & MRxDEqD | StateDrop; assign IncrementIFGCounter = ~ResetIFGCounter & (StateDrop | StateIdle | StatePreamble | StateSFD) & ~IFGCounterEq24; always @ (posedge MRxClk or posedge Reset) begin if(Reset) IFGCounter[4:0] <= 5'h0; else begin if(ResetIFGCounter) IFGCounter[4:0] <= 5'h0; else if(IncrementIFGCounter) IFGCounter[4:0] <= IFGCounter[4:0] + 5'd1; end end assign IFGCounterEq24 = (IFGCounter[4:0] == 5'h18) | r_IFG; always @ (posedge MRxClk or posedge Reset) begin if(Reset) DlyCrcCnt[3:0] <= 4'h0; else begin if(DlyCrcCnt[3:0] == 4'h9) DlyCrcCnt[3:0] <= 4'h0; else if(DlyCrcEn & StateSFD) DlyCrcCnt[3:0] <= 4'h1; else if(DlyCrcEn & (|DlyCrcCnt[3:0])) DlyCrcCnt[3:0] <= DlyCrcCnt[3:0] + 4'd1; end end endmodule", "assertions_gpt_4o": "(MRxDV & StateSFD & MRxDEqD) |-> (ResetByteCounter == 1);\n(StateData[0] & ByteCntMaxFrame) |-> (ResetByteCounter == 1);\n(~ResetByteCounter & MRxDV & (StatePreamble | StateSFD | StateIdle & ~Transmitting | StateData[1] & ~ByteCntMax & ~(DlyCrcEn & |DlyCrcCnt))) |-> (IncrementByteCounter == 1);\n(Reset) |=> (ByteCnt == 16'd0);\n(ResetByteCounter) |=> (ByteCnt == 16'd0);\n(IncrementByteCounter) |=> (ByteCnt == ByteCnt + 16'd1);\n(DlyCrcEn) |-> (ByteCntOut == ByteCntDelayed);\n(~DlyCrcEn) |-> (ByteCntOut == ByteCnt);\n(ByteCnt == 16'd0) |-> (ByteCntEq0 == 1);\n(ByteCnt == 16'd1) |-> (ByteCntEq1 == 1);\n(ByteCnt == 16'd2) |-> (ByteCntEq2 == 1);\n(ByteCnt == 16'd3) |-> (ByteCntEq3 == 1);\n(ByteCnt == 16'd4) |-> (ByteCntEq4 == 1);\n(ByteCnt == 16'd5) |-> (ByteCntEq5 == 1);\n(ByteCnt == 16'd6) |-> (ByteCntEq6 == 1);\n(ByteCnt == 16'd7) |-> (ByteCntEq7 == 1);\n(ByteCnt > 16'd2) |-> (ByteCntGreat2 == 1);\n(ByteCnt < 16'd7) |-> (ByteCntSmall7 == 1);\n(ByteCnt == 16'hffff) |-> (ByteCntMax == 1);\n(ByteCnt == MaxFL & ~HugEn) |-> (ByteCntMaxFrame == 1);\n(StateSFD & MRxDV & MRxDEqD | StateDrop) |-> (ResetIFGCounter == 1);\n(~ResetIFGCounter & (StateDrop | StateIdle | StatePreamble | StateSFD) & ~IFGCounterEq24) |-> (IncrementIFGCounter == 1);\n(Reset) |=> (IFGCounter == 5'h0);\n(ResetIFGCounter) |=> (IFGCounter == 5'h0);\n(IncrementIFGCounter) |=> (IFGCounter == IFGCounter + 5'd1);\n(IFGCounter == 5'h18 | r_IFG) |-> (IFGCounterEq24 == 1);\n(Reset) |=> (DlyCrcCnt == 4'h0);\n(DlyCrcCnt == 4'h9) |=> (DlyCrcCnt == 4'h0);\n(DlyCrcEn & StateSFD) |=> (DlyCrcCnt == 4'h1);\n(DlyCrcEn & (|DlyCrcCnt)) |=> (DlyCrcCnt == DlyCrcCnt + 4'd1);"}, {"file_name": "eth_rxethmac.v", "verilog_design": "`include \"timescale.v\" `include \"eth_crc.v\" `include \"eth_rxstatem.v\" `include \"eth_rxcounters.v\" `include \"eth_rxaddrcheck.v\" module eth_rxethmac (MRxClk, MRxDV, MRxD, Reset, Transmitting, MaxFL, r_IFG, HugEn, DlyCrcEn, RxData, RxValid, RxStartFrm, RxEndFrm, ByteCnt, ByteCntEq0, ByteCntGreat2, ByteCntMaxFrame, CrcError, StateIdle, StatePreamble, StateSFD, StateData, MAC, r_Pro, r_Bro,r_HASH0, r_HASH1, RxAbort, AddressMiss, PassAll, ControlFrmAddressOK ); input MRxClk; input MRxDV; input [3:0] MRxD; input Transmitting; input HugEn; input DlyCrcEn; input [15:0] MaxFL; input r_IFG; input Reset; input [47:0] MAC; input r_Bro; input r_Pro; input [31:0] r_HASH0; input [31:0] r_HASH1; input PassAll; input ControlFrmAddressOK; output [7:0] RxData; output RxValid; output RxStartFrm; output RxEndFrm; output [15:0] ByteCnt; output ByteCntEq0; output ByteCntGreat2; output ByteCntMaxFrame; output CrcError; output StateIdle; output StatePreamble; output StateSFD; output [1:0] StateData; output RxAbort; output AddressMiss; reg [7:0] RxData; reg RxValid; reg RxStartFrm; reg RxEndFrm; reg Broadcast; reg Multicast; reg [5:0] CrcHash; reg CrcHashGood; reg DelayData; reg [7:0] LatchedByte; reg [7:0] RxData_d; reg RxValid_d; reg RxStartFrm_d; reg RxEndFrm_d; wire MRxDEqD; wire MRxDEq5; wire StateDrop; wire ByteCntEq1; wire ByteCntEq2; wire ByteCntEq3; wire ByteCntEq4; wire ByteCntEq5; wire ByteCntEq6; wire ByteCntEq7; wire ByteCntSmall7; wire [31:0] Crc; wire Enable_Crc; wire Initialize_Crc; wire [3:0] Data_Crc; wire GenerateRxValid; wire GenerateRxStartFrm; wire GenerateRxEndFrm; wire DribbleRxEndFrm; wire [3:0] DlyCrcCnt; wire IFGCounterEq24; wire [15:0] CheckSum; wire CSready; assign MRxDEqD = MRxD == 4'hd; assign MRxDEq5 = MRxD == 4'h5; initial begin RxData=0; RxData_d=0; RxStartFrm=0; RxEndFrm=0; RxStartFrm_d=0; RxEndFrm_d=0; end eth_rxstatem rxstatem1 (.MRxClk(MRxClk), .Reset(Reset), .MRxDV(MRxDV), .ByteCntEq0(ByteCntEq0), .ByteCntGreat2(ByteCntGreat2), .Transmitting(Transmitting), .MRxDEq5(MRxDEq5), .MRxDEqD(MRxDEqD), .IFGCounterEq24(IFGCounterEq24), .ByteCntMaxFrame(ByteCntMaxFrame), .StateData(StateData), .StateIdle(StateIdle), .StatePreamble(StatePreamble), .StateSFD(StateSFD), .StateDrop(StateDrop) ); eth_rxcounters rxcounters1 (.MRxClk(MRxClk), .Reset(Reset), .MRxDV(MRxDV), .StateIdle(StateIdle), .StateSFD(StateSFD), .StateData(StateData), .StateDrop(StateDrop), .StatePreamble(StatePreamble), .MRxDEqD(MRxDEqD), .DlyCrcEn(DlyCrcEn), .DlyCrcCnt(DlyCrcCnt), .Transmitting(Transmitting), .MaxFL(MaxFL), .r_IFG(r_IFG), .HugEn(HugEn), .IFGCounterEq24(IFGCounterEq24), .ByteCntEq0(ByteCntEq0), .ByteCntEq1(ByteCntEq1), .ByteCntEq2(ByteCntEq2), .ByteCntEq3(ByteCntEq3), .ByteCntEq4(ByteCntEq4), .ByteCntEq5(ByteCntEq5), .ByteCntEq6(ByteCntEq6), .ByteCntEq7(ByteCntEq7), .ByteCntGreat2(ByteCntGreat2), .ByteCntSmall7(ByteCntSmall7), .ByteCntMaxFrame(ByteCntMaxFrame), .ByteCntOut(ByteCnt) ); eth_rxaddrcheck rxaddrcheck1 (.MRxClk(MRxClk), .Reset( Reset), .RxData(RxData), .Broadcast (Broadcast), .r_Bro (r_Bro), .r_Pro(r_Pro), .ByteCntEq6(ByteCntEq6), .ByteCntEq7(ByteCntEq7), .ByteCntEq2(ByteCntEq2), .ByteCntEq3(ByteCntEq3), .ByteCntEq4(ByteCntEq4), .ByteCntEq5(ByteCntEq5), .HASH0(r_HASH0), .HASH1(r_HASH1), .ByteCntEq0(ByteCntEq0), .CrcHash(CrcHash), .CrcHashGood(CrcHashGood), .StateData(StateData), .Multicast(Multicast), .MAC(MAC), .RxAbort(RxAbort), .RxEndFrm(RxEndFrm), .AddressMiss(AddressMiss), .PassAll(PassAll), .ControlFrmAddressOK(ControlFrmAddressOK) ); assign Enable_Crc = MRxDV & (|StateData & ~ByteCntMaxFrame); assign Initialize_Crc = StateSFD | DlyCrcEn & (|DlyCrcCnt[3:0]) & DlyCrcCnt[3:0] < 4'h9; assign Data_Crc[0] = MRxD[3]; assign Data_Crc[1] = MRxD[2]; assign Data_Crc[2] = MRxD[1]; assign Data_Crc[3] = MRxD[0]; eth_crc crcrx (.Clk(MRxClk), .Reset(Reset), .Data(Data_Crc), .Enable(Enable_Crc), .Initialize(Initialize_Crc), .Crc(Crc), .CrcError(CrcError) ); eth_l3_checksum checkSumcalc ( .MRxClk(MRxClk), .Reset(Reset), .RxData(RxData), .ByteCnt(ByteCnt), .CheckSum(CheckSum), .CSready(CSready) ); always @ (posedge MRxClk) begin CrcHashGood <= StateData[0] & ByteCntEq6; end always @ (posedge MRxClk) begin if(Reset | StateIdle) CrcHash[5:0] <= 6'h0; else if(StateData[0] & ByteCntEq6) CrcHash[5:0] <= Crc[31:26]; end always @ (posedge MRxClk or posedge Reset) begin if(Reset) begin RxData_d[7:0] <= 8'h0; DelayData <= 1'b0; LatchedByte[7:0] <= 8'h0; RxData[7:0] <= 8'h0; end else begin LatchedByte[7:0] <= {MRxD[3:0], LatchedByte[7:4]}; DelayData <= StateData[0]; if(GenerateRxValid) RxData_d[7:0] <= LatchedByte[7:0] & {8{|StateData}}; else if(~DelayData) RxData_d[7:0] <= 8'h0; RxData[7:0] <= RxData_d[7:0]; end end always @ (posedge MRxClk or posedge Reset) begin if(Reset) Broadcast <= 1'b0; else begin if(StateData[0] & ~(&LatchedByte[7:0]) & ByteCntSmall7) Broadcast <= 1'b0; else if(StateData[0] & (&LatchedByte[7:0]) & ByteCntEq1) Broadcast <= 1'b1; else if(RxAbort | RxEndFrm) Broadcast <= 1'b0; end end always @ (posedge MRxClk or posedge Reset) begin if(Reset) Multicast <= 1'b0; else begin if(StateData[0] & ByteCntEq1 & LatchedByte[0]) Multicast <= 1'b1; else if(RxAbort | RxEndFrm) Multicast <= 1'b0; end end assign GenerateRxValid = StateData[0] & (~ByteCntEq0 | DlyCrcCnt >= 4'h3); always @ (posedge MRxClk or posedge Reset) begin if(Reset) begin RxValid_d <= 1'b0; RxValid <= 1'b0; end else begin RxValid_d <= GenerateRxValid; RxValid <= RxValid_d; end end assign GenerateRxStartFrm = StateData[0] & ((ByteCntEq1 & ~DlyCrcEn) | ((DlyCrcCnt == 4'h3) & DlyCrcEn)); always @ (posedge MRxClk or posedge Reset) begin if(Reset) begin RxStartFrm_d <= 1'b0; RxStartFrm <= 1'b0; end else begin RxStartFrm_d <= GenerateRxStartFrm; RxStartFrm <= RxStartFrm_d; end end assign GenerateRxEndFrm = StateData[0] & (~MRxDV & ByteCntGreat2 | ByteCntMaxFrame); assign DribbleRxEndFrm = StateData[1] & ~MRxDV & ByteCntGreat2; always @ (posedge MRxClk or posedge Reset) begin if(Reset) begin RxEndFrm_d <= 1'b0; RxEndFrm <= 1'b0; end else begin RxEndFrm_d <= GenerateRxEndFrm; RxEndFrm <= RxEndFrm_d | DribbleRxEndFrm; end end endmodule module eth_l3_checksum ( MRxClk ,Reset, RxData , ByteCnt, CheckSum ,CSready ); input MRxClk; input Reset; input [7:0] RxData; input [15:0] ByteCnt; output [15:0] CheckSum; output CSready; reg [15:0] CheckSum; reg [31:0] Sum; reg CSready; reg [1:0] StartCalc; reg Divided_2_clk ; reg Divided_4_clk ; reg [7:0] prev_latched_Rx; reg [7:0] prev_latched_Rx1; initial Divided_2_clk=0; initial Divided_4_clk=0; always @ (posedge MRxClk) begin Divided_2_clk <= MRxClk^Divided_2_clk; if (ByteCnt[15:0] >= 16'h17 & ByteCnt[15:0] < (16'h17+16'd20)) begin prev_latched_Rx[7:0] <= RxData[7:0]; prev_latched_Rx1[7:0] <= prev_latched_Rx[7:0]; end end always @ (posedge Divided_2_clk) Divided_4_clk <= Divided_4_clk ^ Divided_2_clk; always @ (posedge Divided_2_clk or posedge Reset ) begin if (Reset) begin CheckSum[15:0] <= 16'd0; CSready <= 1'd0; end else if (ByteCnt[15:0]==16'h15) StartCalc[0] <= (RxData[7:0] == 8'h8); else if (ByteCnt[15:0]==16'h16) begin StartCalc[0] <= (RxData[7:0] == 8'h0) & StartCalc[0] ; CheckSum[15:0] <= 16'h0; Sum[31:0] <= 32'h0; CSready <= 1'b0; end else if (ByteCnt[15:0] >= 16'h17 & ByteCnt[15:0] < (16'h17+16'd20)) begin StartCalc[1]<= (ByteCnt[15:0] > 16'h17) & StartCalc[0] ; end else StartCalc[1:0] <= 2'h0; if (ByteCnt[15:0]-16'h17== 16'd20) begin CSready <= 1'b1; CheckSum[15:0] <= ~(Sum[15:0]+Sum[31:16]); end end always @ (negedge Divided_4_clk) begin if (&StartCalc) Sum[31:0]<= Sum[31:0] + {prev_latched_Rx1[7:0] , RxData[7:0]}; end endmodule", "assertions_gpt_4o": "1. (Reset) |=> (RxData == 8'h0);\n2. (Reset) |=> (RxData_d == 8'h0);\n3. (Reset) |=> (RxStartFrm == 1'b0);\n4. (Reset) |=> (RxEndFrm == 1'b0);\n5. (StateData[0] & ByteCntEq6) |=> (CrcHashGood == 1'b1);\n6. (StateData[0] & ByteCntEq6) |=> (CrcHash == Crc[31:26]);\n7. (Reset) |=> (Broadcast == 1'b0);\n8. (StateData[0] & ~(&LatchedByte[7:0]) & ByteCntSmall7) |=> (Broadcast == 1'b0);\n9. (StateData[0] & (&LatchedByte[7:0]) & ByteCntEq1) |=> (Broadcast == 1'b1);\n10. (RxAbort | RxEndFrm) |=> (Broadcast == 1'b0);\n11. (Reset) |=> (Multicast == 1'b0);\n12. (StateData[0] & ByteCntEq1 & LatchedByte[0]) |=> (Multicast == 1'b1);\n13. (RxAbort | RxEndFrm) |=> (Multicast == 1'b0);\n14. (Reset) |=> (RxValid_d == 1'b0);\n15. (Reset) |=> (RxValid == 1'b0);\n16. (GenerateRxValid) |=> (RxValid_d == 1'b1);\n17. (RxValid_d) |=> (RxValid == 1'b1);\n18. (Reset) |=> (RxStartFrm_d == 1'b0);\n19. (Reset) |=> (RxStartFrm == 1'b0);\n20. (GenerateRxStartFrm) |=> (RxStartFrm_d == 1'b1);\n21. (RxStartFrm_d) |=> (RxStartFrm == 1'b1);\n22. (Reset) |=> (RxEndFrm_d == 1'b0);\n23. (Reset) |=> (RxEndFrm == 1'b0);\n24. (GenerateRxEndFrm) |=> (RxEndFrm_d == 1'b1);\n25. (RxEndFrm_d | DribbleRxEndFrm) |=> (RxEndFrm == 1'b1);\n26. (ByteCnt[15:0] >= 16'h17 & ByteCnt[15:0] < (16'h17+16'd20)) |=> (prev_latched_Rx == RxData);\n27. (ByteCnt[15:0] >= 16'h17 & ByteCnt[15:0] < (16'h17+16'd20)) |=> (prev_latched_Rx1 == prev_latched_Rx);\n28. (Reset) |=> (CheckSum == 16'd0);\n29. (Reset) |=> (CSready == 1'd0);\n30. (ByteCnt[15:0] == 16'h15) |=> (StartCalc[0] == (RxData == 8'h8));\n31. (ByteCnt[15:0] == 16'h16) |=> (StartCalc[0] == (RxData == 8'h0) & StartCalc[0]);\n32. (ByteCnt[15:0] == 16'h16) |=> (CheckSum == 16'h0);\n33. (ByteCnt[15:0] == 16'h16) |=> (Sum == 32'h0);\n34. (ByteCnt[15:0] == 16'h16) |=> (CSready == 1'b0);\n35. (ByteCnt[15:0] >= 16'h17 & ByteCnt[15:0] < (16'h17+16'd20)) |=> (StartCalc[1] == (ByteCnt > 16'h17) & StartCalc[0]);\n36. (ByteCnt[15:0] - 16'h17 == 16'd20) |=> (CSready == 1'b1);\n37. (ByteCnt[15:0] - 16'h17 == 16'd20) |=> (CheckSum == ~(Sum[15:0] + Sum[31:16]));\n38. (&StartCalc) |=> (Sum == Sum + {prev_latched_Rx1, RxData});"}, {"file_name": "eth_transmitcontrol.v", "verilog_design": "`include \"eth_fifo.v\" `include \"timescale.v\" module eth_transmitcontrol (MTxClk, TxReset, TxUsedDataIn, TxUsedDataOut, TxDoneIn, TxAbortIn, TxStartFrmIn, TPauseRq, TxUsedDataOutDetected, TxFlow, DlyCrcEn, TxPauseTV, MAC, TxCtrlStartFrm, TxCtrlEndFrm, SendingCtrlFrm, CtrlMux, ControlData, WillSendControlFrame, BlockTxDone ); input MTxClk; input TxReset; input TxUsedDataIn; input TxUsedDataOut; input TxDoneIn; input TxAbortIn; input TxStartFrmIn; input TPauseRq; input TxUsedDataOutDetected; input TxFlow; input DlyCrcEn; input [15:0] TxPauseTV; input [47:0] MAC; output TxCtrlStartFrm; output TxCtrlEndFrm; output SendingCtrlFrm; output CtrlMux; output [7:0] ControlData; output WillSendControlFrame; output BlockTxDone; reg SendingCtrlFrm; reg CtrlMux; reg WillSendControlFrame; reg [3:0] DlyCrcCnt; reg [5:0] ByteCnt; reg ControlEnd_q; reg [7:0] MuxedCtrlData; reg TxCtrlStartFrm; reg TxCtrlStartFrm_q; reg TxCtrlEndFrm; reg [7:0] ControlData; reg TxUsedDataIn_q; reg BlockTxDone; wire IncrementDlyCrcCnt; wire ResetByteCnt; wire IncrementByteCnt; wire ControlEnd; wire IncrementByteCntBy2; wire EnableCnt; always @ (posedge MTxClk or posedge TxReset) begin if(TxReset) WillSendControlFrame <= 1'b0; else if(TxCtrlEndFrm & CtrlMux) WillSendControlFrame <= 1'b0; else if(TPauseRq & TxFlow) WillSendControlFrame <= 1'b1; end always @ (posedge MTxClk or posedge TxReset) begin if(TxReset) TxCtrlStartFrm <= 1'b0; else if(TxUsedDataIn_q & CtrlMux) TxCtrlStartFrm <= 1'b0; else if(WillSendControlFrame & ~TxUsedDataOut & (TxDoneIn | TxAbortIn | TxStartFrmIn | (~TxUsedDataOutDetected))) TxCtrlStartFrm <= 1'b1; end always @ (posedge MTxClk or posedge TxReset) begin if(TxReset) TxCtrlEndFrm <= 1'b0; else if(ControlEnd | ControlEnd_q) TxCtrlEndFrm <= 1'b1; else TxCtrlEndFrm <= 1'b0; end always @ (posedge MTxClk or posedge TxReset) begin if(TxReset) CtrlMux <= 1'b0; else if(WillSendControlFrame & ~TxUsedDataOut) CtrlMux <= 1'b1; else if(TxDoneIn) CtrlMux <= 1'b0; end always @ (posedge MTxClk or posedge TxReset) begin if(TxReset) SendingCtrlFrm <= 1'b0; else if(WillSendControlFrame & TxCtrlStartFrm) SendingCtrlFrm <= 1'b1; else if(TxDoneIn) SendingCtrlFrm <= 1'b0; end always @ (posedge MTxClk or posedge TxReset) begin if(TxReset) TxUsedDataIn_q <= 1'b0; else TxUsedDataIn_q <= TxUsedDataIn; end always @ (posedge MTxClk or posedge TxReset) begin if(TxReset) BlockTxDone <= 1'b0; else if(TxCtrlStartFrm) BlockTxDone <= 1'b1; else if(TxStartFrmIn) BlockTxDone <= 1'b0; end always @ (posedge MTxClk) begin ControlEnd_q <= ControlEnd; TxCtrlStartFrm_q <= TxCtrlStartFrm; end assign IncrementDlyCrcCnt = CtrlMux & TxUsedDataIn & ~DlyCrcCnt[2]; always @ (posedge MTxClk or posedge TxReset) begin if(TxReset) DlyCrcCnt <= 4'h0; else if(ResetByteCnt) DlyCrcCnt <= 4'h0; else if(IncrementDlyCrcCnt) DlyCrcCnt <= DlyCrcCnt + 4'd1; end assign ResetByteCnt = TxReset | (~TxCtrlStartFrm & (TxDoneIn | TxAbortIn)); assign IncrementByteCnt = CtrlMux & (TxCtrlStartFrm & ~TxCtrlStartFrm_q & ~TxUsedDataIn | TxUsedDataIn & ~ControlEnd); assign IncrementByteCntBy2 = CtrlMux & TxCtrlStartFrm & (~TxCtrlStartFrm_q) & TxUsedDataIn; assign EnableCnt = (~DlyCrcEn | DlyCrcEn & (&DlyCrcCnt[1:0])); always @ (posedge MTxClk or posedge TxReset) begin if(TxReset) ByteCnt <= 6'h0; else if(ResetByteCnt) ByteCnt <= 6'h0; else if(IncrementByteCntBy2 & EnableCnt) ByteCnt <= (ByteCnt[5:0] ) + 6'd2; else if(IncrementByteCnt & EnableCnt) ByteCnt <= (ByteCnt[5:0] ) + 6'd1; end assign ControlEnd = ByteCnt[5:0] == 6'h22; always @ (ByteCnt or DlyCrcEn or MAC or TxPauseTV or DlyCrcCnt) begin case(ByteCnt) 6'h0: if(~DlyCrcEn | DlyCrcEn & (&DlyCrcCnt[1:0])) MuxedCtrlData[7:0] = 8'h01; else MuxedCtrlData[7:0] = 8'h0; 6'h2: MuxedCtrlData[7:0] = 8'h80; 6'h4: MuxedCtrlData[7:0] = 8'hC2; 6'h6: MuxedCtrlData[7:0] = 8'h00; 6'h8: MuxedCtrlData[7:0] = 8'h00; 6'hA: MuxedCtrlData[7:0] = 8'h01; 6'hC: MuxedCtrlData[7:0] = MAC[47:40]; 6'hE: MuxedCtrlData[7:0] = MAC[39:32]; 6'h10: MuxedCtrlData[7:0] = MAC[31:24]; 6'h12: MuxedCtrlData[7:0] = MAC[23:16]; 6'h14: MuxedCtrlData[7:0] = MAC[15:8]; 6'h16: MuxedCtrlData[7:0] = MAC[7:0]; 6'h18: MuxedCtrlData[7:0] = 8'h88; 6'h1A: MuxedCtrlData[7:0] = 8'h08; 6'h1C: MuxedCtrlData[7:0] = 8'h00; 6'h1E: MuxedCtrlData[7:0] = 8'h01; 6'h20: MuxedCtrlData[7:0] = TxPauseTV[15:8]; 6'h22: MuxedCtrlData[7:0] = TxPauseTV[7:0]; default: MuxedCtrlData[7:0] = 8'h0; endcase end always @ (posedge MTxClk or posedge TxReset) begin if(TxReset) ControlData[7:0] <= 8'h0; else if(~ByteCnt[0]) ControlData[7:0] <= MuxedCtrlData[7:0]; end endmodule module eth_L2_Uc_Wrapper (MTxClk, TxReset, TxDataIn, MAC, DMAC, TxData_wrapped_out, TxAbortIn, TxStartFrmIn, TxEndFrmOut_uc ,TxEndFrmIn ); input MTxClk; input TxReset; input [7:0] TxDataIn; input TxStartFrmIn; input [47:0] MAC ,DMAC; input TxAbortIn; input TxEndFrmIn; output TxEndFrmOut_uc; output [7:0] TxData_wrapped_out; wire [7:0] TxData_wrapped_out_wire; reg [7:0] TxData_wrapped_out; reg [7:0] ByteCnt; reg Divided_2_clk ; reg write_fifo; reg read_fifo; reg clear; reg [8:0] PreNib15State; wire TxBufferFull; wire TxBufferAlmostFull; wire TxBufferAlmostEmpty; wire TxBufferEmpty; wire [4:0] txfifo_cnt; reg StateCount , StateLeftinQ; initial begin StateCount = 1'b0; read_fifo = 1'b0; StateLeftinQ = 1'b0; PreNib15State = 1'b0; Divided_2_clk=0; end assign TxEndFrmOut_uc = TxBufferEmpty & StateLeftinQ; always @(posedge TxStartFrmIn) begin Divided_2_clk=1; end always@ (posedge MTxClk) begin Divided_2_clk <= MTxClk^Divided_2_clk; case ({TxStartFrmIn,TxEndFrmIn}) 2'b10: if (StateCount==0) StateCount<=1; 2'b01: if (StateCount==1) StateCount<=0; endcase case ({TxEndFrmIn,TxBufferEmpty}) 2'b10: if (StateLeftinQ==0) StateLeftinQ<=1; 2'b01: if (StateLeftinQ==1) StateLeftinQ<=0; endcase end always@ (negedge Divided_2_clk) begin if (StateCount | StateLeftinQ | TxStartFrmIn) begin case (ByteCnt) 7'h0: begin TxData_wrapped_out[7:0] <= DMAC[47:40]; read_fifo<=0; end 7'h1: begin TxData_wrapped_out[7:0] <= DMAC[39:32]; read_fifo<=0; end 7'h2: begin TxData_wrapped_out[7:0] <= DMAC[31:24]; read_fifo<=0; end 7'h3: begin TxData_wrapped_out[7:0] <= DMAC[23:16]; read_fifo<=0; end 7'h4: begin TxData_wrapped_out[7:0] <= DMAC[15:8]; read_fifo<=0; end 7'h5: begin TxData_wrapped_out[7:0] <= DMAC[7:0]; read_fifo<=0; end 7'h6: begin TxData_wrapped_out[7:0] <= MAC[47:40]; read_fifo<=0; end 7'h7: begin TxData_wrapped_out[7:0] <= MAC[39:32]; read_fifo<=0; end 7'h8: begin TxData_wrapped_out[7:0] <= MAC[31:24]; read_fifo<=0; end 7'h9: begin TxData_wrapped_out[7:0] <= MAC[23:16]; read_fifo<=0; end 7'ha: begin TxData_wrapped_out[7:0] <= MAC[15:8]; read_fifo<=0; end 7'hb: begin TxData_wrapped_out[7:0] <= MAC[7:0]; read_fifo<=0; end default: begin read_fifo<=1; TxData_wrapped_out<=TxData_wrapped_out_wire; end endcase end else begin ByteCnt <=0; read_fifo<=0; TxData_wrapped_out<=8'h0; PreNib15State <= 9'h0; end if (StateCount) begin PreNib15State <= PreNib15State + 1; end if (StateCount & PreNib15State >= 8) begin ByteCnt = ByteCnt+1; write_fifo <= 1; end else begin write_fifo<=0; end end eth_fifo #( .DATA_WIDTH(8), .DEPTH(32), .CNT_WIDTH(5)) L2_fifo ( .clk (Divided_2_clk), .reset (TxReset), .data_in (TxDataIn), .write (write_fifo), .read (read_fifo), .clear (TxFifoClear), .data_out (TxData_wrapped_out_wire), .full (TxBufferFull), .almost_full (TxBufferAlmostFull), .almost_empty (TxBufferAlmostEmpty), .empty (TxBufferEmpty), .cnt (txfifo_cnt) ); endmodule", "assertions_gpt_4o": "(TxReset) |-> (WillSendControlFrame == 0);\n(TxCtrlEndFrm & CtrlMux) |-> (WillSendControlFrame == 0);\n(TPauseRq & TxFlow) |-> (WillSendControlFrame == 1);\n(TxReset) |-> (TxCtrlStartFrm == 0);\n(TxUsedDataIn_q & CtrlMux) |-> (TxCtrlStartFrm == 0);\n(WillSendControlFrame & ~TxUsedDataOut & (TxDoneIn | TxAbortIn | TxStartFrmIn | (~TxUsedDataOutDetected))) |-> (TxCtrlStartFrm == 1);\n(TxReset) |-> (TxCtrlEndFrm == 0);\n(ControlEnd | ControlEnd_q) |-> (TxCtrlEndFrm == 1);\n(TxReset) |-> (CtrlMux == 0);\n(WillSendControlFrame & ~TxUsedDataOut) |-> (CtrlMux == 1);\n(TxDoneIn) |-> (CtrlMux == 0);\n(TxReset) |-> (SendingCtrlFrm == 0);\n(WillSendControlFrame & TxCtrlStartFrm) |-> (SendingCtrlFrm == 1);\n(TxDoneIn) |-> (SendingCtrlFrm == 0);\n(TxReset) |-> (TxUsedDataIn_q == 0);\n(TxReset) |-> (BlockTxDone == 0);\n(TxCtrlStartFrm) |-> (BlockTxDone == 1);\n(TxStartFrmIn) |-> (BlockTxDone == 0);\n(TxReset) |-> (DlyCrcCnt == 4'h0);\n(ResetByteCnt) |-> (DlyCrcCnt == 4'h0);\n(IncrementDlyCrcCnt) |-> (DlyCrcCnt == DlyCrcCnt + 4'd1);\n(TxReset) |-> (ByteCnt == 6'h0);\n(ResetByteCnt) |-> (ByteCnt == 6'h0);\n(IncrementByteCntBy2 & EnableCnt) |-> (ByteCnt == (ByteCnt[5:0]) + 6'd2);\n(IncrementByteCnt & EnableCnt) |-> (ByteCnt == (ByteCnt[5:0]) + 6'd1);\n(ByteCnt[5:0] == 6'h22) |-> (ControlEnd == 1);\n(TxBufferEmpty & StateLeftinQ) |-> (TxEndFrmOut_uc == 1);\n(StateCount | StateLeftinQ | TxStartFrmIn) |-> (ByteCnt == ByteCnt + 1);\n(StateCount & PreNib15State >= 8) |-> (ByteCnt == ByteCnt + 1);\n(StateCount) |-> (PreNib15State == PreNib15State + 1);"}, {"file_name": "eth_txcounters.v", "verilog_design": "`include \"timescale.v\" module eth_txcounters (StatePreamble, StateIPG, StateData, StatePAD, StateFCS, StateJam, StateBackOff, StateDefer, StateIdle, StartDefer, StartIPG, StartFCS, StartJam, StartBackoff, TxStartFrm, MTxClk, Reset, MinFL, MaxFL, HugEn, ExDfrEn, PacketFinished_q, DlyCrcEn, StateSFD, ByteCnt, NibCnt, ExcessiveDefer, NibCntEq7, NibCntEq15, MaxFrame, NibbleMinFl, DlyCrcCnt ); input MTxClk; input Reset; input StatePreamble; input StateIPG; input [1:0] StateData; input StatePAD; input StateFCS; input StateJam; input StateBackOff; input StateDefer; input StateIdle; input StateSFD; input StartDefer; input StartIPG; input StartFCS; input StartJam; input StartBackoff; input TxStartFrm; input [15:0] MinFL; input [15:0] MaxFL; input HugEn; input ExDfrEn; input PacketFinished_q; input DlyCrcEn; output [15:0] ByteCnt; output [15:0] NibCnt; output ExcessiveDefer; output NibCntEq7; output NibCntEq15; output MaxFrame; output NibbleMinFl; output [2:0] DlyCrcCnt; wire ExcessiveDeferCnt; wire ResetNibCnt; wire IncrementNibCnt; wire ResetByteCnt; wire IncrementByteCnt; wire ByteCntMax; reg [15:0] NibCnt; reg [15:0] ByteCnt; reg [2:0] DlyCrcCnt; assign IncrementNibCnt = StateIPG | StatePreamble | (|StateData) | StatePAD | StateFCS | StateJam | StateBackOff | StateDefer & ~ExcessiveDefer & TxStartFrm; assign ResetNibCnt = StateDefer & ExcessiveDefer & ~TxStartFrm | StatePreamble & NibCntEq15 | StateJam & NibCntEq7 | StateIdle | StartDefer | StartIPG | StartFCS | StartJam; always @ (posedge MTxClk or posedge Reset) begin if(Reset) NibCnt <= 16'h0; else begin if(ResetNibCnt) NibCnt <= 16'h0; else if(IncrementNibCnt) NibCnt <= NibCnt + 16'd1; end end assign NibCntEq7 = &NibCnt[2:0]; assign NibCntEq15 = &NibCnt[3:0]; assign NibbleMinFl = NibCnt >= (((MinFL-16'd4)<<1) -1); assign ExcessiveDeferCnt = NibCnt[13:0] == 14'h17b7; assign ExcessiveDefer = NibCnt[13:0] == 14'h17b7 & ~ExDfrEn; assign IncrementByteCnt = StateData[1] & ~ByteCntMax | StateBackOff & (&NibCnt[6:0]) | (StatePAD | StateFCS) & NibCnt[0] & ~ByteCntMax; assign ResetByteCnt = StartBackoff | StateIdle & TxStartFrm | PacketFinished_q; always @ (posedge MTxClk or posedge Reset) begin if(Reset) ByteCnt[15:0] <= 16'h0; else begin if(ResetByteCnt) ByteCnt[15:0] <= 16'h0; else if(IncrementByteCnt) ByteCnt[15:0] <= ByteCnt[15:0] + 16'd1; end end assign MaxFrame = ByteCnt[15:0] == MaxFL[15:0] & ~HugEn; assign ByteCntMax = &ByteCnt[15:0]; always @ (posedge MTxClk or posedge Reset) begin if(Reset) DlyCrcCnt <= 3'h0; else begin if(StateData[1] & DlyCrcCnt == 3'h4 | StartJam | PacketFinished_q) DlyCrcCnt <= 3'h0; else if(DlyCrcEn & (StateSFD | StateData[1] & (|DlyCrcCnt[2:0]))) DlyCrcCnt <= DlyCrcCnt + 3'd1; end end endmodule", "assertions_gpt_4o": "1. (Reset) |-> (NibCnt == 16'h0);\n2. (Reset) |-> (ByteCnt == 16'h0);\n3. (Reset) |-> (DlyCrcCnt == 3'h0);\n4. (ResetNibCnt) |-> (NibCnt == 16'h0);\n5. (IncrementNibCnt) |-> (NibCnt == $past(NibCnt) + 16'd1);\n6. (ResetByteCnt) |-> (ByteCnt == 16'h0);\n7. (IncrementByteCnt) |-> (ByteCnt == $past(ByteCnt) + 16'd1);\n8. (StateIPG | StatePreamble | (|StateData) | StatePAD | StateFCS | StateJam | StateBackOff | (StateDefer & ~ExcessiveDefer & TxStartFrm)) |-> (IncrementNibCnt);\n9. (StateDefer & ExcessiveDefer & ~TxStartFrm | StatePreamble & NibCntEq15 | StateJam & NibCntEq7 | StateIdle | StartDefer | StartIPG | StartFCS | StartJam) |-> (ResetNibCnt);\n10. (StateData[1] & ~ByteCntMax | StateBackOff & (&NibCnt[6:0]) | (StatePAD | StateFCS) & NibCnt[0] & ~ByteCntMax) |-> (IncrementByteCnt);\n11. (StartBackoff | StateIdle & TxStartFrm | PacketFinished_q) |-> (ResetByteCnt);\n12. (NibCnt[13:0] == 14'h17b7) |-> (ExcessiveDeferCnt);\n13. (NibCnt[13:0] == 14'h17b7 & ~ExDfrEn) |-> (ExcessiveDefer);\n14. (ByteCnt[15:0] == MaxFL[15:0] & ~HugEn) |-> (MaxFrame);\n15. (&ByteCnt[15:0]) |-> (ByteCntMax);\n16. (StateData[1] & DlyCrcCnt == 3'h4 | StartJam | PacketFinished_q) |-> (DlyCrcCnt == 3'h0);\n17. (DlyCrcEn & (StateSFD | StateData[1] & (|DlyCrcCnt[2:0]))) |-> (DlyCrcCnt == $past(DlyCrcCnt) + 3'd1)."}, {"file_name": "Broadcast_filter.v", "verilog_design": "module Broadcast_filter ( Reset , Clk , broadcast_ptr , broadcast_drop , broadcast_filter_en , broadcast_bucket_depth , broadcast_bucket_interval ); input Reset ; input Clk ; input broadcast_ptr ; output broadcast_drop ; input broadcast_filter_en ; input [15:0] broadcast_bucket_depth ; input [15:0] broadcast_bucket_interval ; reg [15:0] time_counter ; reg [15:0] broadcast_counter ; reg broadcast_drop ; always @ (posedge Clk or posedge Reset) if (Reset) time_counter <=0; else if (time_counter==broadcast_bucket_interval) time_counter <=0; else time_counter <=time_counter+1; always @ (posedge Clk or posedge Reset) if (Reset) broadcast_counter <=0; else if (time_counter==broadcast_bucket_interval) broadcast_counter <=0; else if (broadcast_ptr&&broadcast_counter!=broadcast_bucket_depth) broadcast_counter <=broadcast_counter+1; always @ (posedge Clk or posedge Reset) if (Reset) broadcast_drop <=0; else if(broadcast_filter_en&&broadcast_counter==broadcast_bucket_depth) broadcast_drop <=1; else broadcast_drop <=0; endmodule", "assertions_gpt_4o": "1. (Reset) |-> (time_counter == 0);\n2. (time_counter == broadcast_bucket_interval) |-> (time_counter == 0);\n3. (time_counter != broadcast_bucket_interval) |-> (time_counter == $past(time_counter) + 1);\n4. (Reset) |-> (broadcast_counter == 0);\n5. (time_counter == broadcast_bucket_interval) |-> (broadcast_counter == 0);\n6. (broadcast_ptr && broadcast_counter != broadcast_bucket_depth) |-> (broadcast_counter == $past(broadcast_counter) + 1);\n7. (Reset) |-> (broadcast_drop == 0);\n8. (broadcast_filter_en && broadcast_counter == broadcast_bucket_depth) |-> (broadcast_drop == 1);\n9. (!broadcast_filter_en || broadcast_counter != broadcast_bucket_depth) |-> (broadcast_drop == 0);"}, {"file_name": "eth_clockgen.v", "verilog_design": "`timescale 1ns/10ps module eth_clockgen(Clk, Reset, Divider, MdcEn, MdcEn_n, Mdc); parameter Tp=1; input Clk; input Reset; input [7:0] Divider; output Mdc; output MdcEn; output MdcEn_n; reg Mdc; reg [7:0] Counter; wire CountEq0; wire [7:0] CounterPreset; wire [7:0] TempDivider; assign TempDivider[7:0] = (Divider[7:0]<2)? 8'h02 : Divider[7:0]; assign CounterPreset[7:0] = (TempDivider[7:0]>>1) -1; always @ (posedge Clk or posedge Reset) begin if(Reset) Counter[7:0] <= #Tp 8'h1; else begin if(CountEq0) begin Counter[7:0] <= #Tp CounterPreset[7:0]; end else Counter[7:0] <= #Tp Counter - 8'h1; end end always @ (posedge Clk or posedge Reset) begin if(Reset) Mdc <= #Tp 1'b0; else begin if(CountEq0) Mdc <= #Tp ~Mdc; end end assign CountEq0 = Counter == 8'h0; assign MdcEn = CountEq0 & ~Mdc; assign MdcEn_n = CountEq0 & Mdc; endmodule", "assertions_gpt_4o": "1. (Reset) |-> (Counter == 8'h1);\n2. (Reset) |-> (Mdc == 1'b0);\n3. (CountEq0 && !Reset) |-> (Counter == CounterPreset);\n4. (!CountEq0 && !Reset) |-> (Counter == $past(Counter) - 8'h1);\n5. (CountEq0 && !Reset) |-> (Mdc == ~($past(Mdc)));\n6. (!CountEq0 && !Reset) |-> (Mdc == $past(Mdc));\n7. (CountEq0) |-> (MdcEn == ~Mdc);\n8. (CountEq0) |-> (MdcEn_n == Mdc);\n9. (MdcEn) |-> (CountEq0 && !Mdc);\n10. (MdcEn_n) |-> (CountEq0 && Mdc);"}, {"file_name": "eth_miim.v", "verilog_design": "`timescale 1ns/10ps `include \"eth_shiftreg.v\" `include \"eth_clockgen.v\" `include \"eth_outputcontrol.v\" module eth_miim ( Clk, Reset, Divider, NoPre, CtrlData, Rgad, Fiad, WCtrlData, RStat, ScanStat, Mdo, MdoEn, Mdi, Mdc, Busy, Prsd, LinkFail, Nvalid, WCtrlDataStart, RStatStart, UpdateMIIRX_DATAReg ); input Clk; input Reset; input [7:0] Divider; input [15:0] CtrlData; input [4:0] Rgad; input [4:0] Fiad; input NoPre; input WCtrlData; input RStat; input ScanStat; output Mdo; output MdoEn; input Mdi; output Mdc; output Busy; output LinkFail; output Nvalid; output [15:0] Prsd; output WCtrlDataStart; output RStatStart; output UpdateMIIRX_DATAReg; parameter Tp = 1; reg Nvalid; reg EndBusy_d; reg EndBusy; reg WCtrlData_q1; reg WCtrlData_q2; reg WCtrlData_q3; reg WCtrlDataStart; reg WCtrlDataStart_q; reg WCtrlDataStart_q1; reg WCtrlDataStart_q2; reg RStat_q1; reg RStat_q2; reg RStat_q3; reg RStatStart; reg RStatStart_q1; reg RStatStart_q2; reg ScanStat_q1; reg ScanStat_q2; reg SyncStatMdcEn; wire WriteDataOp; wire ReadStatusOp; wire ScanStatusOp; wire StartOp; wire EndOp; reg InProgress; reg InProgress_q1; reg InProgress_q2; reg InProgress_q3; reg WriteOp; reg [6:0] BitCounter; wire MdcFrame; wire [3:0] ByteSelect; wire MdcEn; wire ShiftedBit; wire LatchByte1_d2; wire LatchByte0_d2; reg LatchByte1_d; reg LatchByte0_d; reg [1:0] LatchByte; reg UpdateMIIRX_DATAReg; always @ (posedge Clk or posedge Reset) begin if(Reset) begin EndBusy_d <= #Tp 1'b0; EndBusy <= #Tp 1'b0; end else begin EndBusy_d <= #Tp ~InProgress_q2 & InProgress_q3; EndBusy <= #Tp EndBusy_d; end end always @ (posedge Clk or posedge Reset) begin if(Reset) UpdateMIIRX_DATAReg <= #Tp 0; else if(EndBusy & ~WCtrlDataStart_q) UpdateMIIRX_DATAReg <= #Tp 1; else UpdateMIIRX_DATAReg <= #Tp 0; end always @ (posedge Clk or posedge Reset) begin if(Reset) begin WCtrlData_q1 <= #Tp 1'b0; WCtrlData_q2 <= #Tp 1'b0; WCtrlData_q3 <= #Tp 1'b0; RStat_q1 <= #Tp 1'b0; RStat_q2 <= #Tp 1'b0; RStat_q3 <= #Tp 1'b0; ScanStat_q1 <= #Tp 1'b0; ScanStat_q2 <= #Tp 1'b0; SyncStatMdcEn <= #Tp 1'b0; end else begin WCtrlData_q1 <= #Tp WCtrlData; WCtrlData_q2 <= #Tp WCtrlData_q1; WCtrlData_q3 <= #Tp WCtrlData_q2; RStat_q1 <= #Tp RStat; RStat_q2 <= #Tp RStat_q1; RStat_q3 <= #Tp RStat_q2; ScanStat_q1 <= #Tp ScanStat; ScanStat_q2 <= #Tp ScanStat_q1; if(MdcEn) SyncStatMdcEn <= #Tp ScanStat_q2; end end always @ (posedge Clk or posedge Reset) begin if(Reset) begin WCtrlDataStart <= #Tp 1'b0; WCtrlDataStart_q <= #Tp 1'b0; RStatStart <= #Tp 1'b0; end else begin if(EndBusy) begin WCtrlDataStart <= #Tp 1'b0; RStatStart <= #Tp 1'b0; end else begin if(WCtrlData_q2 & ~WCtrlData_q3) WCtrlDataStart <= #Tp 1'b1; if(RStat_q2 & ~RStat_q3) RStatStart <= #Tp 1'b1; WCtrlDataStart_q <= #Tp WCtrlDataStart; end end end always @ (posedge Clk or posedge Reset) begin if(Reset) Nvalid <= #Tp 1'b0; else begin if(~InProgress_q2 & InProgress_q3) begin Nvalid <= #Tp 1'b0; end else begin if(ScanStat_q2 & ~SyncStatMdcEn) Nvalid <= #Tp 1'b1; end end end always @ (posedge Clk or posedge Reset) begin if(Reset) begin WCtrlDataStart_q1 <= #Tp 1'b0; WCtrlDataStart_q2 <= #Tp 1'b0; RStatStart_q1 <= #Tp 1'b0; RStatStart_q2 <= #Tp 1'b0; InProgress_q1 <= #Tp 1'b0; InProgress_q2 <= #Tp 1'b0; InProgress_q3 <= #Tp 1'b0; LatchByte0_d <= #Tp 1'b0; LatchByte1_d <= #Tp 1'b0; LatchByte <= #Tp 2'b00; end else begin if(MdcEn) begin WCtrlDataStart_q1 <= #Tp WCtrlDataStart; WCtrlDataStart_q2 <= #Tp WCtrlDataStart_q1; RStatStart_q1 <= #Tp RStatStart; RStatStart_q2 <= #Tp RStatStart_q1; LatchByte[0] <= #Tp LatchByte0_d; LatchByte[1] <= #Tp LatchByte1_d; LatchByte0_d <= #Tp LatchByte0_d2; LatchByte1_d <= #Tp LatchByte1_d2; InProgress_q1 <= #Tp InProgress; InProgress_q2 <= #Tp InProgress_q1; InProgress_q3 <= #Tp InProgress_q2; end end end assign WriteDataOp = WCtrlDataStart_q1 & ~WCtrlDataStart_q2; assign ReadStatusOp = RStatStart_q1 & ~RStatStart_q2; assign ScanStatusOp = SyncStatMdcEn & ~InProgress & ~InProgress_q1 & ~InProgress_q2; assign StartOp = WriteDataOp | ReadStatusOp | ScanStatusOp; reg Busy; always @ (posedge Clk or posedge Reset) if (Reset) Busy <=0; else if(WCtrlData | WCtrlDataStart | RStat | RStatStart | SyncStatMdcEn | EndBusy | InProgress | InProgress_q3 | Nvalid) Busy <=1; else Busy <=0; always @ (posedge Clk or posedge Reset) begin if(Reset) begin InProgress <= #Tp 1'b0; WriteOp <= #Tp 1'b0; end else begin if(MdcEn) begin if(StartOp) begin if(~InProgress) WriteOp <= #Tp WriteDataOp; InProgress <= #Tp 1'b1; end else begin if(EndOp) begin InProgress <= #Tp 1'b0; WriteOp <= #Tp 1'b0; end end end end end always @ (posedge Clk or posedge Reset) begin if(Reset) BitCounter[6:0] <= #Tp 7'h0; else begin if(MdcEn) begin if(InProgress) begin if(NoPre & ( BitCounter == 7'h0 )) BitCounter[6:0] <= #Tp 7'h21; else BitCounter[6:0] <= #Tp BitCounter[6:0] + 1'b1; end else BitCounter[6:0] <= #Tp 7'h0; end end end assign EndOp = BitCounter==63; assign ByteSelect[0] = InProgress & ((NoPre & (BitCounter == 7'h0)) | (~NoPre & (BitCounter == 7'h20))); assign ByteSelect[1] = InProgress & (BitCounter == 7'h28); assign ByteSelect[2] = InProgress & WriteOp & (BitCounter == 7'h30); assign ByteSelect[3] = InProgress & WriteOp & (BitCounter == 7'h38); assign LatchByte1_d2 = InProgress & ~WriteOp & BitCounter == 7'h37; assign LatchByte0_d2 = InProgress & ~WriteOp & BitCounter == 7'h3F; eth_clockgen clkgen(.Clk(Clk), .Reset(Reset), .Divider(Divider[7:0]), .MdcEn(MdcEn), .MdcEn_n(MdcEn_n), .Mdc(Mdc) ); eth_shiftreg shftrg(.Clk(Clk), .Reset(Reset), .MdcEn_n(MdcEn_n), .Mdi(Mdi), .Fiad(Fiad), .Rgad(Rgad), .CtrlData(CtrlData), .WriteOp(WriteOp), .ByteSelect(ByteSelect), .LatchByte(LatchByte), .ShiftedBit(ShiftedBit), .Prsd(Prsd), .LinkFail(LinkFail) ); eth_outputcontrol outctrl(.Clk(Clk), .Reset(Reset), .MdcEn_n(MdcEn_n), .InProgress(InProgress), .ShiftedBit(ShiftedBit), .BitCounter(BitCounter), .WriteOp(WriteOp), .NoPre(NoPre), .Mdo(Mdo), .MdoEn(MdoEn) ); endmodule", "assertions_gpt_4o": "1. (Reset) |-> (EndBusy_d == 0);\n2. (Reset) |-> (EndBusy == 0);\n3. (EndBusy & ~WCtrlDataStart_q) |-> (UpdateMIIRX_DATAReg == 1);\n4. (~EndBusy & ~WCtrlDataStart_q) |-> (UpdateMIIRX_DATAReg == 0);\n5. (Reset) |-> (WCtrlData_q1 == 0);\n6. (Reset) |-> (WCtrlData_q2 == 0);\n7. (Reset) |-> (WCtrlData_q3 == 0);\n8. (Reset) |-> (RStat_q1 == 0);\n9. (Reset) |-> (RStat_q2 == 0);\n10. (Reset) |-> (RStat_q3 == 0);\n11. (Reset) |-> (ScanStat_q1 == 0);\n12. (Reset) |-> (ScanStat_q2 == 0);\n13. (Reset) |-> (SyncStatMdcEn == 0);\n14. (MdcEn) |-> (SyncStatMdcEn == ScanStat_q2);\n15. (Reset) |-> (WCtrlDataStart == 0);\n16. (Reset) |-> (WCtrlDataStart_q == 0);\n17. (Reset) |-> (RStatStart == 0);\n18. (EndBusy) |-> (WCtrlDataStart == 0);\n19. (EndBusy) |-> (RStatStart == 0);\n20. (WCtrlData_q2 & ~WCtrlData_q3) |-> (WCtrlDataStart == 1);\n21. (RStat_q2 & ~RStat_q3) |-> (RStatStart == 1);\n22. (Reset) |-> (Nvalid == 0);\n23. (~InProgress_q2 & InProgress_q3) |-> (Nvalid == 0);\n24. (ScanStat_q2 & ~SyncStatMdcEn) |-> (Nvalid == 1);\n25. (Reset) |-> (WCtrlDataStart_q1 == 0);\n26. (Reset) |-> (WCtrlDataStart_q2 == 0);\n27. (Reset) |-> (RStatStart_q1 == 0);\n28. (Reset) |-> (RStatStart_q2 == 0);\n29. (Reset) |-> (InProgress_q1 == 0);\n30. (Reset) |-> (InProgress_q2 == 0);\n31. (Reset) |-> (InProgress_q3 == 0);\n32. (Reset) |-> (LatchByte0_d == 0);\n33. (Reset) |-> (LatchByte1_d == 0);\n34. (Reset) |-> (LatchByte == 2'b00);\n35. (MdcEn) |-> (WCtrlDataStart_q1 == WCtrlDataStart);\n36. (MdcEn) |-> (WCtrlDataStart_q2 == WCtrlDataStart_q1);\n37. (MdcEn) |-> (RStatStart_q1 == RStatStart);\n38. (MdcEn) |-> (RStatStart_q2 == RStatStart_q1);\n39. (MdcEn) |-> (LatchByte[0] == LatchByte0_d);\n40. (MdcEn) |-> (LatchByte[1] == LatchByte1_d);\n41. (MdcEn) |-> (LatchByte0_d == LatchByte0_d2);\n42. (MdcEn) |-> (LatchByte1_d == LatchByte1_d2);\n43. (MdcEn) |-> (InProgress_q1 == InProgress);\n44. (MdcEn) |-> (InProgress_q2 == InProgress_q1);\n45. (MdcEn) |-> (InProgress_q3 == InProgress_q2);\n46. (Reset) |-> (Busy == 0);\n47. (WCtrlData | WCtrlDataStart | RStat | RStatStart | SyncStatMdcEn | EndBusy | InProgress | InProgress_q3 | Nvalid) |-> (Busy == 1);\n48. (~(WCtrlData | WCtrlDataStart | RStat | RStatStart | SyncStatMdcEn | EndBusy | InProgress | InProgress_q3 | Nvalid)) |-> (Busy == 0);\n49. (Reset) |-> (InProgress == 0);\n50. (Reset) |-> (WriteOp == 0);\n51. (MdcEn & StartOp & ~InProgress) |-> (WriteOp == WriteDataOp);\n52. (MdcEn & StartOp) |-> (InProgress == 1);\n53. ("}, {"file_name": "eth_outputcontrol.v", "verilog_design": "`timescale 1ns/10ps module eth_outputcontrol(Clk, Reset, InProgress, ShiftedBit, BitCounter, WriteOp, NoPre, MdcEn_n, Mdo, MdoEn); parameter Tp = 1; input Clk; input Reset; input WriteOp; input NoPre; input InProgress; input ShiftedBit; input [6:0] BitCounter; input MdcEn_n; output Mdo; output MdoEn; wire SerialEn; reg MdoEn_2d; reg MdoEn_d; reg MdoEn; reg Mdo_2d; reg Mdo_d; reg Mdo; assign SerialEn = WriteOp & InProgress & ( BitCounter>31 | ( ( BitCounter == 0 ) & NoPre ) ) | ~WriteOp & InProgress & (( BitCounter>31 & BitCounter<46 ) | ( ( BitCounter == 0 ) & NoPre )); always @ (posedge Clk or posedge Reset) begin if(Reset) begin MdoEn_2d <= #Tp 1'b0; MdoEn_d <= #Tp 1'b0; MdoEn <= #Tp 1'b0; end else begin if(MdcEn_n) begin MdoEn_2d <= #Tp SerialEn | InProgress & BitCounter<32; MdoEn_d <= #Tp MdoEn_2d; MdoEn <= #Tp MdoEn_d; end end end always @ (posedge Clk or posedge Reset) begin if(Reset) begin Mdo_2d <= #Tp 1'b0; Mdo_d <= #Tp 1'b0; Mdo <= #Tp 1'b0; end else begin if(MdcEn_n) begin Mdo_2d <= #Tp ~SerialEn & BitCounter<32; Mdo_d <= #Tp ShiftedBit | Mdo_2d; Mdo <= #Tp Mdo_d; end end end endmodule", "assertions_gpt_4o": "(Reset) |-> (MdoEn_2d == 0);\n(Reset) |-> (MdoEn_d == 0);\n(Reset) |-> (MdoEn == 0);\n(Reset) |-> (Mdo_2d == 0);\n(Reset) |-> (Mdo_d == 0);\n(Reset) |-> (Mdo == 0);\n(MdcEn_n && SerialEn) |-> (MdoEn_2d == 1);\n(MdcEn_n && InProgress && BitCounter < 32) |-> (MdoEn_2d == 1);\n(MdcEn_n && MdoEn_2d) |-> (MdoEn_d == 1);\n(MdcEn_n && MdoEn_d) |-> (MdoEn == 1);\n(MdcEn_n && ~SerialEn && BitCounter < 32) |-> (Mdo_2d == 1);\n(MdcEn_n && ShiftedBit) |-> (Mdo_d == 1);\n(MdcEn_n && Mdo_2d) |-> (Mdo_d == 1);\n(MdcEn_n && Mdo_d) |-> (Mdo == 1);"}, {"file_name": "eth_shiftreg.v", "verilog_design": "`timescale 1ns/10ps module eth_shiftreg(Clk, Reset, MdcEn_n, Mdi, Fiad, Rgad, CtrlData, WriteOp, ByteSelect, LatchByte, ShiftedBit, Prsd, LinkFail); parameter Tp=1; input Clk; input Reset; input MdcEn_n; input Mdi; input [4:0] Fiad; input [4:0] Rgad; input [15:0]CtrlData; input WriteOp; input [3:0] ByteSelect; input [1:0] LatchByte; output ShiftedBit; output[15:0]Prsd; output LinkFail; reg [7:0] ShiftReg; reg [15:0]Prsd; reg LinkFail; always @ (posedge Clk or posedge Reset) begin if(Reset) begin ShiftReg[7:0] <= #Tp 8'h0; Prsd[15:0] <= #Tp 16'h0; LinkFail <= #Tp 1'b0; end else begin if(MdcEn_n) begin if(|ByteSelect) begin case (ByteSelect[3:0]) 4'h1 : ShiftReg[7:0] <= #Tp {2'b01, ~WriteOp, WriteOp, Fiad[4:1]}; 4'h2 : ShiftReg[7:0] <= #Tp {Fiad[0], Rgad[4:0], 2'b10}; 4'h4 : ShiftReg[7:0] <= #Tp CtrlData[15:8]; 4'h8 : ShiftReg[7:0] <= #Tp CtrlData[7:0]; default : ShiftReg[7:0] <= #Tp 8'h0; endcase end else begin ShiftReg[7:0] <= #Tp {ShiftReg[6:0], Mdi}; if(LatchByte[0]) begin Prsd[7:0] <= #Tp {ShiftReg[6:0], Mdi}; if(Rgad == 5'h01) LinkFail <= #Tp ~ShiftReg[1]; end else begin if(LatchByte[1]) Prsd[15:8] <= #Tp {ShiftReg[6:0], Mdi}; end end end end end assign ShiftedBit = ShiftReg[7]; endmodule", "assertions_gpt_4o": "1. (Reset) |-> (ShiftReg == 8'h0);\n2. (Reset) |-> (Prsd == 16'h0);\n3. (Reset) |-> (LinkFail == 1'b0);\n4. (MdcEn_n & |ByteSelect & ByteSelect == 4'h1) |-> (ShiftReg == {2'b01, ~WriteOp, WriteOp, Fiad[4:1]});\n5. (MdcEn_n & |ByteSelect & ByteSelect == 4'h2) |-> (ShiftReg == {Fiad[0], Rgad[4:0], 2'b10});\n6. (MdcEn_n & |ByteSelect & ByteSelect == 4'h4) |-> (ShiftReg == CtrlData[15:8]);\n7. (MdcEn_n & |ByteSelect & ByteSelect == 4'h8) |-> (ShiftReg == CtrlData[7:0]);\n8. (MdcEn_n & ~|ByteSelect) |-> (ShiftReg == {ShiftReg[6:0], Mdi});\n9. (MdcEn_n & ~|ByteSelect & LatchByte[0]) |-> (Prsd[7:0] == {ShiftReg[6:0], Mdi});\n10. (MdcEn_n & ~|ByteSelect & LatchByte[0] & Rgad == 5'h01) |-> (LinkFail == ~ShiftReg[1]);\n11. (MdcEn_n & ~|ByteSelect & LatchByte[1]) |-> (Prsd[15:8] == {ShiftReg[6:0], Mdi});\n12. (ShiftedBit) |-> (ShiftReg[7] == 1'b1);"}, {"file_name": "flow_ctrl.v", "verilog_design": "module flow_ctrl ( Reset , Clk , tx_pause_en , xoff_cpu , xon_cpu , pause_quanta , pause_quanta_val , pause_apply , pause_quanta_sub , xoff_gen , xoff_gen_complete , xon_gen , xon_gen_complete ); input Reset ; input Clk ; input tx_pause_en ; input xoff_cpu ; input xon_cpu ; input [15:0] pause_quanta ; input pause_quanta_val ; output pause_apply ; input pause_quanta_sub ; output xoff_gen ; input xoff_gen_complete ; output xon_gen ; input xon_gen_complete ; reg xoff_cpu_dl1 ; reg xoff_cpu_dl2 ; reg xon_cpu_dl1 ; reg xon_cpu_dl2 ; reg [15:0] pause_quanta_dl1 ; reg pause_quanta_val_dl1 ; reg pause_quanta_val_dl2 ; reg pause_apply ; reg xoff_gen ; reg xon_gen ; reg [15:0] pause_quanta_counter ; reg tx_pause_en_dl1 ; reg tx_pause_en_dl2 ; always @ (posedge Clk or posedge Reset) if (Reset) begin xoff_cpu_dl1 <=0; xoff_cpu_dl2 <=0; end else begin xoff_cpu_dl1 <=xoff_cpu; xoff_cpu_dl2 <=xoff_cpu_dl1; end always @ (posedge Clk or posedge Reset) if (Reset) begin xon_cpu_dl1 <=0; xon_cpu_dl2 <=0; end else begin xon_cpu_dl1 <=xon_cpu; xon_cpu_dl2 <=xon_cpu_dl1; end always @ (posedge Clk or posedge Reset) if (Reset) begin pause_quanta_dl1 <=0; end else begin pause_quanta_dl1 <=pause_quanta; end always @ (posedge Clk or posedge Reset) if (Reset) begin pause_quanta_val_dl1 <=0; pause_quanta_val_dl2 <=0; end else begin pause_quanta_val_dl1 <=pause_quanta_val; pause_quanta_val_dl2 <=pause_quanta_val_dl1; end always @ (posedge Clk or posedge Reset) if (Reset) begin tx_pause_en_dl1 <=0; tx_pause_en_dl2 <=0; end else begin tx_pause_en_dl1 <=tx_pause_en; tx_pause_en_dl2 <=tx_pause_en_dl1; end always @ (posedge Clk or posedge Reset) if (Reset) xoff_gen <=0; else if (xoff_gen_complete) xoff_gen <=0; else if (xoff_cpu_dl1&&!xoff_cpu_dl2) xoff_gen <=1; always @ (posedge Clk or posedge Reset) if (Reset) xon_gen <=0; else if (xon_gen_complete) xon_gen <=0; else if (xon_cpu_dl1&&!xon_cpu_dl2) xon_gen <=1; always @ (posedge Clk or posedge Reset) if (Reset) pause_quanta_counter <=0; else if(pause_quanta_val_dl1&&!pause_quanta_val_dl2) pause_quanta_counter <=pause_quanta_dl1; else if(pause_quanta_sub&&pause_quanta_counter!=0) pause_quanta_counter <=pause_quanta_counter-1; always @ (posedge Clk or posedge Reset) if (Reset) pause_apply <=0; else if(pause_quanta_counter==0) pause_apply <=0; else if (tx_pause_en_dl2) pause_apply <=1; endmodule", "assertions_gpt_4o": "1. (xoff_gen_complete) |-> (xoff_gen == 0);\n2. (xoff_cpu_dl1 && !xoff_cpu_dl2) |-> (xoff_gen == 1);\n3. (xon_gen_complete) |-> (xon_gen == 0);\n4. (xon_cpu_dl1 && !xon_cpu_dl2) |-> (xon_gen == 1);\n5. (pause_quanta_val_dl1 && !pause_quanta_val_dl2) |-> (pause_quanta_counter == pause_quanta_dl1);\n6. (pause_quanta_sub && pause_quanta_counter != 0) |-> (pause_quanta_counter == $past(pause_quanta_counter) - 1);\n7. (pause_quanta_counter == 0) |-> (pause_apply == 0);\n8. (tx_pause_en_dl2) |-> (pause_apply == 1);\n9. (Reset) |-> (xoff_cpu_dl1 == 0 && xoff_cpu_dl2 == 0);\n10. (Reset) |-> (xon_cpu_dl1 == 0 && xon_cpu_dl2 == 0);\n11. (Reset) |-> (pause_quanta_dl1 == 0);\n12. (Reset) |-> (pause_quanta_val_dl1 == 0 && pause_quanta_val_dl2 == 0);\n13. (Reset) |-> (tx_pause_en_dl1 == 0 && tx_pause_en_dl2 == 0);\n14. (Reset) |-> (xoff_gen == 0);\n15. (Reset) |-> (xon_gen == 0);\n16. (Reset) |-> (pause_quanta_counter == 0);\n17. (Reset) |-> (pause_apply == 0);"}, {"file_name": "MAC_rx_ctrl.v", "verilog_design": "module MAC_rx_ctrl ( Reset , Clk , MCrs_dv , MRxD , MRxErr , CRC_en , CRC_init , CRC_err , MAC_add_en , MAC_rx_add_chk_err , broadcast_ptr , broadcast_drop , pause_quanta , pause_quanta_val , Fifo_data , Fifo_data_en , Fifo_data_err , Fifo_data_end , Fifo_full , Rx_pkt_type_rmon , Rx_pkt_length_rmon , Rx_apply_rmon , Rx_pkt_err_type_rmon , RX_IFG_SET , RX_MAX_LENGTH, RX_MIN_LENGTH ); input Reset ; input Clk ; input MCrs_dv ; input [7:0] MRxD ; input MRxErr ; output CRC_en ; output CRC_init; input CRC_err ; output MAC_add_en ; input MAC_rx_add_chk_err ; output broadcast_ptr ; input broadcast_drop ; output [15:0] pause_quanta ; output pause_quanta_val ; output [7:0] Fifo_data ; output Fifo_data_en ; output Fifo_data_err ; output Fifo_data_end ; input Fifo_full; output [15:0] Rx_pkt_length_rmon ; output Rx_apply_rmon ; output [2:0] Rx_pkt_err_type_rmon ; output [2:0] Rx_pkt_type_rmon ; input [5:0] RX_IFG_SET ; input [15:0] RX_MAX_LENGTH ; input [6:0] RX_MIN_LENGTH ; parameter State_idle =4'd00; parameter State_preamble =4'd01; parameter State_SFD =4'd02; parameter State_data =4'd03; parameter State_checkCRC =4'd04; parameter State_OkEnd =4'd07; parameter State_drop =4'd08; parameter State_ErrEnd =4'd09; parameter State_CRCErrEnd =4'd10; parameter State_FFFullDrop =4'd11; parameter State_FFFullErrEnd =4'd12; parameter State_IFG =4'd13; parameter Pause_idle =4'd0; parameter Pause_pre_syn =4'd1; parameter Pause_quanta_hi =4'd2; parameter Pause_quanta_lo =4'd3; parameter Pause_syn =4'd4; reg [3:0] Current_state ; reg [3:0] Next_state; reg [3:0] Pause_current ; reg [3:0] Pause_next; reg [5:0] IFG_counter; reg Crs_dv ; reg [7:0] RxD ; reg [7:0] RxD_dl1 ; reg RxErr ; reg [15:0] Frame_length_counter; reg Too_long; reg Too_short; reg Fifo_data_en; reg Fifo_data_end; reg Fifo_data_err; reg CRC_en; reg CRC_init; reg Rx_apply_rmon; reg Rx_apply_rmon_tmp; reg Rx_apply_rmon_tmp_pl1; reg [2:0] Rx_pkt_err_type_rmon; reg MAC_add_en; reg [2:0] Rx_pkt_type_rmon; reg [7:0] pause_quanta_h ; reg [15:0] pause_quanta ; reg pause_quanta_val ; reg pause_quanta_val_tmp; reg pause_frame_ptr ; reg broadcast_ptr ; always @ (posedge Reset or posedge Clk) if (Reset) begin Crs_dv <=0; RxD <=0; RxErr <=0; end else begin Crs_dv <=MCrs_dv ; RxD <=MRxD ; RxErr <=MRxErr ; end always @ (posedge Reset or posedge Clk) if (Reset) RxD_dl1 <=0; else RxD_dl1 <=RxD; always @ (posedge Reset or posedge Clk) if (Reset) Current_state <=State_idle; else Current_state <=Next_state; always @ (*) case (Current_state) State_idle: if (Crs_dv&&RxD==8'h55) Next_state =State_preamble; else Next_state =Current_state; State_preamble: if (!Crs_dv) Next_state =State_ErrEnd; else if (RxErr) Next_state =State_drop; else if (RxD==8'hd5) Next_state =State_SFD; else if (RxD==8'h55) Next_state =Current_state; else Next_state =State_drop; State_SFD: if (!Crs_dv) Next_state =State_ErrEnd; else if (RxErr) Next_state =State_drop; else Next_state =State_data; State_data: if (!Crs_dv&&!Too_short&&!Too_long) Next_state =State_checkCRC; else if (!Crs_dv&&(Too_short||Too_long)) Next_state =State_ErrEnd; else if (Fifo_full) Next_state =State_FFFullErrEnd; else if (RxErr||MAC_rx_add_chk_err||Too_long||broadcast_drop) Next_state =State_drop; else Next_state =State_data; State_checkCRC: if (CRC_err) Next_state =State_CRCErrEnd; else Next_state =State_OkEnd; State_drop: if (!Crs_dv) Next_state =State_ErrEnd; else Next_state =Current_state; State_OkEnd: Next_state =State_IFG; State_ErrEnd: Next_state =State_IFG; State_CRCErrEnd: Next_state =State_IFG; State_FFFullDrop: if (!Crs_dv) Next_state =State_IFG; else Next_state =Current_state; State_FFFullErrEnd: Next_state =State_FFFullDrop; State_IFG: if (IFG_counter==RX_IFG_SET-4) Next_state =State_idle; else Next_state =Current_state; default: Next_state =State_idle; endcase always @ (posedge Reset or posedge Clk) if (Reset) IFG_counter <=0; else if (Current_state!=State_IFG) IFG_counter <=0; else IFG_counter <=IFG_counter + 1; assign Fifo_data =RxD_dl1; always @(Current_state) if (Current_state==State_data) Fifo_data_en =1; else Fifo_data_en =0; always @(Current_state) if (Current_state==State_ErrEnd||Current_state==State_OkEnd ||Current_state==State_CRCErrEnd||Current_state==State_FFFullErrEnd) Fifo_data_end =1; else Fifo_data_end =0; always @(Current_state) if (Current_state==State_ErrEnd||Current_state==State_CRCErrEnd||Current_state==State_FFFullErrEnd) Fifo_data_err =1; else Fifo_data_err =0; always @(Current_state) if (Current_state==State_data) CRC_en =1; else CRC_en =0; always @(Current_state) if (Current_state==State_SFD) CRC_init =1; else CRC_init =0; always @ (posedge Clk or posedge Reset) if (Reset) Frame_length_counter <=0; else if (Current_state==State_SFD) Frame_length_counter <=1; else if (Current_state==State_data) Frame_length_counter <=Frame_length_counter+ 1'b1; always @ (Frame_length_counter or RX_MIN_LENGTH) if (Frame_length_counter<RX_MIN_LENGTH) Too_short =1; else Too_short =0; always @ (*) if (Frame_length_counter>RX_MAX_LENGTH) Too_long =1; else Too_long =0; assign Rx_pkt_length_rmon=Frame_length_counter-1'b1; always @ (posedge Clk or posedge Reset) if (Reset) Rx_apply_rmon_tmp <=0; else if (Current_state==State_OkEnd||Current_state==State_ErrEnd ||Current_state==State_CRCErrEnd||Current_state==State_FFFullErrEnd) Rx_apply_rmon_tmp <=1; else Rx_apply_rmon_tmp <=0; always @ (posedge Clk or posedge Reset) if (Reset) Rx_apply_rmon_tmp_pl1 <=0; else Rx_apply_rmon_tmp_pl1 <=Rx_apply_rmon_tmp; always @ (posedge Clk or posedge Reset) if (Reset) Rx_apply_rmon <=0; else if (Current_state==State_OkEnd||Current_state==State_ErrEnd ||Current_state==State_CRCErrEnd||Current_state==State_FFFullErrEnd) Rx_apply_rmon <=1; else if (Rx_apply_rmon_tmp_pl1) Rx_apply_rmon <=0; always @ (posedge Clk or posedge Reset) if (Reset) Rx_pkt_err_type_rmon <=0; else if (Current_state==State_CRCErrEnd) Rx_pkt_err_type_rmon <=3'b001 ; else if (Current_state==State_FFFullErrEnd) Rx_pkt_err_type_rmon <=3'b010 ; else if (Current_state==State_ErrEnd) Rx_pkt_err_type_rmon <=3'b011 ; else if(Current_state==State_OkEnd) Rx_pkt_err_type_rmon <=3'b100 ; always @ (posedge Clk or posedge Reset) if (Reset) Rx_pkt_type_rmon <=0; else if (Current_state==State_OkEnd&&pause_frame_ptr) Rx_pkt_type_rmon <=3'b100 ; else if(Current_state==State_SFD&&Next_state==State_data) Rx_pkt_type_rmon <={1'b0,MRxD[7:6]}; always @ (posedge Clk or posedge Reset) if (Reset) broadcast_ptr <=0; else if(Current_state==State_IFG) broadcast_ptr <=0; else if(Current_state==State_SFD&&Next_state==State_data&&MRxD[7:6]==2'b11) broadcast_ptr <=1; always @ (Frame_length_counter or Fifo_data_en) if(Frame_length_counter>=1&&Frame_length_counter<=6) MAC_add_en <=Fifo_data_en; else MAC_add_en <=0; always @ (posedge Clk or posedge Reset) if (Reset) Pause_current <=Pause_idle; else Pause_current <=Pause_next; always @ (*) case (Pause_current) Pause_idle : if(Current_state==State_SFD) Pause_next =Pause_pre_syn; else Pause_next =Pause_current; Pause_pre_syn: case (Frame_length_counter) 16'd1: if (RxD_dl1==8'h01) Pause_next =Pause_current; else Pause_next =Pause_idle; 16'd2: if (RxD_dl1==8'h80) Pause_next =Pause_current; else Pause_next =Pause_idle; 16'd3: if (RxD_dl1==8'hc2) Pause_next =Pause_current; else Pause_next =Pause_idle; 16'd4: if (RxD_dl1==8'h00) Pause_next =Pause_current; else Pause_next =Pause_idle; 16'd5: if (RxD_dl1==8'h00) Pause_next =Pause_current; else Pause_next =Pause_idle; 16'd6: if (RxD_dl1==8'h01) Pause_next =Pause_current; else Pause_next =Pause_idle; 16'd13: if (RxD_dl1==8'h88) Pause_next =Pause_current; else Pause_next =Pause_idle; 16'd14: if (RxD_dl1==8'h08) Pause_next =Pause_current; else Pause_next =Pause_idle; 16'd15: if (RxD_dl1==8'h00) Pause_next =Pause_current; else Pause_next =Pause_idle; 16'd16: if (RxD_dl1==8'h01) Pause_next =Pause_quanta_hi; else Pause_next =Pause_idle; default: Pause_next =Pause_current; endcase Pause_quanta_hi : Pause_next =Pause_quanta_lo; Pause_quanta_lo : Pause_next =Pause_syn; Pause_syn : if (Current_state==State_IFG) Pause_next =Pause_idle; else Pause_next =Pause_current; default: Pause_next =Pause_idle; endcase always @ (posedge Clk or posedge Reset) if (Reset) pause_quanta_h <=0; else if(Pause_current==Pause_quanta_hi) pause_quanta_h <=RxD_dl1; always @ (posedge Clk or posedge Reset) if (Reset) pause_quanta <=0; else if(Pause_current==Pause_quanta_lo) pause_quanta <={pause_quanta_h,RxD_dl1}; always @ (posedge Clk or posedge Reset) if (Reset) pause_quanta_val_tmp <=0; else if(Current_state==State_OkEnd&&Pause_current==Pause_syn) pause_quanta_val_tmp <=1; else pause_quanta_val_tmp <=0; always @ (posedge Clk or posedge Reset) if (Reset) pause_quanta_val <=0; else if(Current_state==State_OkEnd&&Pause_current==Pause_syn||pause_quanta_val_tmp) pause_quanta_val <=1; else pause_quanta_val <=0; always @ (posedge Clk or posedge Reset) if (Reset) pause_frame_ptr <=0; else if(Pause_current==Pause_syn) pause_frame_ptr <=1; else pause_frame_ptr <=0; endmodule", "assertions_gpt_4o": "(Current_state == State_idle && Crs_dv && RxD == 8'h55) |-> (Next_state == State_preamble);\n(Current_state == State_preamble && !Crs_dv) |-> (Next_state == State_ErrEnd);\n(Current_state == State_preamble && RxErr) |-> (Next_state == State_drop);\n(Current_state == State_preamble && RxD == 8'hd5) |-> (Next_state == State_SFD);\n(Current_state == State_preamble && RxD == 8'h55) |-> (Next_state == Current_state);\n(Current_state == State_preamble && !(Crs_dv || RxErr || RxD == 8'hd5 || RxD == 8'h55)) |-> (Next_state == State_drop);\n(Current_state == State_SFD && !Crs_dv) |-> (Next_state == State_ErrEnd);\n(Current_state == State_SFD && RxErr) |-> (Next_state == State_drop);\n(Current_state == State_SFD && !(RxErr || !Crs_dv)) |-> (Next_state == State_data);\n(Current_state == State_data && !Crs_dv && !Too_short && !Too_long) |-> (Next_state == State_checkCRC);\n(Current_state == State_data && !Crs_dv && (Too_short || Too_long)) |-> (Next_state == State_ErrEnd);\n(Current_state == State_data && Fifo_full) |-> (Next_state == State_FFFullErrEnd);\n(Current_state == State_data && (RxErr || MAC_rx_add_chk_err || Too_long || broadcast_drop)) |-> (Next_state == State_drop);\n(Current_state == State_data && !(Fifo_full || RxErr || MAC_rx_add_chk_err || Too_long || broadcast_drop || (!Crs_dv && (Too_short || Too_long)) || (!Crs_dv && !Too_short && !Too_long))) |-> (Next_state == State_data);\n(Current_state == State_checkCRC && CRC_err) |-> (Next_state == State_CRCErrEnd);\n(Current_state == State_checkCRC && !CRC_err) |-> (Next_state == State_OkEnd);\n(Current_state == State_drop && !Crs_dv) |-> (Next_state == State_ErrEnd);\n(Current_state == State_drop && Crs_dv) |-> (Next_state == Current_state);\n(Current_state == State_OkEnd) |-> (Next_state == State_IFG);\n(Current_state == State_ErrEnd) |-> (Next_state == State_IFG);\n(Current_state == State_CRCErrEnd) |-> (Next_state == State_IFG);\n(Current_state == State_FFFullDrop && !Crs_dv) |-> (Next_state == State_IFG);\n(Current_state == State_FFFullDrop && Crs_dv) |-> (Next_state == Current_state);\n(Current_state == State_FFFullErrEnd) |-> (Next_state == State_FFFullDrop);\n(Current_state == State_IFG && IFG_counter == RX_IFG_SET - 4) |-> (Next_state == State_idle);\n(Current_state == State_IFG && IFG_counter != RX_IFG_SET - 4) |-> (Next_state == Current_state);\n(Current_state == State_data) |-> (Fifo_data_en == 1);\n(Current_state != State_data) |-> (Fifo_data_en == 0);\n(Current_state == State_ErrEnd || Current_state == State_OkEnd || Current_state == State_CRCErrEnd || Current_state == State_FFFullErrEnd) |-> (Fifo_data_end == 1);\n(!(Current_state == State_ErrEnd || Current_state == State_OkEnd || Current_state == State_CRCErrEnd || Current_state == State_FFFullErrEnd)) |-> (Fifo_data_end == 0);\n(Current_state == State_ErrEnd || Current_state == State_CRCErrEnd || Current_state == State_FFFullErrEnd) |-> (Fifo_data_err == 1);\n(!(Current_state == State_ErrEnd || Current_state == State_CRCErrEnd || Current_state == State_FFFullErrEnd)) |-> (Fifo_data_err == 0);\n(Current_state == State_data) |-> (CRC_en == 1);\n(Current_state != State_data) |-> (CRC_en == 0);\n(Current_state == State_SFD) |-> (CRC_init == 1);\n(Current_state != State_SFD) |-> (CRC_init == 0);\n(Current_state == State_SFD) |-> (Frame_length_counter == 1);\n(Current_state == State_data) |-> (Frame_length_counter == Frame_length_counter + 1);\n(Frame_length_counter < RX_MIN_LENGTH) |-> (Too_short == 1);\n(Frame_length_counter >= RX_MIN_LENGTH) |-> (Too_short == 0);\n(Frame_length_counter > RX_MAX_LENGTH) |"}, {"file_name": "MAC_tx_Ctrl.v", "verilog_design": "module MAC_tx_ctrl ( Reset , Clk , CRC_init , Frame_data , Data_en , CRC_rd , CRC_end , CRC_out , Random_init , RetryCnt , Random_time_meet , pause_apply , pause_quanta_sub , xoff_gen , xoff_gen_complete , xon_gen , xon_gen_complete , Fifo_data , Fifo_rd , Fifo_eop , Fifo_da , Fifo_rd_finish , Fifo_rd_retry , Fifo_ra , Fifo_data_err_empty , Fifo_data_err_full , TxD , TxEn , CRS , MAC_tx_addr_rd , MAC_tx_addr_data , MAC_tx_addr_init , Tx_pkt_type_rmon , Tx_pkt_length_rmon , Tx_apply_rmon , Tx_pkt_err_type_rmon, pause_frame_send_en , pause_quanta_set , MAC_tx_add_en , FullDuplex , MaxRetry , IFGset ); input Reset ; input Clk ; output CRC_init ; output [7:0] Frame_data ; output Data_en ; output CRC_rd ; input CRC_end ; input [7:0] CRC_out ; output Random_init ; output [3:0] RetryCnt ; input Random_time_meet ; input pause_apply ; output pause_quanta_sub ; input xoff_gen ; output xoff_gen_complete ; input xon_gen ; output xon_gen_complete ; input [7:0] Fifo_data ; output Fifo_rd ; input Fifo_eop ; input Fifo_da ; output Fifo_rd_finish ; output Fifo_rd_retry ; input Fifo_ra ; input Fifo_data_err_empty ; input Fifo_data_err_full ; output [7:0] TxD ; output TxEn ; input CRS ; output MAC_tx_addr_init ; output MAC_tx_addr_rd ; input [7:0] MAC_tx_addr_data ; output [2:0] Tx_pkt_type_rmon ; output [15:0] Tx_pkt_length_rmon ; output Tx_apply_rmon ; output [2:0] Tx_pkt_err_type_rmon; input pause_frame_send_en ; input [15:0] pause_quanta_set ; input MAC_tx_add_en ; input FullDuplex ; input [3:0] MaxRetry ; input [5:0] IFGset ; parameter StateIdle =4'd00; parameter StatePreamble =4'd01; parameter StateSFD =4'd02; parameter StateData =4'd03; parameter StatePause =4'd04; parameter StatePAD =4'd05; parameter StateFCS =4'd06; parameter StateIFG =4'd07; parameter StateJam =4'd08; parameter StateBackOff =4'd09; parameter StateJamDrop =4'd10; parameter StateFFEmptyDrop =4'd11; parameter StateSwitchNext =4'd12; parameter StateDefer =4'd13; parameter StateSendPauseFrame =4'd14; reg [3:0] Current_state ; reg [3:0] Next_state; reg [5:0] IFG_counter; reg [4:0] Preamble_counter; reg [7:0] TxD_tmp ; reg TxEn_tmp ; reg [15:0] Tx_pkt_length_rmon ; reg Tx_apply_rmon ; reg Tx_apply_rmon_tmp ; reg Tx_apply_rmon_tmp_pl1; reg [2:0] Tx_pkt_err_type_rmon; reg [3:0] RetryCnt ; reg Random_init ; reg Fifo_rd_finish ; reg Fifo_rd_retry ; reg [7:0] TxD ; reg TxEn ; reg CRC_init ; reg Data_en ; reg CRC_rd ; reg Fifo_rd ; reg MAC_tx_addr_rd ; reg MAC_header_slot ; reg MAC_header_slot_tmp ; reg [2:0] Tx_pkt_type_rmon ; wire Collision ; reg MAC_tx_addr_init ; reg Src_MAC_ptr ; reg [7:0] IPLengthCounter ; reg [1:0] PADCounter ; reg [7:0] JamCounter ; reg PktDrpEvenPtr ; reg [7:0] pause_counter ; reg pause_quanta_sub ; reg pause_frame_send_en_dl1 ; reg [15:0] pause_quanta_set_dl1 ; reg xoff_gen_complete ; reg xon_gen_complete ; always @(posedge Clk or posedge Reset) if (Reset) begin pause_frame_send_en_dl1 <=0; pause_quanta_set_dl1 <=0; end else begin pause_frame_send_en_dl1 <=pause_frame_send_en ; pause_quanta_set_dl1 <=pause_quanta_set ; end assign Collision=TxEn&CRS; always @(posedge Clk or posedge Reset) if (Reset) pause_counter <=0; else if (Current_state!=StatePause) pause_counter <=0; else pause_counter <=pause_counter+1; always @(posedge Clk or posedge Reset) if (Reset) IPLengthCounter <=0; else if (Current_state==StateDefer) IPLengthCounter <=0; else if (IPLengthCounter!=8'hff&&(Current_state==StateData||Current_state==StateSendPauseFrame||Current_state==StatePAD)) IPLengthCounter <=IPLengthCounter+1; always @(posedge Clk or posedge Reset) if (Reset) PADCounter <=0; else if (Current_state!=StatePAD) PADCounter <=0; else PADCounter <=PADCounter+1; always @(posedge Clk or posedge Reset) if (Reset) Current_state <=StateDefer; else Current_state <=Next_state; always @ (*) case (Current_state) StateDefer: if ((FullDuplex)||(!FullDuplex&&!CRS)) Next_state=StateIFG; else Next_state=Current_state; StateIFG: if (!FullDuplex&&CRS) Next_state=StateDefer; else if ((FullDuplex&&IFG_counter==IFGset-4)||(!FullDuplex&&!CRS&&IFG_counter==IFGset-4)) Next_state=StateIdle; else Next_state=Current_state; StateIdle: if (!FullDuplex&&CRS) Next_state=StateDefer; else if (pause_apply) Next_state=StatePause; else if ((FullDuplex&&Fifo_ra)||(!FullDuplex&&!CRS&&Fifo_ra)||(pause_frame_send_en_dl1&&(xoff_gen||xon_gen))) Next_state=StatePreamble; else Next_state=Current_state; StatePause: if (pause_counter==512/8) Next_state=StateDefer; else Next_state=Current_state; StatePreamble: if (!FullDuplex&&Collision) Next_state=StateJam; else if ((FullDuplex&&Preamble_counter==6)||(!FullDuplex&&!Collision&&Preamble_counter==6)) Next_state=StateSFD; else Next_state=Current_state; StateSFD: if (!FullDuplex&&Collision) Next_state=StateJam; else if (pause_frame_send_en_dl1&&(xoff_gen||xon_gen)) Next_state=StateSendPauseFrame; else Next_state=StateData; StateSendPauseFrame: if (IPLengthCounter==17) Next_state=StatePAD; else Next_state=Current_state; StateData: if (!FullDuplex&&Collision) Next_state=StateJam; else if (Fifo_data_err_empty) Next_state=StateFFEmptyDrop; else if (Fifo_eop&&IPLengthCounter>=59) Next_state=StateFCS; else if (Fifo_eop) Next_state=StatePAD; else Next_state=StateData; StatePAD: if (!FullDuplex&&Collision) Next_state=StateJam; else if (IPLengthCounter>=59) Next_state=StateFCS; else Next_state=Current_state; StateJam: if (RetryCnt<=MaxRetry&&JamCounter==16) Next_state=StateBackOff; else if (RetryCnt>MaxRetry) Next_state=StateJamDrop; else Next_state=Current_state; StateBackOff: if (Random_time_meet) Next_state =StateDefer; else Next_state =Current_state; StateFCS: if (!FullDuplex&&Collision) Next_state =StateJam; else if (CRC_end) Next_state =StateSwitchNext; else Next_state =Current_state; StateFFEmptyDrop: if (Fifo_eop) Next_state =StateSwitchNext; else Next_state =Current_state; StateJamDrop: if (Fifo_eop) Next_state =StateSwitchNext; else Next_state =Current_state; StateSwitchNext: Next_state =StateDefer; default: Next_state =StateDefer; endcase always @ (posedge Clk or posedge Reset) if (Reset) JamCounter <=0; else if (Current_state!=StateJam) JamCounter <=0; else if (Current_state==StateJam) JamCounter <=JamCounter+1; always @ (posedge Clk or posedge Reset) if (Reset) RetryCnt <=0; else if (Current_state==StateSwitchNext) RetryCnt <=0; else if (Current_state==StateJam&&Next_state==StateBackOff) RetryCnt <=RetryCnt + 1; always @ (posedge Clk or posedge Reset) if (Reset) IFG_counter <=0; else if (Current_state!=StateIFG) IFG_counter <=0; else IFG_counter <=IFG_counter + 1; always @ (posedge Clk or posedge Reset) if (Reset) Preamble_counter <=0; else if (Current_state!=StatePreamble) Preamble_counter <=0; else Preamble_counter <=Preamble_counter+ 1; always @ (posedge Clk or posedge Reset) if (Reset) PktDrpEvenPtr <=0; else if(Current_state==StateJamDrop||Current_state==StateFFEmptyDrop) PktDrpEvenPtr <=~PktDrpEvenPtr; always @(Current_state) if (Current_state==StateSFD) CRC_init =1; else CRC_init =0; assign Frame_data=TxD_tmp; always @(Current_state) if (Current_state==StateData||Current_state==StateSendPauseFrame||Current_state==StatePAD) Data_en =1; else Data_en =0; always @(Current_state) if (Current_state==StateFCS) CRC_rd =1; else CRC_rd =0; always @(Current_state or Next_state) if (Current_state==StateJam&&Next_state==StateBackOff) Random_init =1; else Random_init =0; always @ (*) if (Current_state==StateData || Current_state==StateSFD&&!(pause_frame_send_en_dl1&&(xoff_gen||xon_gen)) || Current_state==StateJamDrop&&PktDrpEvenPtr|| Current_state==StateFFEmptyDrop&&PktDrpEvenPtr ) Fifo_rd =1; else Fifo_rd =0; always @ (Current_state) if (Current_state==StateSwitchNext) Fifo_rd_finish =1; else Fifo_rd_finish =0; always @ (Current_state) if (Current_state==StateJam) Fifo_rd_retry =1; else Fifo_rd_retry =0; always @(Current_state) if (Current_state==StatePreamble||Current_state==StateSFD|| Current_state==StateData||Current_state==StateSendPauseFrame|| Current_state==StateFCS||Current_state==StatePAD||Current_state==StateJam) TxEn_tmp =1; else TxEn_tmp =0; always @(*) case (Current_state) StatePreamble: TxD_tmp =8'h55; StateSFD: TxD_tmp =8'hd5; StateData: if (Src_MAC_ptr&&MAC_tx_add_en) TxD_tmp =MAC_tx_addr_data; else TxD_tmp =Fifo_data; StateSendPauseFrame: if (Src_MAC_ptr&&MAC_tx_add_en) TxD_tmp =MAC_tx_addr_data; else case (IPLengthCounter) 7'd0: TxD_tmp =8'h01; 7'd1: TxD_tmp =8'h80; 7'd2: TxD_tmp =8'hc2; 7'd3: TxD_tmp =8'h00; 7'd4: TxD_tmp =8'h00; 7'd5: TxD_tmp =8'h01; 7'd12: TxD_tmp =8'h88; 7'd13: TxD_tmp =8'h08; 7'd14: TxD_tmp =8'h00; 7'd15: TxD_tmp =8'h01; 7'd16: TxD_tmp =xon_gen?8'b0:pause_quanta_set_dl1[15:8]; 7'd17: TxD_tmp =xon_gen?8'b0:pause_quanta_set_dl1[7:0]; default:TxD_tmp =0; endcase StatePAD: TxD_tmp =8'h00; StateJam: TxD_tmp =8'h01; StateFCS: TxD_tmp =CRC_out; default: TxD_tmp =2'b0; endcase always @ (posedge Clk or posedge Reset) if (Reset) begin TxD <=0; TxEn <=0; end else begin TxD <=TxD_tmp; TxEn <=TxEn_tmp; end always @ (posedge Clk or posedge Reset) if (Reset) Tx_pkt_length_rmon <=0; else if (Current_state==StateSFD) Tx_pkt_length_rmon <=0; else if (Current_state==StateData||Current_state==StateSendPauseFrame||Current_state==StatePAD||Current_state==StateFCS) Tx_pkt_length_rmon <=Tx_pkt_length_rmon+1; always @ (posedge Clk or posedge Reset) if (Reset) Tx_apply_rmon_tmp <=0; else if ((Fifo_eop&&Current_state==StateJamDrop)|| (Fifo_eop&&Current_state==StateFFEmptyDrop)|| CRC_end) Tx_apply_rmon_tmp <=1; else Tx_apply_rmon_tmp <=0; always @ (posedge Clk or posedge Reset) if (Reset) Tx_apply_rmon_tmp_pl1 <=0; else Tx_apply_rmon_tmp_pl1 <=Tx_apply_rmon_tmp; always @ (posedge Clk or posedge Reset) if (Reset) Tx_apply_rmon <=0; else if ((Fifo_eop&&Current_state==StateJamDrop)|| (Fifo_eop&&Current_state==StateFFEmptyDrop)|| CRC_end) Tx_apply_rmon <=1; else if (Tx_apply_rmon_tmp_pl1) Tx_apply_rmon <=0; always @ (posedge Clk or posedge Reset) if (Reset) Tx_pkt_err_type_rmon <=0; else if(Fifo_eop&&Current_state==StateJamDrop) Tx_pkt_err_type_rmon <=3'b001; else if(Fifo_eop&&Current_state==StateFFEmptyDrop) Tx_pkt_err_type_rmon <=3'b010; else if(Fifo_eop&&Fifo_data_err_full) Tx_pkt_err_type_rmon <=3'b011; else if(CRC_end) Tx_pkt_err_type_rmon <=3'b100; always @ (posedge Clk or posedge Reset) if (Reset) MAC_header_slot_tmp <=0; else if(Current_state==StateSFD&&Next_state==StateData) MAC_header_slot_tmp <=1; else MAC_header_slot_tmp <=0; always @ (posedge Clk or posedge Reset) if (Reset) MAC_header_slot <=0; else MAC_header_slot <=MAC_header_slot_tmp; always @ (posedge Clk or posedge Reset) if (Reset) Tx_pkt_type_rmon <=0; else if (Current_state==StateSendPauseFrame) Tx_pkt_type_rmon <=3'b100; else if(MAC_header_slot) Tx_pkt_type_rmon <={1'b0,TxD[7:6]}; always @(Tx_pkt_length_rmon) if (Tx_pkt_length_rmon>=6&&Tx_pkt_length_rmon<=11) Src_MAC_ptr =1; else Src_MAC_ptr =0; always @ (posedge Clk or posedge Reset) if (Reset) MAC_tx_addr_rd <=0; else if ((Tx_pkt_length_rmon>=4&&Tx_pkt_length_rmon<=9)&&(MAC_tx_add_en||Current_state==StateSendPauseFrame)) MAC_tx_addr_rd <=1; else MAC_tx_addr_rd <=0; always @ (Tx_pkt_length_rmon or Fifo_rd) if ((Tx_pkt_length_rmon==3)&&Fifo_rd) MAC_tx_addr_init=1; else MAC_tx_addr_init=0; always @ (posedge Clk or posedge Reset) if (Reset) pause_quanta_sub <=0; else if(pause_counter==512/8) pause_quanta_sub <=1; else pause_quanta_sub <=0; always @ (posedge Clk or posedge Reset) if (Reset) xoff_gen_complete <=0; else if(Current_state==StateDefer&&xoff_gen) xoff_gen_complete <=1; else xoff_gen_complete <=0; always @ (posedge Clk or posedge Reset) if (Reset) xon_gen_complete <=0; else if(Current_state==StateDefer&&xon_gen) xon_gen_complete <=1; else xon_gen_complete <=0; endmodule", "assertions_gpt_4o": "(Current_state == StateDefer && FullDuplex) |-> (Next_state == StateIFG);\n(Current_state == StateDefer && !FullDuplex && !CRS) |-> (Next_state == StateIFG);\n(Current_state == StateIFG && !FullDuplex && CRS) |-> (Next_state == StateDefer);\n(Current_state == StateIFG && FullDuplex && IFG_counter == IFGset-4) |-> (Next_state == StateIdle);\n(Current_state == StateIFG && !FullDuplex && !CRS && IFG_counter == IFGset-4) |-> (Next_state == StateIdle);\n(Current_state == StateIdle && !FullDuplex && CRS) |-> (Next_state == StateDefer);\n(Current_state == StateIdle && pause_apply) |-> (Next_state == StatePause);\n(Current_state == StateIdle && FullDuplex && Fifo_ra) |-> (Next_state == StatePreamble);\n(Current_state == StateIdle && !FullDuplex && !CRS && Fifo_ra) |-> (Next_state == StatePreamble);\n(Current_state == StateIdle && pause_frame_send_en_dl1 && (xoff_gen || xon_gen)) |-> (Next_state == StatePreamble);\n(Current_state == StatePause && pause_counter == 512/8) |-> (Next_state == StateDefer);\n(Current_state == StatePreamble && !FullDuplex && Collision) |-> (Next_state == StateJam);\n(Current_state == StatePreamble && FullDuplex && Preamble_counter == 6) |-> (Next_state == StateSFD);\n(Current_state == StatePreamble && !FullDuplex && !Collision && Preamble_counter == 6) |-> (Next_state == StateSFD);\n(Current_state == StateSFD && !FullDuplex && Collision) |-> (Next_state == StateJam);\n(Current_state == StateSFD && pause_frame_send_en_dl1 && (xoff_gen || xon_gen)) |-> (Next_state == StateSendPauseFrame);\n(Current_state == StateSFD && !(pause_frame_send_en_dl1 && (xoff_gen || xon_gen))) |-> (Next_state == StateData);\n(Current_state == StateSendPauseFrame && IPLengthCounter == 17) |-> (Next_state == StatePAD);\n(Current_state == StateData && !FullDuplex && Collision) |-> (Next_state == StateJam);\n(Current_state == StateData && Fifo_data_err_empty) |-> (Next_state == StateFFEmptyDrop);\n(Current_state == StateData && Fifo_eop && IPLengthCounter >= 59) |-> (Next_state == StateFCS);\n(Current_state == StateData && Fifo_eop && IPLengthCounter < 59) |-> (Next_state == StatePAD);\n(Current_state == StatePAD && !FullDuplex && Collision) |-> (Next_state == StateJam);\n(Current_state == StatePAD && IPLengthCounter >= 59) |-> (Next_state == StateFCS);\n(Current_state == StateJam && RetryCnt <= MaxRetry && JamCounter == 16) |-> (Next_state == StateBackOff);\n(Current_state == StateJam && RetryCnt > MaxRetry) |-> (Next_state == StateJamDrop);\n(Current_state == StateBackOff && Random_time_meet) |-> (Next_state == StateDefer);\n(Current_state == StateFCS && !FullDuplex && Collision) |-> (Next_state == StateJam);\n(Current_state == StateFCS && CRC_end) |-> (Next_state == StateSwitchNext);\n(Current_state == StateFFEmptyDrop && Fifo_eop) |-> (Next_state == StateSwitchNext);\n(Current_state == StateJamDrop && Fifo_eop) |-> (Next_state == StateSwitchNext);\n(Current_state == StateSwitchNext) |-> (Next_state == StateDefer);\n(Current_state == StateJam && Next_state == StateBackOff) |-> (Random_init == 1);\n(Current_state == StateData || (Current_state == StateSFD && !(pause_frame_send_en_dl1 && (xoff_gen || xon_gen))) || (Current_state == StateJamDrop && PktDrpEvenPtr) || (Current_state == StateFFEmptyDrop && PktDrpEvenPtr)) |-> (Fifo_rd == 1);\n(Current_state == StateSwitchNext) |-> (Fifo_rd_finish == 1);\n(Current_state == StateJam) |-> (Fifo_rd_retry == 1);\n(Current_state == StatePreamble || Current_state == StateSFD || Current_state == StateData || Current_state == StateSendPauseFrame || Current_state == StateFCS || Current_state == StatePAD || Current_state == StateJam) |-> (TxEn_tmp == 1);\n(Current_state == StateSFD) |-> (CRC_init == 1);\n(Current_state == StateData || Current_state == StateSendPauseFrame || Current"}, {"file_name": "Phy_sim.v", "verilog_design": "`timescale 1ns/100ps module Phy_sim ( input Gtx_clk , output Rx_clk , output Tx_clk , input Tx_er , input Tx_en , input [7:0] Txd , output Rx_er , output Rx_dv , output [7:0] Rxd , output Crs , output Col , input [2:0] Speed ); reg Clk_25m ; reg Clk_2_5m ; always begin #20 Clk_25m=0; #20 Clk_25m=1; end always begin #200 Clk_2_5m=0; #200 Clk_2_5m=1; end assign Rx_clk=Speed[2]?Gtx_clk:Speed[1]?Clk_25m:Speed[0]?Clk_2_5m:0; assign Tx_clk=Speed[2]?Gtx_clk:Speed[1]?Clk_25m:Speed[0]?Clk_2_5m:0; assign Rx_dv =Tx_en ; assign Rxd =Txd ; assign Rx_er =0 ; assign Crs =Tx_en ; assign Col =0 ; endmodule", "assertions_gpt_4o": "1. (Speed[2] == 1) |-> (Rx_clk == Gtx_clk);\n2. (Speed[1] == 1 & Speed[2] == 0) |-> (Rx_clk == Clk_25m);\n3. (Speed[0] == 1 & Speed[1] == 0 & Speed[2] == 0) |-> (Rx_clk == Clk_2_5m);\n4. (Speed == 3'b000) |-> (Rx_clk == 0);\n5. (Speed[2] == 1) |-> (Tx_clk == Gtx_clk);\n6. (Speed[1] == 1 & Speed[2] == 0) |-> (Tx_clk == Clk_25m);\n7. (Speed[0] == 1 & Speed[1] == 0 & Speed[2] == 0) |-> (Tx_clk == Clk_2_5m);\n8. (Speed == 3'b000) |-> (Tx_clk == 0);\n9. (Tx_en == 1) |-> (Rx_dv == 1);\n10. (Tx_en == 0) |-> (Rx_dv == 0);\n11. (Txd == Rxd);\n12. (Rx_er == 0);\n13. (Tx_en == 1) |-> (Crs == 1);\n14. (Tx_en == 0) |-> (Crs == 0);\n15. (Col == 0);"}, {"file_name": "Ramdon_gen.v", "verilog_design": "module Ramdon_gen( Reset , Clk , Init , RetryCnt , Random_time_meet ); input Reset ; input Clk ; input Init ; input [3:0] RetryCnt ; output Random_time_meet; reg [9:0] Random_sequence ; reg [9:0] Ramdom ; reg [9:0] Ramdom_counter ; reg [7:0] Slot_time_counter; reg Random_time_meet; always @ (posedge Clk or posedge Reset) if (Reset) Random_sequence <=0; else Random_sequence <={Random_sequence[8:0],~(Random_sequence[2]^Random_sequence[9])}; always @ (RetryCnt or Random_sequence) case (RetryCnt) 4'h0 : Ramdom={9'b0,Random_sequence[0]}; 4'h1 : Ramdom={8'b0,Random_sequence[1:0]}; 4'h2 : Ramdom={7'b0,Random_sequence[2:0]}; 4'h3 : Ramdom={6'b0,Random_sequence[3:0]}; 4'h4 : Ramdom={5'b0,Random_sequence[4:0]}; 4'h5 : Ramdom={4'b0,Random_sequence[5:0]}; 4'h6 : Ramdom={3'b0,Random_sequence[6:0]}; 4'h7 : Ramdom={2'b0,Random_sequence[7:0]}; 4'h8 : Ramdom={1'b0,Random_sequence[8:0]}; 4'h9 : Ramdom={ Random_sequence[9:0]}; default : Ramdom={ Random_sequence[9:0]}; endcase always @ (posedge Clk or posedge Reset) if (Reset) Slot_time_counter <=0; else if(Init) Slot_time_counter <=0; else if(!Random_time_meet) Slot_time_counter <=Slot_time_counter+1; always @ (posedge Clk or posedge Reset) if (Reset) Ramdom_counter <=0; else if (Init) Ramdom_counter <=Ramdom; else if (Ramdom_counter!=0&&Slot_time_counter==255) Ramdom_counter <=Ramdom_counter -1 ; always @ (posedge Clk or posedge Reset) if (Reset) Random_time_meet <=1; else if (Init) Random_time_meet <=0; else if (Ramdom_counter==0) Random_time_meet <=1; endmodule", "assertions_gpt_4o": "1. (Reset) |-> (Random_sequence == 0);\n2. (RetryCnt == 4'h0) |-> (Ramdom == {9'b0, Random_sequence[0]});\n3. (RetryCnt == 4'h1) |-> (Ramdom == {8'b0, Random_sequence[1:0]});\n4. (RetryCnt == 4'h2) |-> (Ramdom == {7'b0, Random_sequence[2:0]});\n5. (RetryCnt == 4'h3) |-> (Ramdom == {6'b0, Random_sequence[3:0]});\n6. (RetryCnt == 4'h4) |-> (Ramdom == {5'b0, Random_sequence[4:0]});\n7. (RetryCnt == 4'h5) |-> (Ramdom == {4'b0, Random_sequence[5:0]});\n8. (RetryCnt == 4'h6) |-> (Ramdom == {3'b0, Random_sequence[6:0]});\n9. (RetryCnt == 4'h7) |-> (Ramdom == {2'b0, Random_sequence[7:0]});\n10. (RetryCnt == 4'h8) |-> (Ramdom == {1'b0, Random_sequence[8:0]});\n11. (RetryCnt == 4'h9) |-> (Ramdom == Random_sequence);\n12. (Reset) |-> (Slot_time_counter == 0);\n13. (Init) |-> (Slot_time_counter == 0);\n14. (!Random_time_meet) |=> (Slot_time_counter == $past(Slot_time_counter) + 1);\n15. (Reset) |-> (Ramdom_counter == 0);\n16. (Init) |-> (Ramdom_counter == Ramdom);\n17. (Ramdom_counter != 0 && Slot_time_counter == 255) |=> (Ramdom_counter == $past(Ramdom_counter) - 1);\n18. (Reset) |-> (Random_time_meet == 1);\n19. (Init) |-> (Random_time_meet == 0);\n20. (Ramdom_counter == 0) |-> (Random_time_meet == 1);"}, {"file_name": "reg_int_sim.v", "verilog_design": "module reg_int_sim ( input Reset , input Clk_reg , output [4:0] Tx_Hwmark , output [4:0] Tx_Lwmark , output pause_frame_send_en , output [15:0] pause_quanta_set , output MAC_tx_add_en , output FullDuplex , output [3:0] MaxRetry , output [5:0] IFGset , output [7:0] MAC_tx_add_prom_data , output [2:0] MAC_tx_add_prom_add , output MAC_tx_add_prom_wr , output tx_pause_en , output xoff_cpu , output xon_cpu , output MAC_rx_add_chk_en , output [7:0] MAC_rx_add_prom_data , output [2:0] MAC_rx_add_prom_add , output MAC_rx_add_prom_wr , output broadcast_filter_en , output [15:0] broadcast_MAX , output RX_APPEND_CRC , output CRC_chk_en , output [5:0] RX_IFG_SET , output [15:0] RX_MAX_LENGTH , output [6:0] RX_MIN_LENGTH , output [5:0] CPU_rd_addr , output CPU_rd_apply , input CPU_rd_grant , input [31:0] CPU_rd_dout , output Line_loop_en , output [2:0] Speed , input Busy , input LinkFail , input Nvalid , input [15:0] Prsd , input UpdateMIIRX_DATAReg ); assign Tx_Hwmark =5'h1e; assign Tx_Lwmark =5'h19; assign pause_frame_send_en =0; assign pause_quanta_set =0; assign MAC_tx_add_en =0; assign FullDuplex =1; assign MaxRetry =2; assign IFGset =10; assign MAC_tx_add_prom_data =0; assign MAC_tx_add_prom_add =0; assign MAC_tx_add_prom_wr =0; assign tx_pause_en =0; assign xoff_cpu =0; assign xon_cpu =0; assign MAC_rx_add_chk_en =0; assign MAC_rx_add_prom_data =0; assign MAC_rx_add_prom_add =0; assign MAC_rx_add_prom_wr =0; assign broadcast_filter_en =0; assign broadcast_MAX =10; assign RX_APPEND_CRC =0; assign CRC_chk_en =1; assign RX_IFG_SET =10; assign RX_MAX_LENGTH =1518; assign RX_MIN_LENGTH =64; assign CPU_rd_addr =0; assign CPU_rd_apply =0; assign Line_loop_en =0; assign Speed =3'b001; endmodule", "assertions_gpt_4o": "(CPU_rd_apply == 1) |-> (CPU_rd_grant == 1);\n(CPU_rd_grant == 1) |-> (CPU_rd_apply == 1);\n(FullDuplex == 1) |-> (MaxRetry == 2);\n(Tx_Hwmark == 5'h1e) |-> (Tx_Lwmark == 5'h19);\n(pause_frame_send_en == 0) |-> (pause_quanta_set == 0);\n(MAC_tx_add_en == 0) |-> (MAC_tx_add_prom_wr == 0);\n(tx_pause_en == 0) |-> (xoff_cpu == 0);\n(xon_cpu == 0) |-> (MAC_rx_add_chk_en == 0);\n(broadcast_filter_en == 0) |-> (broadcast_MAX == 10);\n(RX_APPEND_CRC == 0) |-> (CRC_chk_en == 1);\n(RX_IFG_SET == 10) |-> (RX_MAX_LENGTH == 1518);\n(RX_MIN_LENGTH == 64) |-> (CPU_rd_addr == 0);\n(CPU_rd_apply == 0) |-> (Line_loop_en == 0);\n(Speed == 3'b001) |-> (Busy == 0);\n(Busy == 0) |-> (LinkFail == 0);\n(Nvalid == 0) |-> (Prsd == 0);\n(UpdateMIIRX_DATAReg == 0) |-> (CPU_rd_dout == 0);"}, {"file_name": "RMON_addr_gen.v", "verilog_design": "module RMON_addr_gen( Clk , Reset , Pkt_type_rmon , Pkt_length_rmon , Apply_rmon , Pkt_err_type_rmon , Reg_apply , Reg_addr , Reg_data , Reg_next , Reg_drop_apply ); input Clk ; input Reset ; input [2:0] Pkt_type_rmon ; input [15:0] Pkt_length_rmon ; input Apply_rmon ; input [2:0] Pkt_err_type_rmon ; output Reg_apply ; output [4:0] Reg_addr ; output [15:0] Reg_data ; input Reg_next ; output Reg_drop_apply ; parameter StateIdle =4'd0; parameter StatePktLength =4'd1; parameter StatePktNumber =4'd2; parameter StatePktType =4'd3; parameter StatePktRange =4'd4; reg [3:0] CurrentState ; reg [3:0] NextState; reg [2:0] PktTypeReg ; reg [15:0] PktLengthReg ; reg [2:0] PktErrTypeReg ; reg Reg_apply ; reg [4:0] Reg_addr ; reg [15:0] Reg_data ; reg Reg_drop_apply ; reg Apply_rmon_dl1; reg Apply_rmon_dl2; reg Apply_rmon_pulse; reg [2:0] Pkt_type_rmon_dl1 ; reg [15:0] Pkt_length_rmon_dl1 ; reg [2:0] Pkt_err_type_rmon_dl1 ; always @(posedge Clk or posedge Reset) if (Reset) begin Pkt_type_rmon_dl1 <=0; Pkt_length_rmon_dl1 <=0; Pkt_err_type_rmon_dl1 <=0; end else begin Pkt_type_rmon_dl1 <=Pkt_type_rmon ; Pkt_length_rmon_dl1 <=Pkt_length_rmon ; Pkt_err_type_rmon_dl1 <=Pkt_err_type_rmon ; end always @(posedge Clk or posedge Reset) if (Reset) begin Apply_rmon_dl1 <=0; Apply_rmon_dl2 <=0; end else begin Apply_rmon_dl1 <=Apply_rmon; Apply_rmon_dl2 <=Apply_rmon_dl1; end always @(Apply_rmon_dl1 or Apply_rmon_dl2) if (Apply_rmon_dl1&!Apply_rmon_dl2) Apply_rmon_pulse =1; else Apply_rmon_pulse =0; always @(posedge Clk or posedge Reset) if (Reset) begin PktTypeReg <=0; PktLengthReg <=0; PktErrTypeReg <=0; end else if (Apply_rmon_pulse&&CurrentState==StateIdle) begin PktTypeReg <=Pkt_type_rmon_dl1 ; PktLengthReg <=Pkt_length_rmon_dl1 ; PktErrTypeReg <=Pkt_err_type_rmon_dl1 ; end always @(posedge Clk or posedge Reset) if (Reset) CurrentState <=StateIdle; else CurrentState <=NextState; always @(CurrentState or Apply_rmon_pulse or Reg_next) case (CurrentState) StateIdle: if (Apply_rmon_pulse) NextState =StatePktLength; else NextState =StateIdle; StatePktLength: if (Reg_next) NextState =StatePktNumber; else NextState =CurrentState; StatePktNumber: if (Reg_next) NextState =StatePktType; else NextState =CurrentState; StatePktType: if (Reg_next) NextState =StatePktRange; else NextState =CurrentState; StatePktRange: if (Reg_next) NextState =StateIdle; else NextState =CurrentState; default: NextState =StateIdle; endcase always @ (CurrentState) if (CurrentState==StatePktLength||CurrentState==StatePktNumber|| CurrentState==StatePktType||CurrentState==StatePktRange) Reg_apply =1; else Reg_apply =0; always @ (posedge Clk or posedge Reset) if (Reset) Reg_addr <=0; else case (CurrentState) StatePktLength: Reg_addr <=5'd00; StatePktNumber: Reg_addr <=5'd01; StatePktType: case(PktTypeReg) 3'b011: Reg_addr <=5'd02; 3'b001: Reg_addr <=5'd03; 3'b100: Reg_addr <=5'd16; default: Reg_addr <=5'd04; endcase StatePktRange: case(PktErrTypeReg) 3'b001: Reg_addr <=5'd05; 3'b010: Reg_addr <=5'd06; 3'b011: Reg_addr <=5'd07; 3'b100: if (PktLengthReg<64) Reg_addr <=5'd08; else if (PktLengthReg==64) Reg_addr <=5'd09; else if (PktLengthReg<128) Reg_addr <=5'd10; else if (PktLengthReg<256) Reg_addr <=5'd11; else if (PktLengthReg<512) Reg_addr <=5'd12; else if (PktLengthReg<1024) Reg_addr <=5'd13; else if (PktLengthReg<1519) Reg_addr <=5'd14; else Reg_addr <=5'd15; default: Reg_addr <=5'd05; endcase default: Reg_addr <=5'd05; endcase always @ (CurrentState or PktLengthReg) case (CurrentState) StatePktLength: Reg_data =PktLengthReg; StatePktNumber: Reg_data =1; StatePktType: Reg_data =1; StatePktRange: Reg_data =1; default: Reg_data =0; endcase always @ (posedge Clk or posedge Reset) if (Reset) Reg_drop_apply <=0; else if (CurrentState!=StateIdle&&Apply_rmon_pulse) Reg_drop_apply <=1; else Reg_drop_apply <=0; endmodule", "assertions_gpt_4o": "1. (Reset) |-> (Pkt_type_rmon_dl1 == 0 && Pkt_length_rmon_dl1 == 0 && Pkt_err_type_rmon_dl1 == 0);\n2. (Reset) |-> (Apply_rmon_dl1 == 0 && Apply_rmon_dl2 == 0);\n3. (Apply_rmon_dl1 && !Apply_rmon_dl2) |-> (Apply_rmon_pulse == 1);\n4. (!Apply_rmon_dl1 || Apply_rmon_dl2) |-> (Apply_rmon_pulse == 0);\n5. (Reset) |-> (PktTypeReg == 0 && PktLengthReg == 0 && PktErrTypeReg == 0);\n6. (Apply_rmon_pulse && CurrentState == StateIdle) |-> (PktTypeReg == Pkt_type_rmon_dl1 && PktLengthReg == Pkt_length_rmon_dl1 && PktErrTypeReg == Pkt_err_type_rmon_dl1);\n7. (Reset) |-> (CurrentState == StateIdle);\n8. (CurrentState == StateIdle && Apply_rmon_pulse) |-> (NextState == StatePktLength);\n9. (CurrentState == StatePktLength && Reg_next) |-> (NextState == StatePktNumber);\n10. (CurrentState == StatePktNumber && Reg_next) |-> (NextState == StatePktType);\n11. (CurrentState == StatePktType && Reg_next) |-> (NextState == StatePktRange);\n12. (CurrentState == StatePktRange && Reg_next) |-> (NextState == StateIdle);\n13. (CurrentState == StatePktLength || CurrentState == StatePktNumber || CurrentState == StatePktType || CurrentState == StatePktRange) |-> (Reg_apply == 1);\n14. (!(CurrentState == StatePktLength || CurrentState == StatePktNumber || CurrentState == StatePktType || CurrentState == StatePktRange)) |-> (Reg_apply == 0);\n15. (Reset) |-> (Reg_addr == 0);\n16. (CurrentState == StatePktLength) |-> (Reg_addr == 5'd00);\n17. (CurrentState == StatePktNumber) |-> (Reg_addr == 5'd01);\n18. (CurrentState == StatePktType && PktTypeReg == 3'b011) |-> (Reg_addr == 5'd02);\n19. (CurrentState == StatePktType && PktTypeReg == 3'b001) |-> (Reg_addr == 5'd03);\n20. (CurrentState == StatePktType && PktTypeReg == 3'b100) |-> (Reg_addr == 5'd16);\n21. (CurrentState == StatePktType && !(PktTypeReg == 3'b011 || PktTypeReg == 3'b001 || PktTypeReg == 3'b100)) |-> (Reg_addr == 5'd04);\n22. (CurrentState == StatePktRange && PktErrTypeReg == 3'b001) |-> (Reg_addr == 5'd05);\n23. (CurrentState == StatePktRange && PktErrTypeReg == 3'b010) |-> (Reg_addr == 5'd06);\n24. (CurrentState == StatePktRange && PktErrTypeReg == 3'b011) |-> (Reg_addr == 5'd07);\n25. (CurrentState == StatePktRange && PktErrTypeReg == 3'b100 && PktLengthReg < 64) |-> (Reg_addr == 5'd08);\n26. (CurrentState == StatePktRange && PktErrTypeReg == 3'b100 && PktLengthReg == 64) |-> (Reg_addr == 5'd09);\n27. (CurrentState == StatePktRange && PktErrTypeReg == 3'b100 && PktLengthReg > 64 && PktLengthReg < 128) |-> (Reg_addr == 5'd10);\n28. (CurrentState == StatePktRange && PktErrTypeReg == 3'b100 && PktLengthReg >= 128 && PktLengthReg < 256) |-> (Reg_addr == 5'd11);\n29. (CurrentState == StatePktRange && PktErrTypeReg == 3'b100 && PktLengthReg >= 256 && PktLengthReg < 512) |-> (Reg_addr == 5'd12);\n30. (CurrentState == StatePktRange && PktErrTypeReg == 3'b100 && PktLengthReg >= 512 && PktLengthReg < 1024) |-> (Reg_addr == 5'd13);\n31. (CurrentState == StatePktRange && PktErrTypeReg == 3'b100 && PktLengthReg >= 1024 && PktLength"}, {"file_name": "RMON_ctrl.v", "verilog_design": "module RMON_CTRL ( Clk , Reset , Reg_apply_0 , Reg_addr_0 , Reg_data_0 , Reg_next_0 , Reg_apply_1 , Reg_addr_1 , Reg_data_1 , Reg_next_1 , Addra , Dina , Douta , Wea , CPU_rd_addr , CPU_rd_apply , CPU_rd_grant , CPU_rd_dout ); input Clk ; input Reset ; input Reg_apply_0 ; input [4:0] Reg_addr_0 ; input [15:0] Reg_data_0 ; output Reg_next_0 ; input Reg_apply_1 ; input [4:0] Reg_addr_1 ; input [15:0] Reg_data_1 ; output Reg_next_1 ; output [5:0] Addra ; output [31:0] Dina ; input [31:0] Douta ; output Wea ; input [5:0] CPU_rd_addr ; input CPU_rd_apply ; output CPU_rd_grant ; output [31:0] CPU_rd_dout ; parameter StateCPU =4'd00; parameter StateMAC0 =4'd01; parameter StateMAC1 =4'd02; reg [3:0] CurrentState ; reg [3:0] NextState; reg [3:0] CurrentState_reg; reg [4:0] StepCounter; reg [31:0] DoutaReg; reg [5:0] Addra ; reg [31:0] Dina; reg Reg_next_0 ; reg Reg_next_1 ; reg Write; reg Read; reg Pipeline; reg [31:0] CPU_rd_dout ; reg CPU_rd_apply_reg ; always @(posedge Clk or posedge Reset) if (Reset) CurrentState <=StateMAC0; else CurrentState <=NextState; always @(posedge Clk or posedge Reset) if (Reset) CurrentState_reg <=StateMAC0; else if(CurrentState!=StateCPU) CurrentState_reg <=CurrentState; always @(CurrentState or CPU_rd_apply_reg or Reg_apply_0 or CurrentState_reg or Reg_apply_1 or StepCounter ) case(CurrentState) StateMAC0: if(!Reg_apply_0&&CPU_rd_apply_reg) NextState =StateCPU; else if(!Reg_apply_0) NextState =StateMAC1; else NextState =CurrentState; StateMAC1: if(!Reg_apply_1&&CPU_rd_apply_reg) NextState =StateCPU; else if(!Reg_apply_1) NextState =StateMAC0; else NextState =CurrentState; StateCPU: if (StepCounter==3) case (CurrentState_reg) StateMAC0 :NextState =StateMAC0 ; StateMAC1 :NextState =StateMAC1 ; default :NextState =StateMAC0; endcase else NextState =CurrentState; default: NextState =StateMAC0; endcase always @(posedge Clk or posedge Reset) if (Reset) StepCounter <=0; else if(NextState!=CurrentState) StepCounter <=0; else if (StepCounter!=4'hf) StepCounter <=StepCounter + 1; always @(StepCounter) if( StepCounter==1||StepCounter==4|| StepCounter==7||StepCounter==10) Read =1; else Read =0; always @(StepCounter or CurrentState) if( StepCounter==2||StepCounter==5|| StepCounter==8||StepCounter==11) Pipeline =1; else Pipeline =0; always @(StepCounter or CurrentState) if( StepCounter==3||StepCounter==6|| StepCounter==9||StepCounter==12) Write =1; else Write =0; always @(posedge Clk or posedge Reset) if (Reset) DoutaReg <=0; else if (Read) DoutaReg <=Douta; always @(*) case(CurrentState) StateMAC0 : Addra={1'd0 ,Reg_addr_0 }; StateMAC1 : Addra={1'd1 ,Reg_addr_1 }; StateCPU: Addra=CPU_rd_addr; default: Addra=0; endcase always @(posedge Clk or posedge Reset) if (Reset) Dina <=0; else case(CurrentState) StateMAC0 : Dina<=Douta+Reg_data_0 ; StateMAC1 : Dina<=Douta+Reg_data_1 ; StateCPU: Dina<=0; default: Dina<=0; endcase assign Wea =Write; always @(CurrentState or Pipeline) if(CurrentState==StateMAC0) Reg_next_0 =Pipeline; else Reg_next_0 =0; always @(CurrentState or Pipeline) if(CurrentState==StateMAC1) Reg_next_1 =Pipeline; else Reg_next_1 =0; reg CPU_rd_apply_dl1; reg CPU_rd_apply_dl2; always @ (posedge Clk or posedge Reset) if (Reset) begin CPU_rd_apply_dl1 <=0; CPU_rd_apply_dl2 <=0; end else begin CPU_rd_apply_dl1 <=CPU_rd_apply; CPU_rd_apply_dl2 <=CPU_rd_apply_dl1; end always @ (posedge Clk or posedge Reset) if (Reset) CPU_rd_apply_reg <=0; else if (CPU_rd_apply_dl1&!CPU_rd_apply_dl2) CPU_rd_apply_reg <=1; else if (CurrentState==StateCPU&&Write) CPU_rd_apply_reg <=0; assign CPU_rd_grant =!CPU_rd_apply_reg; always @ (posedge Clk or posedge Reset) if (Reset) CPU_rd_dout <=0; else if (Pipeline&&CurrentState==StateCPU) CPU_rd_dout <=Douta; endmodule", "assertions_gpt_4o": "(CurrentState == StateMAC0 && !Reg_apply_0 && CPU_rd_apply_reg) |-> (NextState == StateCPU);\n(CurrentState == StateMAC0 && !Reg_apply_0 && !CPU_rd_apply_reg) |-> (NextState == StateMAC1);\n(CurrentState == StateMAC0 && Reg_apply_0) |-> (NextState == CurrentState);\n(CurrentState == StateMAC1 && !Reg_apply_1 && CPU_rd_apply_reg) |-> (NextState == StateCPU);\n(CurrentState == StateMAC1 && !Reg_apply_1 && !CPU_rd_apply_reg) |-> (NextState == StateMAC0);\n(CurrentState == StateMAC1 && Reg_apply_1) |-> (NextState == CurrentState);\n(CurrentState == StateCPU && StepCounter == 3 && CurrentState_reg == StateMAC0) |-> (NextState == StateMAC0);\n(CurrentState == StateCPU && StepCounter == 3 && CurrentState_reg == StateMAC1) |-> (NextState == StateMAC1);\n(CurrentState == StateCPU && StepCounter != 3) |-> (NextState == CurrentState);\n(Reset) |-> (CurrentState == StateMAC0);\n(Reset) |-> (CurrentState_reg == StateMAC0);\n(Reset) |-> (StepCounter == 0);\n(NextState != CurrentState) |-> (StepCounter == 0);\n(StepCounter != 4'hf) |-> (StepCounter == StepCounter + 1);\n(StepCounter == 1 || StepCounter == 4 || StepCounter == 7 || StepCounter == 10) |-> (Read == 1);\n(StepCounter != 1 && StepCounter != 4 && StepCounter != 7 && StepCounter != 10) |-> (Read == 0);\n(StepCounter == 2 || StepCounter == 5 || StepCounter == 8 || StepCounter == 11) |-> (Pipeline == 1);\n(StepCounter != 2 && StepCounter != 5 && StepCounter != 8 && StepCounter != 11) |-> (Pipeline == 0);\n(StepCounter == 3 || StepCounter == 6 || StepCounter == 9 || StepCounter == 12) |-> (Write == 1);\n(StepCounter != 3 && StepCounter != 6 && StepCounter != 9 && StepCounter != 12) |-> (Write == 0);\n(Read) |-> (DoutaReg == Douta);\n(CurrentState == StateMAC0) |-> (Addra == {1'd0, Reg_addr_0});\n(CurrentState == StateMAC1) |-> (Addra == {1'd1, Reg_addr_1});\n(CurrentState == StateCPU) |-> (Addra == CPU_rd_addr);\n(Reset) |-> (Dina == 0);\n(CurrentState == StateMAC0) |-> (Dina == Douta + Reg_data_0);\n(CurrentState == StateMAC1) |-> (Dina == Douta + Reg_data_1);\n(CurrentState == StateCPU) |-> (Dina == 0);\n(CurrentState == StateMAC0) |-> (Reg_next_0 == Pipeline);\n(CurrentState != StateMAC0) |-> (Reg_next_0 == 0);\n(CurrentState == StateMAC1) |-> (Reg_next_1 == Pipeline);\n(CurrentState != StateMAC1) |-> (Reg_next_1 == 0);\n(Reset) |-> (CPU_rd_apply_dl1 == 0 && CPU_rd_apply_dl2 == 0);\n(CPU_rd_apply_dl1 && !CPU_rd_apply_dl2) |-> (CPU_rd_apply_reg == 1);\n(CurrentState == StateCPU && Write) |-> (CPU_rd_apply_reg == 0);\n(Reset) |-> (CPU_rd_dout == 0);\n(Pipeline && CurrentState == StateCPU) |-> (CPU_rd_dout == Douta);\n(CPU_rd_grant) |-> (!CPU_rd_apply_reg);"}, {"file_name": "ack_counter.v", "verilog_design": "module ack_counter ( clock , reset , ready, tx_start , max_count, tx_ack ); input clock; input reset; input ready; input tx_start; input [15:0] max_count; output tx_ack; wire clock; wire reset; wire ready; wire tx_start; wire [15:0] max_count; reg tx_ack; reg start_count; reg start_count_del; reg [15:0] counter; always @ (reset or tx_start or counter or max_count) begin if (reset) begin start_count <= 0; end else if (tx_start) begin start_count <= 1; end else if ((counter == max_count) & !ready) begin start_count <= 0; end end always @ (posedge clock or posedge reset) begin if (reset) begin counter <= 0; end else if (counter == max_count) begin counter <= 0; end else if (start_count) begin counter <= counter + 1; end end always @ (posedge clock or posedge reset) begin if (reset) begin start_count_del <= 0; tx_ack <= 0; end else begin start_count_del <= start_count; tx_ack <= ~start_count & start_count_del; end end endmodule", "assertions_gpt_4o": "1. (reset) |-> (start_count == 0);\n2. (tx_start) |-> (start_count == 1);\n3. ((counter == max_count) & !ready) |-> (start_count == 0);\n4. (reset) |-> (counter == 0);\n5. (counter == max_count) |-> (counter == 0);\n6. (start_count) |-> (counter == counter + 1);\n7. (reset) |-> (start_count_del == 0);\n8. (reset) |-> (tx_ack == 0);\n9. (start_count_del) |-> (tx_ack == ~start_count);\n10. (start_count) |-> (start_count_del == start_count);"}, {"file_name": "counter.v", "verilog_design": "`timescale 100ps / 10ps module counter(clk, reset, load, en, value); input clk; input reset; input load; input en; parameter WIDTH = 8; output[WIDTH-1:0] value; reg [WIDTH-1:0] value; always @(posedge clk or posedge reset) if (reset) value <= 0; else begin if (load) value <= 0; else if (en) value <= value + 1; end endmodule", "assertions_gpt_4o": "1. (reset) |-> (value == 0);\n2. (load) |-> (value == 0);\n3. (en && !reset && !load) |=> (value == $past(value) + 1);\n4. (!en && !reset && !load) |=> (value == $past(value));\n5. (reset && load) |-> (value == 0);\n6. (reset && en) |-> (value == 0);\n7. (load && en) |-> (value == 0);\n8. (reset && !load && !en) |-> (value == 0);\n9. (load && !reset && !en) |-> (value == 0);\n10. (en && !reset && !load) |-> (value == $past(value) + 1);"}, {"file_name": "rxClkgen.v", "verilog_design": "`include \"timescale.v\" `include \"xgiga_define.v\" module rxClkgen(rxclk_in, reset, rxclk, rxclk_180, locked); input rxclk_in; input reset; output rxclk; output rxclk_180; output locked; wire rxclk; wire rxclk_180; assign rxclk = rxclk_in; assign rxclk_180 = ~rxclk; assign locked = ~reset; endmodule", "assertions_gpt_4o": "(locked == 1) |-> (reset == 0);\n(reset == 1) |-> (locked == 0);\n(rxclk == 1) |-> (rxclk_180 == 0);\n(rxclk == 0) |-> (rxclk_180 == 1);\n(rxclk_180 == 1) |-> (rxclk == 0);\n(rxclk_180 == 0) |-> (rxclk == 1);"}, {"file_name": "rxLinkFaultState.v", "verilog_design": "`include \"timescale.v\" `include \"xgiga_define.v\" module rxLinkFaultState(rxclk, reset, local_fault, remote_fault, link_fault); input rxclk; input reset; input local_fault; input remote_fault; output[1:0] link_fault; parameter TP =1; parameter IDLE = 0, LinkFaultDetect = 1, NewFaultType = 2, GetFault = 3; wire fault_type; wire get_one_fault; wire no_new_type; reg[2:0] linkstate, linkstate_next; reg[5:0] col_cnt; reg seq_cnt; reg[1:0] seq_type; reg[1:0] last_seq_type; reg[1:0] link_fault; reg reset_col_cnt; wire seq_cnt_3; wire col_cnt_64; assign fault_type = {local_fault, remote_fault}; assign get_one_fault = local_fault | remote_fault; assign no_new_type = (seq_type == last_seq_type); assign col_cnt_64 = & col_cnt; always@(posedge rxclk or posedge reset)begin if (reset) begin seq_type <=#TP 0; seq_cnt <=#TP 0; last_seq_type <=#TP 0; reset_col_cnt<= #TP 1; link_fault <=#TP 2'b00; linkstate<= #TP IDLE; end else begin seq_type <= #TP fault_type; last_seq_type <=#TP seq_type; case (linkstate) IDLE: begin linkstate <=#TP IDLE; reset_col_cnt <= #TP 1; seq_cnt <= #TP 0; link_fault <= #TP 2'b00; if (get_one_fault) linkstate<=#TP LinkFaultDetect; end LinkFaultDetect: begin linkstate <=#TP LinkFaultDetect; reset_col_cnt <=#TP 1; if (get_one_fault & no_new_type) begin if (seq_cnt) begin linkstate <=#TP IDLE; link_fault <=#TP seq_type; end else seq_cnt <=#TP seq_cnt + 1; end else if(~get_one_fault) begin reset_col_cnt <=#TP 0; if (col_cnt_64) linkstate <=#TP IDLE; end else if(get_one_fault & ~no_new_type) linkstate <=#TP NewFaultType; end NewFaultType: begin seq_cnt <=#TP 0; linkstate <=#TP LinkFaultDetect; reset_col_cnt<=#TP 1; end endcase end end always@(posedge rxclk or posedge reset) begin if (reset) col_cnt <=#TP 0; else if (reset_col_cnt) col_cnt <=#TP 0; else col_cnt <=#TP col_cnt + 1; end endmodule", "assertions_gpt_4o": "1. (reset) |-> (linkstate == IDLE);\n2. (linkstate == IDLE & get_one_fault) |-> (linkstate == LinkFaultDetect);\n3. (linkstate == LinkFaultDetect & get_one_fault & no_new_type & seq_cnt) |-> (linkstate == IDLE & link_fault == seq_type);\n4. (linkstate == LinkFaultDetect & get_one_fault & no_new_type & ~seq_cnt) |-> (seq_cnt == seq_cnt + 1);\n5. (linkstate == LinkFaultDetect & ~get_one_fault & col_cnt_64) |-> (linkstate == IDLE);\n6. (linkstate == LinkFaultDetect & get_one_fault & ~no_new_type) |-> (linkstate == NewFaultType);\n7. (linkstate == NewFaultType) |-> (linkstate == LinkFaultDetect & seq_cnt == 0 & reset_col_cnt == 1);\n8. (reset) |-> (col_cnt == 0);\n9. (reset_col_cnt) |-> (col_cnt == 0);\n10. (~reset & ~reset_col_cnt) |-> (col_cnt == col_cnt + 1);"}, {"file_name": "rxNumCounter.v", "verilog_design": "`include \"timescale.v\" `include \"xgiga_define.v\" `include \"counter.v\" module rxNumCounter(rxclk, reset, receiving, frame_cnt); input rxclk; input reset; input receiving; output[`COUNTER_WIDTH-1:0] frame_cnt; parameter TP =1; counter data_counter(.clk(rxclk), .reset(reset), .load(~receiving), .en(receiving), .value(frame_cnt)); endmodule", "assertions_gpt_4o": "```\n(reset) |-> (frame_cnt == 0);\n(receiving == 1) |-> (frame_cnt != 0);\n(receiving == 0) |-> (frame_cnt == 0);\n(frame_cnt == `COUNTER_WIDTH-1) |-> (receiving == 1);\n```\n"}, {"file_name": "rxStateMachine.v", "verilog_design": "`include \"timescale.v\" `include \"xgiga_define.v\" module rxStateMachine(rxclk, reset, recv_enable, get_sfd, local_invalid, length_error, crc_check_valid, crc_check_invalid, start_da, start_lt, receiving, receiving_d1, good_frame_get, bad_frame_get, get_error_code, wait_crc_check, get_terminator,check_reset); input rxclk; input reset; input recv_enable; input get_sfd; input local_invalid; input length_error; input get_terminator; input crc_check_valid; input crc_check_invalid; input get_error_code; input check_reset; output start_da; output start_lt; output receiving; output receiving_d1; output good_frame_get; output bad_frame_get; output wait_crc_check; parameter IDLE = 0, rxReceiveDA = 1, rxReceiveLT = 2, rxReceiveData = 4; parameter rxGetError = 8, rxIFGWait = 16; parameter TP =1; wire start_da; wire start_lt; wire receiving; reg good_frame_get; reg bad_frame_get; reg[4:0] rxstate, rxstate_next; always@(rxstate, get_sfd, local_invalid, recv_enable, get_error_code, length_error, get_terminator, reset)begin if (reset) begin rxstate_next <=#TP IDLE; end else begin case (rxstate) IDLE: begin if (get_sfd && recv_enable) rxstate_next <=#TP rxReceiveDA; else rxstate_next <=#TP IDLE; end rxReceiveDA: begin rxstate_next <=#TP rxReceiveLT; end rxReceiveLT: begin rxstate_next <=#TP rxReceiveData; end rxReceiveData: begin if (local_invalid |length_error| get_error_code) rxstate_next <=#TP rxGetError; else if (get_terminator) rxstate_next <=#TP rxIFGWait; else rxstate_next <=#TP rxReceiveData; end rxGetError: begin if (get_sfd && recv_enable) rxstate_next <=#TP rxReceiveDA; else rxstate_next <=#TP IDLE; end rxIFGWait : begin if (get_sfd && recv_enable) rxstate_next <=#TP rxReceiveDA; else rxstate_next <=#TP IDLE; end endcase end end always@(posedge rxclk or posedge reset) begin if (reset) rxstate <=#TP IDLE; else rxstate <=#TP rxstate_next; end assign start_da = rxstate[0]; assign start_lt = rxstate[1]; assign receiving = rxstate[2] | rxstate[1] | rxstate[0]; reg receiving_d1; always@(posedge rxclk or posedge reset) begin if (reset) begin receiving_d1<=#TP 0; end else begin receiving_d1<=#TP receiving; end end reg wait_crc_check; always@(posedge rxclk or posedge reset) begin if (reset) wait_crc_check <=#TP 0; else if (rxstate[4]) wait_crc_check <=#TP 1'b1; else if (crc_check_valid || crc_check_invalid||length_error) wait_crc_check <=#TP 1'b0; else wait_crc_check <=#TP wait_crc_check; end always@(posedge rxclk or posedge reset)begin if (reset) begin bad_frame_get <=#TP 0; good_frame_get <=#TP 0; end else if(rxstate[3] || crc_check_invalid || length_error)begin bad_frame_get <=#TP 1'b1; good_frame_get <=#TP 1'b0; end else if (crc_check_valid)begin good_frame_get <=#TP 1'b1; bad_frame_get <=#TP 1'b0; end else if (check_reset)begin good_frame_get <=#TP 1'b0; bad_frame_get <=#TP 1'b0; end end endmodule", "assertions_gpt_4o": "1. (reset) |-> (rxstate_next == IDLE);\n2. (rxstate == IDLE && get_sfd && recv_enable) |-> (rxstate_next == rxReceiveDA);\n3. (rxstate == IDLE && !(get_sfd && recv_enable)) |-> (rxstate_next == IDLE);\n4. (rxstate == rxReceiveDA) |-> (rxstate_next == rxReceiveLT);\n5. (rxstate == rxReceiveLT) |-> (rxstate_next == rxReceiveData);\n6. (rxstate == rxReceiveData && (local_invalid || length_error || get_error_code)) |-> (rxstate_next == rxGetError);\n7. (rxstate == rxReceiveData && get_terminator) |-> (rxstate_next == rxIFGWait);\n8. (rxstate == rxReceiveData && !(local_invalid || length_error || get_error_code || get_terminator)) |-> (rxstate_next == rxReceiveData);\n9. (rxstate == rxGetError && get_sfd && recv_enable) |-> (rxstate_next == rxReceiveDA);\n10. (rxstate == rxGetError && !(get_sfd && recv_enable)) |-> (rxstate_next == IDLE);\n11. (rxstate == rxIFGWait && get_sfd && recv_enable) |-> (rxstate_next == rxReceiveDA);\n12. (rxstate == rxIFGWait && !(get_sfd && recv_enable)) |-> (rxstate_next == IDLE);\n13. (posedge rxclk or posedge reset) |-> (rxstate == IDLE);\n14. (rxstate[0]) |-> (start_da == 1);\n15. (!rxstate[0]) |-> (start_da == 0);\n16. (rxstate[1]) |-> (start_lt == 1);\n17. (!rxstate[1]) |-> (start_lt == 0);\n18. (rxstate[2] || rxstate[1] || rxstate[0]) |-> (receiving == 1);\n19. (!(rxstate[2] || rxstate[1] || rxstate[0])) |-> (receiving == 0);\n20. (posedge rxclk or posedge reset) |-> (receiving_d1 == receiving);\n21. (reset) |-> (wait_crc_check == 0);\n22. (rxstate[4]) |-> (wait_crc_check == 1);\n23. (crc_check_valid || crc_check_invalid || length_error) |-> (wait_crc_check == 0);\n24. (posedge rxclk or posedge reset) |-> (wait_crc_check == wait_crc_check);\n25. (reset) |-> (bad_frame_get == 0 && good_frame_get == 0);\n26. (rxstate[3] || crc_check_invalid || length_error) |-> (bad_frame_get == 1 && good_frame_get == 0);\n27. (crc_check_valid) |-> (good_frame_get == 1 && bad_frame_get == 0);\n28. (check_reset) |-> (good_frame_get == 0 && bad_frame_get == 0)."}, {"file_name": "rxStatModule.v", "verilog_design": "`include \"timescale.v\" `include \"xgiga_define.v\" module rxStatModule(rxclk, reset, good_frame_get,crc_check_invalid, large_error, small_error, receiving, padded_frame, pause_frame, broad_valid, multi_valid, length_65_127, length_128_255, length_256_511, length_512_1023, length_1024_max, jumbo_frame, get_error_code, rxStatRegPlus); input rxclk; input reset; input good_frame_get; input large_error; input small_error; input crc_check_invalid; input receiving; input padded_frame; input pause_frame; input broad_valid; input multi_valid; input length_65_127; input length_128_255; input length_256_511; input length_512_1023; input length_1024_max; input jumbo_frame; input get_error_code; output [17:0] rxStatRegPlus; parameter TP =1; wire[17:0] rxStatRegPlus_tmp; assign rxStatRegPlus_tmp[0] = good_frame_get; assign rxStatRegPlus_tmp[1] = crc_check_invalid; assign rxStatRegPlus_tmp[2] = broad_valid & good_frame_get; assign rxStatRegPlus_tmp[3] = multi_valid & good_frame_get; assign rxStatRegPlus_tmp[4] = padded_frame & good_frame_get; assign rxStatRegPlus_tmp[5] = length_65_127 & good_frame_get; assign rxStatRegPlus_tmp[6] = length_128_255 & good_frame_get; assign rxStatRegPlus_tmp[7] = length_256_511 & good_frame_get; assign rxStatRegPlus_tmp[8] = length_512_1023 & good_frame_get; assign rxStatRegPlus_tmp[9] = length_1024_max & good_frame_get; assign rxStatRegPlus_tmp[10] = pause_frame & good_frame_get; assign rxStatRegPlus_tmp[11] = large_error; assign rxStatRegPlus_tmp[12] = pause_frame & good_frame_get; assign rxStatRegPlus_tmp[13] = 0; assign rxStatRegPlus_tmp[14] = jumbo_frame & good_frame_get; assign rxStatRegPlus_tmp[15] = small_error; assign rxStatRegPlus_tmp[16] = receiving & get_error_code; assign rxStatRegPlus_tmp[17] = receiving; reg[17:0] rxStatRegPlus; always@(posedge rxclk or posedge reset) begin if(reset) rxStatRegPlus <=#TP 0; else rxStatRegPlus <=#TP rxStatRegPlus_tmp; end endmodule", "assertions_gpt_4o": "(good_frame_get) |-> (rxStatRegPlus[0] == 1);\n(crc_check_invalid) |-> (rxStatRegPlus[1] == 1);\n(broad_valid & good_frame_get) |-> (rxStatRegPlus[2] == 1);\n(multi_valid & good_frame_get) |-> (rxStatRegPlus[3] == 1);\n(padded_frame & good_frame_get) |-> (rxStatRegPlus[4] == 1);\n(length_65_127 & good_frame_get) |-> (rxStatRegPlus[5] == 1);\n(length_128_255 & good_frame_get) |-> (rxStatRegPlus[6] == 1);\n(length_256_511 & good_frame_get) |-> (rxStatRegPlus[7] == 1);\n(length_512_1023 & good_frame_get) |-> (rxStatRegPlus[8] == 1);\n(length_1024_max & good_frame_get) |-> (rxStatRegPlus[9] == 1);\n(pause_frame & good_frame_get) |-> (rxStatRegPlus[10] == 1);\n(large_error) |-> (rxStatRegPlus[11] == 1);\n(pause_frame & good_frame_get) |-> (rxStatRegPlus[12] == 1);\n(jumbo_frame & good_frame_get) |-> (rxStatRegPlus[14] == 1);\n(small_error) |-> (rxStatRegPlus[15] == 1);\n(receiving & get_error_code) |-> (rxStatRegPlus[16] == 1);\n(receiving) |-> (rxStatRegPlus[17] == 1);\n(reset) |-> (rxStatRegPlus == 0);"}, {"file_name": "apb.v", "verilog_design": "`timescale 1ns/1ps module apb( input PCLK, input PRESETn, input PSELx, input PWRITE, input PENABLE, input [31:0] PADDR, input [31:0] PWDATA, input [31:0] READ_DATA_ON_RX, input ERROR, input TX_EMPTY, input RX_EMPTY, output [31:0] PRDATA, output reg [13:0] INTERNAL_I2C_REGISTER_CONFIG, output reg [13:0] INTERNAL_I2C_REGISTER_TIMEOUT, output [31:0] WRITE_DATA_ON_TX, output WR_ENA, output RD_ENA, output PREADY, output PSLVERR, output INT_RX, output INT_TX ); assign WR_ENA = (PWRITE == 1'b1 & PENABLE == 1'b1 & PADDR == 32'd0 & PSELx == 1'b1)? 1'b1:1'b0; assign RD_ENA = (PWRITE == 1'b0 & PENABLE == 1'b1 & PADDR == 32'd4 & PSELx == 1'b1)? 1'b1:1'b0; assign PREADY = ((WR_ENA == 1'b1 | RD_ENA == 1'b1 | PADDR == 32'd8 | PADDR == 32'd12) & (PENABLE == 1'b1 & PSELx == 1'b1))? 1'b1:1'b0; assign WRITE_DATA_ON_TX = (PADDR == 32'd0)? PWDATA:PWDATA; assign PRDATA = (PADDR == 32'd4)? READ_DATA_ON_RX:READ_DATA_ON_RX; assign PSLVERR = ERROR; assign INT_TX = TX_EMPTY; assign INT_RX = RX_EMPTY; always@(posedge PCLK) begin if(!PRESETn) begin INTERNAL_I2C_REGISTER_CONFIG <= 14'd0; INTERNAL_I2C_REGISTER_TIMEOUT <= 14'd0; end else begin if(PADDR == 32'd8 && PSELx == 1'b1 && PWRITE == 1'b1 && PREADY == 1'b1) begin INTERNAL_I2C_REGISTER_CONFIG <= PWDATA[13:0]; end else if(PADDR == 32'd12 && PSELx == 1'b1 && PWRITE == 1'b1 && PREADY == 1'b1) begin INTERNAL_I2C_REGISTER_TIMEOUT <= PWDATA[13:0]; end else begin INTERNAL_I2C_REGISTER_CONFIG <= INTERNAL_I2C_REGISTER_CONFIG; end end end endmodule", "assertions_gpt_4o": "(PWRITE == 1'b1 & PENABLE == 1'b1 & PADDR == 32'd0 & PSELx == 1'b1) |-> (WR_ENA == 1'b1);\n(PWRITE == 1'b0 & PENABLE == 1'b1 & PADDR == 32'd4 & PSELx == 1'b1) |-> (RD_ENA == 1'b1);\n((WR_ENA == 1'b1 | RD_ENA == 1'b1 | PADDR == 32'd8 | PADDR == 32'd12) & (PENABLE == 1'b1 & PSELx == 1'b1)) |-> (PREADY == 1'b1);\n(PADDR == 32'd0) |-> (WRITE_DATA_ON_TX == PWDATA);\n(PADDR == 32'd4) |-> (PRDATA == READ_DATA_ON_RX);\n(ERROR) |-> (PSLVERR == 1'b1);\n(TX_EMPTY) |-> (INT_TX == 1'b1);\n(RX_EMPTY) |-> (INT_RX == 1'b1);\n(!PRESETn) |-> (INTERNAL_I2C_REGISTER_CONFIG == 14'd0 & INTERNAL_I2C_REGISTER_TIMEOUT == 14'd0);\n(PADDR == 32'd8 & PSELx == 1'b1 & PWRITE == 1'b1 & PREADY == 1'b1) |-> (INTERNAL_I2C_REGISTER_CONFIG == PWDATA[13:0]);\n(PADDR == 32'd12 & PSELx == 1'b1 & PWRITE == 1'b1 & PREADY == 1'b1) |-> (INTERNAL_I2C_REGISTER_TIMEOUT == PWDATA[13:0]);"}, {"file_name": "can_btl.v", "verilog_design": "`include \"timescale.v\" `include \"can_defines.v\" module can_btl ( clk, rst, rx, tx, baud_r_presc, sync_jump_width, time_segment1, time_segment2, triple_sampling, sample_point, sampled_bit, sampled_bit_q, tx_point, hard_sync, rx_idle, rx_inter, transmitting, transmitter, go_rx_inter, tx_next, go_overload_frame, go_error_frame, go_tx, send_ack, node_error_passive ); parameter Tp = 1; input clk; input rst; input rx; input tx; input [5:0] baud_r_presc; input [1:0] sync_jump_width; input [3:0] time_segment1; input [2:0] time_segment2; input triple_sampling; input rx_idle; input rx_inter; input transmitting; input transmitter; input go_rx_inter; input tx_next; input go_overload_frame; input go_error_frame; input go_tx; input send_ack; input node_error_passive; output sample_point; output sampled_bit; output sampled_bit_q; output tx_point; output hard_sync; reg [6:0] clk_cnt; reg clk_en; reg clk_en_q; reg sync_blocked; reg hard_sync_blocked; reg sampled_bit; reg sampled_bit_q; reg [4:0] quant_cnt; reg [3:0] delay; reg sync; reg seg1; reg seg2; reg resync_latched; reg sample_point; reg [1:0] sample; reg tx_point; reg tx_next_sp; wire go_sync; wire go_seg1; wire go_seg2; wire [7:0] preset_cnt; wire sync_window; wire resync; assign preset_cnt = (baud_r_presc + 1'b1)<<1; assign hard_sync = (rx_idle | rx_inter) & (~rx) & sampled_bit & (~hard_sync_blocked); assign resync = (~rx_idle) & (~rx_inter) & (~rx) & sampled_bit & (~sync_blocked); always @ (posedge clk or posedge rst) begin if (rst) clk_cnt <= 7'h0; else if (clk_cnt >= (preset_cnt-1'b1)) clk_cnt <=#Tp 7'h0; else clk_cnt <=#Tp clk_cnt + 1'b1; end always @ (posedge clk or posedge rst) begin if (rst) clk_en <= 1'b0; else if ({1'b0, clk_cnt} == (preset_cnt-1'b1)) clk_en <=#Tp 1'b1; else clk_en <=#Tp 1'b0; end always @ (posedge clk or posedge rst) begin if (rst) clk_en_q <= 1'b0; else clk_en_q <=#Tp clk_en; end assign go_sync = clk_en_q & seg2 & (quant_cnt[2:0] == time_segment2) & (~hard_sync) & (~resync); assign go_seg1 = clk_en_q & (sync | hard_sync | (resync & seg2 & sync_window) | (resync_latched & sync_window)); assign go_seg2 = clk_en_q & (seg1 & (~hard_sync) & (quant_cnt == (time_segment1 + delay))); always @ (posedge clk or posedge rst) begin if (rst) tx_point <= 1'b0; else tx_point <=#Tp ~tx_point & seg2 & ( clk_en & (quant_cnt[2:0] == time_segment2) | (clk_en | clk_en_q) & (resync | hard_sync) ); end always @ (posedge clk or posedge rst) begin if (rst) resync_latched <= 1'b0; else if (resync & seg2 & (~sync_window)) resync_latched <=#Tp 1'b1; else if (go_seg1) resync_latched <= 1'b0; end always @ (posedge clk or posedge rst) begin if (rst) sync <= 1'b0; else if (clk_en_q) sync <=#Tp go_sync; end always @ (posedge clk or posedge rst) begin if (rst) seg1 <= 1'b1; else if (go_seg1) seg1 <=#Tp 1'b1; else if (go_seg2) seg1 <=#Tp 1'b0; end always @ (posedge clk or posedge rst) begin if (rst) seg2 <= 1'b0; else if (go_seg2) seg2 <=#Tp 1'b1; else if (go_sync | go_seg1) seg2 <=#Tp 1'b0; end always @ (posedge clk or posedge rst) begin if (rst) quant_cnt <= 5'h0; else if (go_sync | go_seg1 | go_seg2) quant_cnt <=#Tp 5'h0; else if (clk_en_q) quant_cnt <=#Tp quant_cnt + 1'b1; end always @ (posedge clk or posedge rst) begin if (rst) delay <= 4'h0; else if (resync & seg1 & (~transmitting | transmitting & (tx_next_sp | (tx & (~rx))))) delay <=#Tp (quant_cnt > {3'h0, sync_jump_width})? ({2'h0, sync_jump_width} + 1'b1) : (quant_cnt + 1'b1); else if (go_sync | go_seg1) delay <=#Tp 4'h0; end assign sync_window = ((time_segment2 - quant_cnt[2:0]) < ( sync_jump_width + 1'b1)); always @ (posedge clk or posedge rst) begin if (rst) sample <= 2'b11; else if (clk_en_q) sample <= {sample[0], rx}; end always @ (posedge clk or posedge rst) begin if (rst) begin sampled_bit <= 1'b1; sampled_bit_q <= 1'b1; sample_point <= 1'b0; end else if (go_error_frame) begin sampled_bit_q <=#Tp sampled_bit; sample_point <=#Tp 1'b0; end else if (clk_en_q & (~hard_sync)) begin if (seg1 & (quant_cnt == (time_segment1 + delay))) begin sample_point <=#Tp 1'b1; sampled_bit_q <=#Tp sampled_bit; if (triple_sampling) sampled_bit <=#Tp (sample[0] & sample[1]) | ( sample[0] & rx) | (sample[1] & rx); else sampled_bit <=#Tp rx; end end else sample_point <=#Tp 1'b0; end always @ (posedge clk or posedge rst) begin if (rst) tx_next_sp <= 1'b0; else if (go_overload_frame | (go_error_frame & (~node_error_passive)) | go_tx | send_ack) tx_next_sp <=#Tp 1'b0; else if (go_error_frame & node_error_passive) tx_next_sp <=#Tp 1'b1; else if (sample_point) tx_next_sp <=#Tp tx_next; end always @ (posedge clk or posedge rst) begin if (rst) sync_blocked <=#Tp 1'b1; else if (clk_en_q) begin if (resync) sync_blocked <=#Tp 1'b1; else if (go_seg2) sync_blocked <=#Tp 1'b0; end end always @ (posedge clk or posedge rst) begin if (rst) hard_sync_blocked <=#Tp 1'b0; else if (hard_sync & clk_en_q | (transmitting & transmitter | go_tx) & tx_point & (~tx_next)) hard_sync_blocked <=#Tp 1'b1; else if (go_rx_inter | (rx_idle | rx_inter) & sample_point & sampled_bit) hard_sync_blocked <=#Tp 1'b0; end endmodule", "assertions_gpt_4o": "(go_sync) |-> (clk_en_q & seg2 & (quant_cnt[2:0] == time_segment2) & (~hard_sync) & (~resync));\n(go_seg1) |-> (clk_en_q & (sync | hard_sync | (resync & seg2 & sync_window) | (resync_latched & sync_window)));\n(go_seg2) |-> (clk_en_q & (seg1 & (~hard_sync) & (quant_cnt == (time_segment1 + delay))));\n(tx_point) |-> (~tx_point & seg2 & (clk_en & (quant_cnt[2:0] == time_segment2) | (clk_en | clk_en_q) & (resync | hard_sync)));\n(resync_latched) |-> (resync & seg2 & (~sync_window));\n(sync) |-> (clk_en_q & go_sync);\n(seg1) |-> (go_seg1);\n(seg2) |-> (go_seg2);\n(quant_cnt == 5'h0) |-> (go_sync | go_seg1 | go_seg2);\n(delay == 4'h0) |-> (go_sync | go_seg1);\n(sync_window) |-> ((time_segment2 - quant_cnt[2:0]) < (sync_jump_width + 1'b1));\n(sample == 2'b11) |-> (clk_en_q);\n(sampled_bit == 1'b1) |-> (rst);\n(sampled_bit_q == 1'b1) |-> (rst);\n(sample_point == 1'b0) |-> (rst);\n(sampled_bit_q == sampled_bit) |-> (go_error_frame);\n(sample_point == 1'b1) |-> (seg1 & (quant_cnt == (time_segment1 + delay)));\n(sampled_bit == rx) |-> (clk_en_q & (~hard_sync) & seg1 & (quant_cnt == (time_segment1 + delay)) & ~triple_sampling);\n(sampled_bit == (sample[0] & sample[1]) | (sample[0] & rx) | (sample[1] & rx)) |-> (clk_en_q & (~hard_sync) & seg1 & (quant_cnt == (time_segment1 + delay)) & triple_sampling);\n(tx_next_sp == 1'b0) |-> (go_overload_frame | (go_error_frame & (~node_error_passive)) | go_tx | send_ack);\n(tx_next_sp == 1'b1) |-> (go_error_frame & node_error_passive);\n(tx_next_sp == tx_next) |-> (sample_point);\n(sync_blocked == 1'b1) |-> (clk_en_q & resync);\n(sync_blocked == 1'b0) |-> (clk_en_q & go_seg2);\n(hard_sync_blocked == 1'b1) |-> (hard_sync & clk_en_q | (transmitting & transmitter | go_tx) & tx_point & (~tx_next));\n(hard_sync_blocked == 1'b0) |-> (go_rx_inter | (rx_idle | rx_inter) & sample_point & sampled_bit);"}, {"file_name": "can_crc.v", "verilog_design": "`include \"timescale.v\" module can_crc (clk, data, enable, initialize, crc); parameter Tp = 1; input clk; input data; input enable; input initialize; output [14:0] crc; reg [14:0] crc; wire crc_next; wire [14:0] crc_tmp; assign crc_next = data ^ crc[14]; assign crc_tmp = {crc[13:0], 1'b0}; always @ (posedge clk) begin if(initialize) crc <= #Tp 15'h0; else if (enable) begin if (crc_next) crc <= #Tp crc_tmp ^ 15'h4599; else crc <= #Tp crc_tmp; end end endmodule", "assertions_gpt_4o": "1. (initialize) |-> (crc == 15'h0);\n2. (enable && !initialize && crc_next) |-> (crc == (crc_tmp ^ 15'h4599));\n3. (enable && !initialize && !crc_next) |-> (crc == crc_tmp);\n4. (!enable && !initialize) |-> (crc == $past(crc));\n5. (crc_next == (data ^ crc[14]));\n6. (crc_tmp == {crc[13:0], 1'b0});"}, {"file_name": "can_fifo.v", "verilog_design": "`include \"timescale.v\" `include \"can_defines.v\" module can_fifo ( clk, rst, wr, data_in, addr, data_out, fifo_selected, reset_mode, release_buffer, extended_mode, overrun, info_empty, info_cnt `ifdef CAN_BIST , mbist_si_i, mbist_so_o, mbist_ctrl_i `endif ); parameter Tp = 1; input clk; input rst; input wr; input [7:0] data_in; input [5:0] addr; input reset_mode; input release_buffer; input extended_mode; input fifo_selected; output [7:0] data_out; output overrun; output info_empty; output [6:0] info_cnt; `ifdef CAN_BIST input mbist_si_i; output mbist_so_o; input [`CAN_MBIST_CTRL_WIDTH - 1:0] mbist_ctrl_i; wire mbist_s_0; `endif `ifdef ALTERA_RAM `else `ifdef ACTEL_APA_RAM `else `ifdef XILINX_RAM `else `ifdef ARTISAN_RAM reg overrun_info[0:63]; `else `ifdef VIRTUALSILICON_RAM reg overrun_info[0:63]; `else reg [7:0] fifo [0:63]; reg [3:0] length_fifo[0:63]; reg overrun_info[0:63]; `endif `endif `endif `endif `endif reg [5:0] rd_pointer; reg [5:0] wr_pointer; reg [5:0] read_address; reg [5:0] wr_info_pointer; reg [5:0] rd_info_pointer; reg wr_q; reg [3:0] len_cnt; reg [6:0] fifo_cnt; reg [6:0] info_cnt; reg latch_overrun; reg initialize_memories; wire [3:0] length_info; wire write_length_info; wire fifo_empty; wire fifo_full; wire info_full; assign write_length_info = (~wr) & wr_q; always @ (posedge clk or posedge rst) begin if (rst) wr_q <=#Tp 1'b0; else if (reset_mode) wr_q <=#Tp 1'b0; else wr_q <=#Tp wr; end always @ (posedge clk or posedge rst) begin if (rst) len_cnt <= 4'h0; else if (reset_mode | write_length_info) len_cnt <=#Tp 4'h0; else if (wr & (~fifo_full)) len_cnt <=#Tp len_cnt + 1'b1; end always @ (posedge clk or posedge rst) begin if (rst) wr_info_pointer <= 6'h0; else if (write_length_info & (~info_full) | initialize_memories) wr_info_pointer <=#Tp wr_info_pointer + 1'b1; else if (reset_mode) wr_info_pointer <=#Tp rd_info_pointer; end always @ (posedge clk or posedge rst) begin if (rst) rd_info_pointer <= 6'h0; else if (release_buffer & (~info_full)) rd_info_pointer <=#Tp rd_info_pointer + 1'b1; end always @ (posedge clk or posedge rst) begin if (rst) rd_pointer <= 5'h0; else if (release_buffer & (~fifo_empty)) rd_pointer <=#Tp rd_pointer + {2'h0, length_info}; end always @ (posedge clk or posedge rst) begin if (rst) wr_pointer <= 5'h0; else if (reset_mode) wr_pointer <=#Tp rd_pointer; else if (wr & (~fifo_full)) wr_pointer <=#Tp wr_pointer + 1'b1; end always @ (posedge clk or posedge rst) begin if (rst) latch_overrun <= 1'b0; else if (reset_mode | write_length_info) latch_overrun <=#Tp 1'b0; else if (wr & fifo_full) latch_overrun <=#Tp 1'b1; end always @ (posedge clk or posedge rst) begin if (rst) fifo_cnt <= 7'h0; else if (reset_mode) fifo_cnt <=#Tp 7'h0; else if (wr & (~release_buffer) & (~fifo_full)) fifo_cnt <=#Tp fifo_cnt + 1'b1; else if ((~wr) & release_buffer & (~fifo_empty)) fifo_cnt <=#Tp fifo_cnt - {3'h0, length_info}; else if (wr & release_buffer & (~fifo_full) & (~fifo_empty)) fifo_cnt <=#Tp fifo_cnt - {3'h0, length_info} + 1'b1; end assign fifo_full = fifo_cnt == 7'd64; assign fifo_empty = fifo_cnt == 7'd0; always @ (posedge clk or posedge rst) begin if (rst) info_cnt <=#Tp 7'h0; else if (reset_mode) info_cnt <=#Tp 7'h0; else if (write_length_info ^ release_buffer) begin if (release_buffer & (~info_empty)) info_cnt <=#Tp info_cnt - 1'b1; else if (write_length_info & (~info_full)) info_cnt <=#Tp info_cnt + 1'b1; end end assign info_full = info_cnt == 7'd64; assign info_empty = info_cnt == 7'd0; always @ (extended_mode or rd_pointer or addr) begin if (extended_mode) read_address = rd_pointer + (addr - 6'd16); else read_address = rd_pointer + (addr - 6'd20); end always @ (posedge clk or posedge rst) begin if (rst) initialize_memories <= 1'b1; else if (&wr_info_pointer) initialize_memories <=#Tp 1'b0; end `ifdef ALTERA_RAM lpm_ram_dp fifo ( .q (data_out), .rdclock (clk), .wrclock (clk), .data (data_in), .wren (wr & (~fifo_full)), .rden (fifo_selected), .wraddress (wr_pointer), .rdaddress (read_address) ); defparam fifo.lpm_width = 8; defparam fifo.lpm_widthad = 6; defparam fifo.lpm_numwords = 64; lpm_ram_dp info_fifo ( .q (length_info), .rdclock (clk), .wrclock (clk), .data (len_cnt & {4{~initialize_memories}}), .wren (write_length_info & (~info_full) | initialize_memories), .wraddress (wr_info_pointer), .rdaddress (rd_info_pointer) ); defparam info_fifo.lpm_width = 4; defparam info_fifo.lpm_widthad = 6; defparam info_fifo.lpm_numwords = 64; lpm_ram_dp overrun_fifo ( .q (overrun), .rdclock (clk), .wrclock (clk), .data ((latch_overrun | (wr & fifo_full)) & (~initialize_memories)), .wren (write_length_info & (~info_full) | initialize_memories), .wraddress (wr_info_pointer), .rdaddress (rd_info_pointer) ); defparam overrun_fifo.lpm_width = 1; defparam overrun_fifo.lpm_widthad = 6; defparam overrun_fifo.lpm_numwords = 64; `else `ifdef ACTEL_APA_RAM actel_ram_64x8_sync fifo ( .DO (data_out), .RCLOCK (clk), .WCLOCK (clk), .DI (data_in), .PO (), .WRB (~(wr & (~fifo_full))), .RDB (~fifo_selected), .WADDR (wr_pointer), .RADDR (read_address) ); actel_ram_64x4_sync info_fifo ( .DO (length_info), .RCLOCK (clk), .WCLOCK (clk), .DI (len_cnt & {4{~initialize_memories}}), .PO (), .WRB (~(write_length_info & (~info_full) | initialize_memories)), .RDB (1'b0), .WADDR (wr_info_pointer), .RADDR (rd_info_pointer) ); actel_ram_64x1_sync overrun_fifo ( .DO (overrun), .RCLOCK (clk), .WCLOCK (clk), .DI ((latch_overrun | (wr & fifo_full)) & (~initialize_memories)), .PO (), .WRB (~(write_length_info & (~info_full) | initialize_memories)), .RDB (1'b0), .WADDR (wr_info_pointer), .RADDR (rd_info_pointer) ); `else `ifdef XILINX_RAM RAMB4_S8_S8 fifo ( .DOA(), .DOB(data_out), .ADDRA({3'h0, wr_pointer}), .CLKA(clk), .DIA(data_in), .ENA(1'b1), .RSTA(1'b0), .WEA(wr & (~fifo_full)), .ADDRB({3'h0, read_address}), .CLKB(clk), .DIB(8'h0), .ENB(1'b1), .RSTB(1'b0), .WEB(1'b0) ); RAMB4_S4_S4 info_fifo ( .DOA(), .DOB(length_info), .ADDRA({4'h0, wr_info_pointer}), .CLKA(clk), .DIA(len_cnt & {4{~initialize_memories}}), .ENA(1'b1), .RSTA(1'b0), .WEA(write_length_info & (~info_full) | initialize_memories), .ADDRB({4'h0, rd_info_pointer}), .CLKB(clk), .DIB(4'h0), .ENB(1'b1), .RSTB(1'b0), .WEB(1'b0) ); RAMB4_S1_S1 overrun_fifo ( .DOA(), .DOB(overrun), .ADDRA({6'h0, wr_info_pointer}), .CLKA(clk), .DIA((latch_overrun | (wr & fifo_full)) & (~initialize_memories)), .ENA(1'b1), .RSTA(1'b0), .WEA(write_length_info & (~info_full) | initialize_memories), .ADDRB({6'h0, rd_info_pointer}), .CLKB(clk), .DIB(1'h0), .ENB(1'b1), .RSTB(1'b0), .WEB(1'b0) ); `else `ifdef VIRTUALSILICON_RAM `ifdef CAN_BIST vs_hdtp_64x8_bist fifo `else vs_hdtp_64x8 fifo `endif ( .RCK (clk), .WCK (clk), .RADR (read_address), .WADR (wr_pointer), .DI (data_in), .DOUT (data_out), .REN (~fifo_selected), .WEN (~(wr & (~fifo_full))) `ifdef CAN_BIST , .mbist_si_i (mbist_si_i), .mbist_so_o (mbist_s_0), .mbist_ctrl_i (mbist_ctrl_i) `endif ); `ifdef CAN_BIST vs_hdtp_64x4_bist info_fifo `else vs_hdtp_64x4 info_fifo `endif ( .RCK (clk), .WCK (clk), .RADR (rd_info_pointer), .WADR (wr_info_pointer), .DI (len_cnt & {4{~initialize_memories}}), .DOUT (length_info), .REN (1'b0), .WEN (~(write_length_info & (~info_full) | initialize_memories)) `ifdef CAN_BIST , .mbist_si_i (mbist_s_0), .mbist_so_o (mbist_so_o), .mbist_ctrl_i (mbist_ctrl_i) `endif ); always @ (posedge clk) begin if (write_length_info & (~info_full) | initialize_memories) overrun_info[wr_info_pointer] <=#Tp (latch_overrun | (wr & fifo_full)) & (~initialize_memories); end assign overrun = overrun_info[rd_info_pointer]; `else `ifdef ARTISAN_RAM `ifdef CAN_BIST art_hstp_64x8_bist fifo ( .CLKR (clk), .CLKW (clk), .AR (read_address), .AW (wr_pointer), .D (data_in), .Q (data_out), .REN (~fifo_selected), .WEN (~(wr & (~fifo_full))), .mbist_si_i (mbist_si_i), .mbist_so_o (mbist_s_0), .mbist_ctrl_i (mbist_ctrl_i) ); art_hstp_64x4_bist info_fifo ( .CLKR (clk), .CLKW (clk), .AR (rd_info_pointer), .AW (wr_info_pointer), .D (len_cnt & {4{~initialize_memories}}), .Q (length_info), .REN (1'b0), .WEN (~(write_length_info & (~info_full) | initialize_memories)), .mbist_si_i (mbist_s_0), .mbist_so_o (mbist_so_o), .mbist_ctrl_i (mbist_ctrl_i) ); `else art_hsdp_64x8 fifo ( .CENA (1'b0), .CENB (1'b0), .CLKA (clk), .CLKB (clk), .AA (read_address), .AB (wr_pointer), .DA (8'h00), .DB (data_in), .QA (data_out), .QB (), .OENA (~fifo_selected), .OENB (1'b1), .WENA (1'b1), .WENB (~(wr & (~fifo_full))) ); art_hsdp_64x4 info_fifo ( .CENA (1'b0), .CENB (1'b0), .CLKA (clk), .CLKB (clk), .AA (rd_info_pointer), .AB (wr_info_pointer), .DA (4'h0), .DB (len_cnt & {4{~initialize_memories}}), .QA (length_info), .QB (), .OENA (1'b0), .OENB (1'b1), .WENA (1'b1), .WENB (~(write_length_info & (~info_full) | initialize_memories)) ); `endif always @ (posedge clk) begin if (write_length_info & (~info_full) | initialize_memories) overrun_info[wr_info_pointer] <=#Tp (latch_overrun | (wr & fifo_full)) & (~initialize_memories); end assign overrun = overrun_info[rd_info_pointer]; `else always @ (posedge clk) begin if (wr & (~fifo_full)) fifo[wr_pointer] <=#Tp data_in; end assign data_out = fifo[read_address]; always @ (posedge clk) begin if (write_length_info & (~info_full) | initialize_memories) length_fifo[wr_info_pointer] <=#Tp len_cnt & {4{~initialize_memories}}; end assign length_info = length_fifo[rd_info_pointer]; always @ (posedge clk) begin if (write_length_info & (~info_full) | initialize_memories) overrun_info[wr_info_pointer] <=#Tp (latch_overrun | (wr & fifo_full)) & (~initialize_memories); end assign overrun = overrun_info[rd_info_pointer]; `endif `endif `endif `endif `endif endmodule", "assertions_gpt_4o": "1. (rst) |-> (wr_q == 0);\n2. (reset_mode) |-> (wr_q == 0);\n3. (wr) |-> (wr_q == 1);\n4. (rst) |-> (len_cnt == 4'h0);\n5. (reset_mode | write_length_info) |-> (len_cnt == 4'h0);\n6. (wr & (~fifo_full)) |-> (len_cnt == len_cnt + 1'b1);\n7. (rst) |-> (wr_info_pointer == 6'h0);\n8. (write_length_info & (~info_full) | initialize_memories) |-> (wr_info_pointer == wr_info_pointer + 1'b1);\n9. (reset_mode) |-> (wr_info_pointer == rd_info_pointer);\n10. (rst) |-> (rd_info_pointer == 6'h0);\n11. (release_buffer & (~info_full)) |-> (rd_info_pointer == rd_info_pointer + 1'b1);\n12. (rst) |-> (rd_pointer == 5'h0);\n13. (release_buffer & (~fifo_empty)) |-> (rd_pointer == rd_pointer + {2'h0, length_info});\n14. (rst) |-> (wr_pointer == 5'h0);\n15. (reset_mode) |-> (wr_pointer == rd_pointer);\n16. (wr & (~fifo_full)) |-> (wr_pointer == wr_pointer + 1'b1);\n17. (rst) |-> (latch_overrun == 1'b0);\n18. (reset_mode | write_length_info) |-> (latch_overrun == 1'b0);\n19. (wr & fifo_full) |-> (latch_overrun == 1'b1);\n20. (rst) |-> (fifo_cnt == 7'h0);\n21. (reset_mode) |-> (fifo_cnt == 7'h0);\n22. (wr & (~release_buffer) & (~fifo_full)) |-> (fifo_cnt == fifo_cnt + 1'b1);\n23. ((~wr) & release_buffer & (~fifo_empty)) |-> (fifo_cnt == fifo_cnt - {3'h0, length_info});\n24. (wr & release_buffer & (~fifo_full) & (~fifo_empty)) |-> (fifo_cnt == fifo_cnt - {3'h0, length_info} + 1'b1);\n25. (fifo_cnt == 7'd64) |-> (fifo_full == 1'b1);\n26. (fifo_cnt == 7'd0) |-> (fifo_empty == 1'b1);\n27. (rst) |-> (info_cnt == 7'h0);\n28. (reset_mode) |-> (info_cnt == 7'h0);\n29. (write_length_info ^ release_buffer) |-> ((release_buffer & (~info_empty)) ? (info_cnt == info_cnt - 1'b1) : (write_length_info & (~info_full)) ? (info_cnt == info_cnt + 1'b1) : 1'b1);\n30. (info_cnt == 7'd64) |-> (info_full == 1'b1);\n31. (info_cnt == 7'd0) |-> (info_empty == 1'b1);\n32. (extended_mode) |-> (read_address == rd_pointer + (addr - 6'd16));\n33. (~extended_mode) |-> (read_address == rd_pointer + (addr - 6'd20));\n34. (rst) |-> (initialize_memories == 1'b1);\n35. (&wr_info_pointer) |-> (initialize_memories == 1'b0);"}, {"file_name": "can_ibo.v", "verilog_design": "module can_ibo ( di, do_can ); input [7:0] di; output [7:0] do_can; assign do_can[0] = di[7]; assign do_can[1] = di[6]; assign do_can[2] = di[5]; assign do_can[3] = di[4]; assign do_can[4] = di[3]; assign do_can[5] = di[2]; assign do_can[6] = di[1]; assign do_can[7] = di[0]; endmodule", "assertions_gpt_4o": "(di[7] == 1) |-> (do_can[0] == 1);\n(di[7] == 0) |-> (do_can[0] == 0);\n(di[6] == 1) |-> (do_can[1] == 1);\n(di[6] == 0) |-> (do_can[1] == 0);\n(di[5] == 1) |-> (do_can[2] == 1);\n(di[5] == 0) |-> (do_can[2] == 0);\n(di[4] == 1) |-> (do_can[3] == 1);\n(di[4] == 0) |-> (do_can[3] == 0);\n(di[3] == 1) |-> (do_can[4] == 1);\n(di[3] == 0) |-> (do_can[4] == 0);\n(di[2] == 1) |-> (do_can[5] == 1);\n(di[2] == 0) |-> (do_can[5] == 0);\n(di[1] == 1) |-> (do_can[6] == 1);\n(di[1] == 0) |-> (do_can[6] == 0);\n(di[0] == 1) |-> (do_can[7] == 1);\n(di[0] == 0) |-> (do_can[7] == 0);"}, {"file_name": "can_register_asyn.v", "verilog_design": "`include \"timescale.v\" module can_register_asyn ( data_in, data_out, we, clk, rst ); parameter WIDTH = 8; parameter RESET_VALUE = 0; input [WIDTH-1:0] data_in; input we; input clk; input rst; output [WIDTH-1:0] data_out; reg [WIDTH-1:0] data_out; always @ (posedge clk or posedge rst) begin if (rst) data_out<=#1 RESET_VALUE; else if (we) data_out<=#1 data_in; end endmodule", "assertions_gpt_4o": "1. (rst) |-> (data_out == RESET_VALUE);\n2. (we && !rst) |-> (data_out == data_in);\n3. (!we && !rst) |-> (data_out == $past(data_out));\n4. (posedge clk && rst) |-> (data_out == RESET_VALUE);\n5. (posedge clk && we && !rst) |-> (data_out == data_in);\n6. (posedge clk && !we && !rst) |-> (data_out == $past(data_out));"}, {"file_name": "can_register_asyn_syn.v", "verilog_design": "`include \"timescale.v\" module can_register_asyn_syn ( data_in, data_out, we, clk, rst, rst_sync ); parameter WIDTH = 8; parameter RESET_VALUE = 0; input [WIDTH-1:0] data_in; input we; input clk; input rst; input rst_sync; output [WIDTH-1:0] data_out; reg [WIDTH-1:0] data_out; always @ (posedge clk or posedge rst) begin if(rst) data_out<=#1 RESET_VALUE; else if (rst_sync) data_out<=#1 RESET_VALUE; else if (we) data_out<=#1 data_in; end endmodule", "assertions_gpt_4o": "1. (rst == 1) |-> (data_out == RESET_VALUE);\n2. (rst_sync == 1) |-> (data_out == RESET_VALUE);\n3. (we == 1 && rst == 0 && rst_sync == 0) |=> (data_out == data_in);\n4. (we == 0 && rst == 0 && rst_sync == 0) |=> (data_out == $past(data_out));\n5. (rst == 0 && rst_sync == 0) |=> (data_out == $past(data_out) || data_out == data_in);"}, {"file_name": "can_register.v", "verilog_design": "`include \"timescale.v\" module can_register ( data_in, data_out, we, clk ); parameter WIDTH = 8; input [WIDTH-1:0] data_in; input we; input clk; output [WIDTH-1:0] data_out; reg [WIDTH-1:0] data_out; always @ (posedge clk) begin if (we) data_out<=#1 data_in; end endmodule", "assertions_gpt_4o": "(we == 1) |-> (data_out == data_in);\n(we == 0) |-> (data_out == $past(data_out));\n(we == 1) |-> (data_out == $past(data_in, 1));\n(we == 0) |-> (data_out == $past(data_out, 1));\n(we == 1) |-> (data_out == $past(data_in));\n(we == 0) |-> (data_out == $past(data_out));"}, {"file_name": "can_register_syn.v", "verilog_design": "`include \"timescale.v\" module can_register_syn ( data_in, data_out, we, clk, rst_sync ); parameter WIDTH = 8; parameter RESET_VALUE = 0; input [WIDTH-1:0] data_in; input we; input clk; input rst_sync; output [WIDTH-1:0] data_out; reg [WIDTH-1:0] data_out; always @ (posedge clk) begin if (rst_sync) data_out<=#1 RESET_VALUE; else if (we) data_out<=#1 data_in; end endmodule", "assertions_gpt_4o": "1. (rst_sync) |-> (data_out == RESET_VALUE);\n2. (we && !rst_sync) |-> (data_out == data_in);\n3. (!we && !rst_sync) |-> (data_out == $past(data_out));\n4. (posedge clk) |-> (data_out inside {RESET_VALUE, data_in, $past(data_out)});\n5. (rst_sync && we) |-> (data_out == RESET_VALUE);\n6. (we && $past(we) && !rst_sync) |-> (data_out == data_in);\n7. (!we && $past(!we) && !rst_sync) |-> (data_out == $past(data_out));"}]